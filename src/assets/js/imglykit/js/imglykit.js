(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("canvas"));
	else if(typeof define === 'function' && define.amd)
		define(["canvas"], factory);
	else if(typeof exports === 'object')
		exports["ImglyKit"] = factory(require("canvas"));
	else
		root["ImglyKit"] = factory(root["canvas"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_7__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libRenderImage = __webpack_require__(2);
	
	var _libRenderImage2 = _interopRequireDefault(_libRenderImage);
	
	var _libImageExporter = __webpack_require__(16);
	
	var _libImageExporter2 = _interopRequireDefault(_libImageExporter);
	
	var _libVersionChecker = __webpack_require__(20);
	
	var _libVersionChecker2 = _interopRequireDefault(_libVersionChecker);
	
	var _constants = __webpack_require__(17);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libExif = __webpack_require__(18);
	
	var _libExif2 = _interopRequireDefault(_libExif);
	
	var _operationsRotationOperation = __webpack_require__(21);
	
	var _operationsRotationOperation2 = _interopRequireDefault(_operationsRotationOperation);
	
	var _operationsFlipOperation = __webpack_require__(25);
	
	var _operationsFlipOperation2 = _interopRequireDefault(_operationsFlipOperation);
	
	/**
	 * @class
	 * @param {Object} options
	 * @param {Image} [options.image] - The source image
	 * @param {HTMLElement} [options.container] - Specifies where the UI should be
	 *                                          added to. If none is given, the UI
	 *                                          will automatically be disabled.
	 * @param {Boolean} [options.ui.enabled=true] - Enables or disables the UI
	 * @param {Boolean} [options.renderOnWindowResize] - Specifies whether the canvas
	 *                                                 should re-render itself when
	 *                                                 the window is being resized.
	 * @param {String} [options.assetsUrl='assets'] - The base path for all external assets.
	 * @param {String} [options.renderer='webgl'] - The renderer identifier. Can either
	 *                                            be 'webgl' or 'canvas'.
	 */
	var VERSION = '2.0.3-13';
	
	var ImglyKit = (function (_EventEmitter) {
	  _inherits(ImglyKit, _EventEmitter);
	
	  function ImglyKit(options) {
	    _classCallCheck(this, ImglyKit);
	
	    _get(Object.getPrototypeOf(ImglyKit.prototype), 'constructor', this).call(this);
	
	    // `options` is required
	    if (typeof options === 'undefined') {
	      throw new Error('No options given.');
	    }
	
	    // Set default options
	    options = _libUtils2['default'].defaults(options, {
	      assetsUrl: 'assets',
	      container: null,
	      renderOnWindowResize: false,
	      versionCheck: true
	    });
	    options.ui = options.ui || {};
	    options.ui = _libUtils2['default'].defaults(options.ui, {
	      enabled: true
	    });
	
	    if (typeof options.image === 'undefined' && !options.ui.enabled) {
	      throw new Error('`options.image` needs to be set when UI is disabled.');
	    }
	
	    /**
	     * @type {Object}
	     * @private
	     */
	    this._options = options;
	
	    /**
	     * The stack of {@link Operation} instances that will be used
	     * to render the final Image
	     * @type {Array.<ImglyKit.Operation>}
	     */
	    this.operationsStack = [];
	
	    /**
	     * The registered UI types that can be selected via the `ui` option
	     * @type {Object.<String, UI>}
	     * @private
	     */
	    this._registeredUIs = {};
	
	    // Register the default UIs
	    this._registerUIs();
	
	    /**
	     * The registered operations
	     * @type {Object.<String, ImglyKit.Operation>}
	     */
	    this._registeredOperations = {};
	
	    // Register the default operations
	    this._registerOperations();
	
	    if (typeof window !== 'undefined' && this._options.versionCheck) {
	      this._versionChecker = new _libVersionChecker2['default'](VERSION);
	    }
	
	    if (this._options.image) {
	      this._parseExif(this._options.image);
	    }
	
	    if (this._options.ui.enabled) {
	      this._initUI();
	      if (this._options.renderOnWindowResize) {
	        this._handleWindowResize();
	      }
	    }
	  }
	
	  /**
	   * The current version of the SDK
	   * @name ImglyKit.version
	   * @internal Keep in sync with package.json
	   */
	
	  /**
	   * Renders the image
	   * @param  {ImglyKit.RenderType} [renderType=ImglyKit.RenderType.DATAURL] - The output type
	   * @param  {ImglyKit.ImageFormat} [imageFormat=ImglyKit.ImageFormat.PNG] - The output image format
	   * @param  {string} [dimensions] - The final dimensions of the image
	   * @param  {Number} [quality] - The image quality, between 0 and 1
	   * @return {Promise}
	   */
	
	  _createClass(ImglyKit, [{
	    key: 'render',
	    value: function render(renderType, imageFormat, dimensions, quality) {
	      var _this = this;
	
	      var settings = _libImageExporter2['default'].validateSettings(renderType, imageFormat);
	
	      renderType = settings.renderType;
	      imageFormat = settings.imageFormat;
	
	      // Create a RenderImage
	      var renderImage = new _libRenderImage2['default'](this._options.image, this.operationsStack, dimensions, this._options.renderer);
	
	      // Set all operations to dirty, since we have another webgl renderer
	      for (var i = 0; i < this.operationsStack.length; i++) {
	        var operation = this.operationsStack[i];
	        if (!operation) {
	          continue;
	        }
	        operation.dirty = true;
	      }
	
	      // Initiate image rendering
	      return renderImage.render().then(function () {
	        var canvas = renderImage.getRenderer().getCanvas();
	        return _libImageExporter2['default']['export'](_this, _this._options.image, canvas, renderType, imageFormat, quality);
	      });
	    }
	
	    /**
	     * Sets the image and parses the exif data
	     * @param {Image} image
	     * @param {Exif} exif = null
	     */
	  }, {
	    key: 'setImage',
	    value: function setImage(image) {
	      var exif = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      this._options.image = image;
	      if (!exif) {
	        this._parseExif(image);
	      } else {
	        this._exif = exif;
	      }
	    }
	
	    /**
	     * Parses the exif data and fixes the orientation if necessary
	     * @param {Image} image
	     * @private
	     */
	  }, {
	    key: '_parseExif',
	    value: function _parseExif(image) {
	      if (_libExif2['default'].isJPEG(image.src)) {
	        this._exif = null;
	        try {
	          this._exif = _libExif2['default'].fromBase64String(image.src);
	        } catch (e) {}
	        if (!this._exif) return;
	
	        var exifTags = this._exif.getTags();
	
	        if (exifTags && exifTags.Orientation) {
	          if (exifTags.Orientation !== 1 && exifTags.Orientation !== 2) {
	            // We need to rotate
	            var degrees = 0;
	            switch (exifTags.Orientation) {
	              case 7:
	              case 8:
	                degrees = -90;
	                break;
	              case 3:
	              case 4:
	                degrees = -180;
	                break;
	              case 5:
	              case 6:
	                degrees = 90;
	                break;
	            }
	
	            var rotationOperation = new _operationsRotationOperation2['default'](this, { degrees: degrees });
	            this.operationsStack.push(rotationOperation);
	          }
	
	          if ([2, 4, 5, 7].indexOf(exifTags.Orientation) !== -1) {
	            var flipOperation = new _operationsFlipOperation2['default'](this, { horizontal: true });
	            this.operationsStack.push(flipOperation);
	          }
	
	          this._exif.setOrientation(1);
	        }
	      }
	    }
	
	    /**
	     * Resets all custom and selected operations
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {}
	
	    /**
	     * Returns the asset path for the given filename
	     * @param  {String} asset
	     * @return {String}
	     */
	  }, {
	    key: 'getAssetPath',
	    value: function getAssetPath(asset) {
	      var isBrowser = typeof window !== 'undefined';
	      if (isBrowser) {
	        /* istanbul ignore next */
	        return this._options.assetsUrl + '/' + asset;
	      } else {
	        var path = __webpack_require__(26);
	        return path.resolve(this._options.assetsUrl, asset);
	      }
	    }
	
	    /**
	     * If `options.renderOnWindowResize` is set to true, this function
	     * will re-render the canvas with a slight delay so that it won't
	     * cause lagging of the resize
	     * @private
	     */
	  }, {
	    key: '_handleWindowResize',
	    value: function _handleWindowResize() {
	      var _this2 = this;
	
	      var timer = null;
	      window.addEventListener('resize', function () {
	        if (timer !== null) {
	          clearTimeout(timer);
	        }
	
	        timer = setTimeout(function () {
	          timer = null;
	          _this2.ui.render();
	        }, 300);
	      });
	    }
	
	    /**
	     * Registers all default UIs
	     * @private
	     */
	  }, {
	    key: '_registerUIs',
	    value: function _registerUIs() {
	      this.registerUI(ImglyKit.NightUI);
	    }
	
	    /**
	     * Registers all default operations
	     * @private
	     */
	  }, {
	    key: '_registerOperations',
	    value: function _registerOperations() {
	      for (var operationName in ImglyKit.Operations) {
	        this.registerOperation(ImglyKit.Operations[operationName]);
	      }
	    }
	
	    /**
	     * Registers the given operation
	     * @param {ImglyKit.Operation} operation - The operation class
	     */
	  }, {
	    key: 'registerOperation',
	    value: function registerOperation(operation) {
	      this._registeredOperations[operation.prototype.identifier] = operation;
	      if (this.ui) {
	        this.ui.addOperation(operation);
	      }
	    }
	
	    /**
	     * Registers the given UI
	     * @param {UI} ui
	     */
	  }, {
	    key: 'registerUI',
	    value: function registerUI(ui) {
	      this._registeredUIs[ui.prototype.identifier] = ui;
	    }
	
	    /**
	     * Initializes the UI
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_initUI',
	    value: function _initUI() {
	      var UI;
	
	      if (this._options.ui.enabled === true) {
	        // Select the first UI by default
	        UI = _libUtils2['default'].values(this._registeredUIs)[0];
	      }
	
	      if (!UI) {
	        return;
	      }
	
	      /**
	       * @type {ImglyKit.UI}
	       */
	      this.ui = new UI(this, this._options);
	      this.ui.pipeEvents(this);
	    }
	
	    /**
	     * Returns the Operation instance with the given identifier,
	     * if it exists
	     * @param {String} identifier
	     * @returns {Operation}
	     */
	  }, {
	    key: 'getOperationFromStack',
	    value: function getOperationFromStack(identifier) {
	      var operation = this.operationsStack.filter(function (operation) {
	        return operation.identifier === identifier;
	      })[0];
	      return operation;
	    }
	
	    /**
	     * Runs the UI, if present
	     */
	  }, {
	    key: 'run',
	    value: function run() {
	      if (typeof this.ui !== 'undefined') {
	        this.ui.run();
	      }
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this._exif.dispose();
	      this._exif = null;
	    }
	  }, {
	    key: 'exif',
	    get: function get() {
	      return this._exif;
	    }
	  }, {
	    key: 'registeredOperations',
	    get: function get() {
	      return this._registeredOperations;
	    }
	  }]);
	
	  return ImglyKit;
	})(_libEventEmitter2['default']);
	
	ImglyKit.version = VERSION;
	
	// Exposed classes
	ImglyKit.RenderImage = _libRenderImage2['default'];
	ImglyKit.Color = __webpack_require__(23);
	ImglyKit.Filter = __webpack_require__(31);
	ImglyKit.Operation = __webpack_require__(22);
	ImglyKit.Operations = {};
	ImglyKit.Operations.Filters = __webpack_require__(45);
	ImglyKit.Operations.Crop = __webpack_require__(47);
	ImglyKit.Operations.Rotation = __webpack_require__(21);
	ImglyKit.Operations.Saturation = __webpack_require__(48);
	ImglyKit.Operations.Contrast = __webpack_require__(49);
	ImglyKit.Operations.Brightness = __webpack_require__(50);
	ImglyKit.Operations.Flip = __webpack_require__(25);
	ImglyKit.Operations.TiltShift = __webpack_require__(51);
	ImglyKit.Operations.RadialBlur = __webpack_require__(53);
	ImglyKit.Operations.Text = __webpack_require__(54);
	ImglyKit.Operations.Stickers = __webpack_require__(55);
	ImglyKit.Operations.Frames = __webpack_require__(56);
	ImglyKit.Operations.Brush = __webpack_require__(57);
	
	ImglyKit.Filters = {};
	ImglyKit.Filters.A15 = __webpack_require__(58);
	ImglyKit.Filters.Breeze = __webpack_require__(59);
	ImglyKit.Filters.BW = __webpack_require__(60);
	ImglyKit.Filters.BWHard = __webpack_require__(61);
	ImglyKit.Filters.Celsius = __webpack_require__(62);
	ImglyKit.Filters.Chest = __webpack_require__(63);
	ImglyKit.Filters.Fixie = __webpack_require__(64);
	ImglyKit.Filters.Food = __webpack_require__(65);
	ImglyKit.Filters.Fridge = __webpack_require__(66);
	ImglyKit.Filters.Front = __webpack_require__(67);
	ImglyKit.Filters.Glam = __webpack_require__(68);
	ImglyKit.Filters.Gobblin = __webpack_require__(69);
	ImglyKit.Filters.K1 = __webpack_require__(70);
	ImglyKit.Filters.K2 = __webpack_require__(71);
	ImglyKit.Filters.K6 = __webpack_require__(72);
	ImglyKit.Filters.KDynamic = __webpack_require__(73);
	ImglyKit.Filters.Lenin = __webpack_require__(74);
	ImglyKit.Filters.Lomo = __webpack_require__(75);
	ImglyKit.Filters.Mellow = __webpack_require__(76);
	ImglyKit.Filters.Morning = __webpack_require__(77);
	ImglyKit.Filters.Orchid = __webpack_require__(78);
	ImglyKit.Filters.Pola = __webpack_require__(79);
	ImglyKit.Filters.Pola669 = __webpack_require__(80);
	ImglyKit.Filters.Quozi = __webpack_require__(81);
	ImglyKit.Filters.Semired = __webpack_require__(82);
	ImglyKit.Filters.Sunny = __webpack_require__(83);
	ImglyKit.Filters.Texas = __webpack_require__(84);
	ImglyKit.Filters.X400 = __webpack_require__(85);
	
	// Exposed constants
	ImglyKit.RenderType = _constants.RenderType;
	ImglyKit.ImageFormat = _constants.ImageFormat;
	ImglyKit.Vector2 = __webpack_require__(4);
	
	// UI
	ImglyKit.NightUI = __webpack_require__(86);
	
	exports['default'] = ImglyKit;
	module.exports = exports['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	/**
	 * EventEmitter (ES6) from:
	 * https://gist.github.com/bloodyowl/41b1de3388c626796eca
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var DEFAULT_MAX_LISTENERS = 12;
	
	function error(message) {
	  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	    args[_key - 1] = arguments[_key];
	  }
	
	  console.error.apply(console, [message].concat(args));
	  console.trace();
	}
	
	var EventEmitter = (function () {
	  function EventEmitter() {
	    _classCallCheck(this, EventEmitter);
	
	    this._maxListeners = DEFAULT_MAX_LISTENERS;
	    this._events = {};
	    this._pipeDestinations = [];
	  }
	
	  _createClass(EventEmitter, [{
	    key: 'pipeEvents',
	    value: function pipeEvents(destination) {
	      this._pipeDestinations.push(destination);
	    }
	  }, {
	    key: 'unpipeEvents',
	    value: function unpipeEvents(destination) {
	      var i = this._pipeDestinations.indexOf(destination);
	      if (i === -1) return;
	      this._pipeDestinations.splice(i, 1);
	    }
	  }, {
	    key: 'on',
	    value: function on(type, listener) {
	      if (typeof listener !== 'function') {
	        throw new TypeError();
	      }
	
	      var listeners = this._events[type] || (this._events[type] = []);
	      if (listeners.indexOf(listener) !== -1) {
	        return this;
	      }
	      listeners.push(listener);
	
	      if (listeners.length > this._maxListeners) {
	        error('possible memory leak, added %i %s listeners,\n        use EventEmitter#setMaxListeners(number) if you\n        want to increase the limit (%i now)', listeners.length, type, this._maxListeners);
	      }
	      return this;
	    }
	  }, {
	    key: 'once',
	    value: function once(type, listener) {
	      var eventsInstance = this;
	      function onceCallback() {
	        eventsInstance.off(type, onceCallback);
	        listener.apply(null, arguments);
	      }
	      return this.on(type, onceCallback);
	    }
	  }, {
	    key: 'off',
	    value: function off(type) {
	      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        args[_key2 - 1] = arguments[_key2];
	      }
	
	      if (args.length === 0) {
	        this._events[type] = null;
	        return this;
	      }
	
	      var listener = args[0];
	      if (typeof listener !== 'function') {
	        throw new TypeError();
	      }
	
	      var listeners = this._events[type];
	      if (!listeners || !listeners.length) {
	        return this;
	      }
	
	      var indexOfListener = listeners.indexOf(listener);
	      if (indexOfListener === -1) {
	        return this;
	      }
	
	      listeners.splice(indexOfListener, 1);
	      return this;
	    }
	  }, {
	    key: 'emit',
	    value: function emit(type) {
	      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
	        args[_key3 - 1] = arguments[_key3];
	      }
	
	      this._pipeDestinations.forEach(function (dest) {
	        dest.emit.apply(dest, [type].concat(args));
	      });
	
	      var listeners = this._events[type];
	      if (!listeners || !listeners.length) {
	        return false;
	      }
	
	      listeners.forEach(function (fn) {
	        return fn.apply(null, args);
	      });
	
	      return true;
	    }
	  }, {
	    key: 'setMaxListeners',
	    value: function setMaxListeners(newMaxListeners) {
	      if (parseInt(newMaxListeners, 10) !== newMaxListeners) {
	        throw new TypeError();
	      }
	
	      this._maxListeners = newMaxListeners;
	    }
	  }]);
	
	  return EventEmitter;
	})();
	
	exports['default'] = EventEmitter;
	module.exports = exports['default'];

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _eventEmitter = __webpack_require__(1);
	
	var _eventEmitter2 = _interopRequireDefault(_eventEmitter);
	
	var _imageDimensions = __webpack_require__(3);
	
	var _imageDimensions2 = _interopRequireDefault(_imageDimensions);
	
	var _mathVector2 = __webpack_require__(4);
	
	var _mathVector22 = _interopRequireDefault(_mathVector2);
	
	var _renderersCanvasRenderer = __webpack_require__(5);
	
	var _renderersCanvasRenderer2 = _interopRequireDefault(_renderersCanvasRenderer);
	
	var _renderersWebglRenderer = __webpack_require__(12);
	
	var _renderersWebglRenderer2 = _interopRequireDefault(_renderersWebglRenderer);
	
	var _utils = __webpack_require__(13);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	/**
	 * Handles the image rendering process
	 * @class
	 * @alias ImglyKit.RenderImage
	 * @param {Image} image
	 * @param {Array.<ImglyKit.Operation>} operationsStack
	 * @param {string} dimensions
	 * @param {string} preferredRenderer
	 * @private
	 */
	
	var RenderImage = (function (_EventEmitter) {
	  _inherits(RenderImage, _EventEmitter);
	
	  function RenderImage(image, operationsStack, dimensions, preferredRenderer) {
	    _classCallCheck(this, RenderImage);
	
	    _get(Object.getPrototypeOf(RenderImage.prototype), 'constructor', this).call(this);
	
	    /**
	     * @type {Object}
	     * @private
	     */
	    this._options = {
	      preferredRenderer: preferredRenderer
	    };
	
	    /**
	     * @type {Boolean}
	     * @private
	     * @default false
	     */
	    this._webglEnabled = false;
	
	    /**
	     * @type {Renderer}
	     * @private
	     */
	    this._renderer = null;
	
	    /**
	     * @type {Image}
	     * @private
	     */
	    this._image = image;
	
	    /**
	     * @type {Array.<ImglyKit.Operation>}
	     * @private
	     */
	    this._stack = operationsStack;
	
	    /**
	     * @type {ImglyKit.ImageDimensions}
	     * @private
	     */
	    this._dimensions = new _imageDimensions2['default'](dimensions);
	
	    /**
	     * @type {Vector2}
	     * @private
	     */
	    this._initialDimensions = new _mathVector22['default'](this._image.width, this._image.height);
	
	    this._initRenderer();
	  }
	
	  /**
	   * Creates a renderer (canvas or webgl, depending on support)
	   * @return {Promise}
	   * @private
	   */
	
	  _createClass(RenderImage, [{
	    key: '_initRenderer',
	    value: function _initRenderer() {
	      var _this = this;
	
	      /* istanbul ignore if */
	      if (_renderersWebglRenderer2['default'].isSupported() && this._options.preferredRenderer !== 'canvas') {
	        this._renderer = new _renderersWebglRenderer2['default'](this._initialDimensions, null, this._image);
	        this._webglEnabled = true;
	      } else if (_renderersCanvasRenderer2['default'].isSupported()) {
	        this._renderer = new _renderersCanvasRenderer2['default'](this._initialDimensions, null, this._image);
	        this._webglEnabled = false;
	      }
	
	      /* istanbul ignore if */
	      if (this._renderer === null) {
	        throw new Error('Neither Canvas nor WebGL renderer are supported.');
	      }
	
	      this._renderer.on('error', function (err) {
	        return _this.emit('error', err);
	      });
	    }
	
	    /**
	     * Renders the image
	     * @return {Promise}
	     */
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      var stack = this.sanitizedStack;
	      var initialDimensions = this._renderer.getInitialDimensionsForStack(stack, this._dimensions);
	      this._renderer.resizeTo(initialDimensions);
	      this._renderer.drawImage(this._image);
	
	      var validationPromises = [];
	      for (var i = 0; i < stack.length; i++) {
	        var operation = stack[i];
	        validationPromises.push(operation.validateSettings());
	      }
	
	      return Promise.all(validationPromises).then(function () {
	        var promise = Promise.resolve();
	
	        var _loop = function (i) {
	          var operation = stack[i];
	          promise = promise.then(function () {
	            return new Promise(function (resolve, reject) {
	              _utils2['default'].requestAnimationFrame(function () {
	                operation.render(_this2._renderer);
	                resolve();
	              });
	            });
	          });
	        };
	
	        for (var i = 0; i < stack.length; i++) {
	          _loop(i);
	        }
	        return promise;
	      }).then(function () {
	        return _this2._renderer.renderFinal();
	      }).then(function () {
	        return _this2._renderer.postRender(_this2._dimensions);
	      });
	    }
	
	    /**
	     * Returns the renderer
	     * @return {Renderer}
	     */
	  }, {
	    key: 'getRenderer',
	    value: function getRenderer() {
	      return this._renderer;
	    }
	
	    /**
	     * Returns the operations stack without falsy values
	     * @type {Array.<Operation>}
	     */
	  }, {
	    key: 'sanitizedStack',
	    get: function get() {
	      var sanitizedStack = [];
	      for (var i = 0; i < this._stack.length; i++) {
	        var operation = this._stack[i];
	        if (!operation) continue;
	        sanitizedStack.push(operation);
	      }
	      return sanitizedStack;
	    }
	  }]);
	
	  return RenderImage;
	})(_eventEmitter2['default']);
	
	exports['default'] = RenderImage;
	module.exports = exports['default'];

/***/ },
/* 3 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Parses the dimensions string and provides calculation functions
	 * @class
	 * @alias ImglyKit.ImageDimensions
	 * @param {string} dimensions
	 * @private
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var ImageDimensions = (function () {
	  function ImageDimensions(dimensions) {
	    _classCallCheck(this, ImageDimensions);
	
	    /**
	     * The available dimension modifiers
	     * @type {Object}
	     * @private
	     */
	    this._modifiers = {
	      FIXED: '!'
	    };
	
	    /**
	     * @type {string}
	     * @private
	     */
	    this._dimensionsString = dimensions;
	
	    /**
	     * An object that represents the parsed dimensions string
	     * @type {Object}
	     */
	    this._rules = this._parse();
	
	    this._validateRules();
	  }
	
	  /**
	   * Parses the dimensions string
	   * @private
	   */
	
	  _createClass(ImageDimensions, [{
	    key: '_parse',
	    value: function _parse() {
	      if (typeof this._dimensionsString === 'undefined' || this._dimensionsString === null) {
	        return null;
	      }
	
	      var match = this._dimensionsString.match(/^([0-9]+)?x([0-9]+)?([\!])?$/i);
	      if (!match) {
	        throw new Error('Invalid size option: ' + this._dimensionsString);
	      }
	
	      return {
	        x: isNaN(match[1]) ? null : parseInt(match[1], 10),
	        y: isNaN(match[2]) ? null : parseInt(match[2], 10),
	        modifier: match[3]
	      };
	    }
	
	    /**
	     * Validates the rules
	     * @private
	     */
	  }, {
	    key: '_validateRules',
	    value: function _validateRules() {
	      if (this._rules === null) return;
	
	      var xAvailable = this._rules.x !== null;
	      var yAvailable = this._rules.y !== null;
	
	      if (this._rules.modifier === this._modifiers.FIXED && !(xAvailable && yAvailable)) {
	        throw new Error('Both `x` and `y` have to be set when using the fixed (!) modifier.');
	      }
	
	      if (!xAvailable && !yAvailable) {
	        throw new Error('Neither `x` nor `y` are given.');
	      }
	    }
	
	    /**
	     * Calculates the final dimensions using the dimensions string and the
	     * given initial dimensions
	     * @param  {Vector2} initialDimensions
	     * @return {Vector2}
	     */
	  }, {
	    key: 'calculateFinalDimensions',
	    value: function calculateFinalDimensions(initialDimensions) {
	      var dimensions = initialDimensions.clone(),
	          ratio;
	
	      if (this._rules === null) return dimensions;
	
	      /* istanbul ignore else */
	      if (this._rules.modifier === this._modifiers.FIXED) {
	        // Fixed dimensions
	        dimensions.set(this._rules.x, this._rules.y);
	      } else if (this._rules.x !== null && this._rules.y !== null) {
	        // Both x and y given, resize to fit
	        ratio = Math.min(this._rules.x / dimensions.x, this._rules.y / dimensions.y);
	        dimensions.multiply(ratio);
	      } else if (this._rules.x !== null) {
	        // Fixed x, y by ratio
	        ratio = initialDimensions.y / initialDimensions.x;
	        dimensions.x = this._rules.x;
	        dimensions.y = dimensions.x * ratio;
	      } else if (this._rules.y !== null) {
	        // Fixed y, x by ratio
	        ratio = initialDimensions.x / initialDimensions.y;
	        dimensions.y = this._rules.y;
	        dimensions.x = dimensions.y * ratio;
	      }
	
	      return dimensions;
	    }
	  }]);
	
	  return ImageDimensions;
	})();
	
	exports['default'] = ImageDimensions;
	module.exports = exports['default'];

/***/ },
/* 4 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Represents a 2-dimensional vector while providing math functions to
	 * modify / clone the vector. Fully chainable.
	 * @class
	 * @alias ImglyKit.Vector2
	 * @param {number} x
	 * @param {number} y
	 * @private
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Vector2 = (function () {
	  function Vector2(x, y) {
	    _classCallCheck(this, Vector2);
	
	    this.x = x;
	    this.y = y;
	    if (typeof this.x === 'undefined') {
	      this.x = 0;
	    }
	    if (typeof this.y === 'undefined') {
	      this.y = 0;
	    }
	  }
	
	  /**
	   * Sets the given values
	   * @param {number} x
	   * @param {number} y
	   * @return {Vector2}
	   */
	
	  _createClass(Vector2, [{
	    key: 'set',
	    value: function set(x, y) {
	      this.x = x;
	      this.y = y;
	      return this;
	    }
	
	    /**
	     * Creates a clone of this vector
	     * @return {Vector2}
	     */
	  }, {
	    key: 'clone',
	    value: function clone() {
	      return new Vector2(this.x, this.y);
	    }
	
	    /**
	     * Copies the values of the given vector
	     * @param  {Vector2} other
	     * @return {Vector2}
	     */
	  }, {
	    key: 'copy',
	    value: function copy(other) {
	      this.x = other.x;
	      this.y = other.y;
	      return this;
	    }
	
	    /**
	     * Clamps this vector with the given Vector2 / number
	     * @param  {(number|Vector2)} minimum
	     * @param  {(number|Vector2)} maximum
	     * @return {Vector2}
	     */
	  }, {
	    key: 'clamp',
	    value: function clamp(minimum, maximum) {
	      var minimumSet = minimum !== null && typeof minimum !== 'undefined';
	      var maximumSet = maximum !== null && typeof maximum !== 'undefined';
	
	      /* istanbul ignore else  */
	      if (!(minimum instanceof Vector2) && minimumSet) {
	        minimum = new Vector2(minimum, minimum);
	      }
	      /* istanbul ignore else  */
	      if (!(maximum instanceof Vector2) && maximumSet) {
	        maximum = new Vector2(maximum, maximum);
	      }
	
	      if (minimumSet) {
	        this.x = Math.max(minimum.x, this.x);
	        this.y = Math.max(minimum.y, this.y);
	      }
	
	      if (maximumSet) {
	        this.x = Math.min(maximum.x, this.x);
	        this.y = Math.min(maximum.y, this.y);
	      }
	      return this;
	    }
	
	    /**
	     * Divides this vector by the given Vector2 / number
	     * @param  {(number|Vector2)} divisor
	     * @param  {number} [y]
	     * @return {Vector2}
	     */
	  }, {
	    key: 'divide',
	    value: function divide(divisor, y) {
	      if (divisor instanceof Vector2) {
	        this.x /= divisor.x;
	        this.y /= divisor.y;
	      } else {
	        this.x /= divisor;
	        this.y /= typeof y === 'undefined' ? divisor : y;
	      }
	      return this;
	    }
	
	    /**
	     * Subtracts the given Vector2 / number from this vector
	     * @param  {(number|Vector2)} subtrahend
	     * @param  {number} [y]
	     * @return {Vector2}
	     */
	  }, {
	    key: 'subtract',
	    value: function subtract(subtrahend, y) {
	      if (subtrahend instanceof Vector2) {
	        this.x -= subtrahend.x;
	        this.y -= subtrahend.y;
	      } else {
	        this.x -= subtrahend;
	        this.y -= typeof y === 'undefined' ? subtrahend : y;
	      }
	      return this;
	    }
	
	    /**
	     * Multiplies the given Vector2 / number with this vector
	     * @param  {(number|Vector2)} subtrahend
	     * @param  {number} [y]
	     * @return {Vector2}
	     */
	  }, {
	    key: 'multiply',
	    value: function multiply(factor, y) {
	      if (factor instanceof Vector2) {
	        this.x *= factor.x;
	        this.y *= factor.y;
	      } else {
	        this.x *= factor;
	        this.y *= typeof y === 'undefined' ? factor : y;
	      }
	      return this;
	    }
	
	    /**
	     * Adds the given Vector2 / numbers to this vector
	     * @param {(number|Vector2)} addend
	     * @param {number} [y]
	     */
	  }, {
	    key: 'add',
	    value: function add(addend, y) {
	      if (addend instanceof Vector2) {
	        this.x += addend.x;
	        this.y += addend.y;
	      } else {
	        this.x += addend;
	        this.y += typeof y === 'undefined' ? addend : y;
	      }
	      return this;
	    }
	
	    /**
	     * Checks whether the x and y value are the same as the given ones
	     * @param  {(number|Vector2)} vec
	     * @param  {number} y
	     * @return {boolean}
	     */
	  }, {
	    key: 'equals',
	    value: function equals(vec, y) {
	      if (vec instanceof Vector2) {
	        return vec.x === this.x && vec.y === this.y;
	      } else {
	        return vec === this.x && y === this.y;
	      }
	    }
	
	    /**
	     * Flips the x and y values of this vector
	     * @return {Vector2}
	     */
	  }, {
	    key: 'flip',
	    value: function flip() {
	      var tempX = this.x;
	      this.x = this.y;
	      this.y = tempX;
	      return this;
	    }
	
	    /**
	     * Rounds the values of this vector
	     * @returns {Vector2}
	     */
	  }, {
	    key: 'round',
	    value: function round() {
	      this.x = Math.round(this.x);
	      this.y = Math.round(this.y);
	      return this;
	    }
	
	    /**
	     * Rounds up the values of this vector
	     * @returns {Vector2}
	     */
	  }, {
	    key: 'ceil',
	    value: function ceil() {
	      this.x = Math.ceil(this.x);
	      this.y = Math.ceil(this.y);
	      return this;
	    }
	
	    /**
	     * Rounds down the values of this vector
	     * @returns {Vector2}
	     */
	  }, {
	    key: 'floor',
	    value: function floor() {
	      this.x = Math.floor(this.x);
	      this.y = Math.floor(this.y);
	      return this;
	    }
	
	    /**
	     * Makes both numbers of this vector positive
	     * @returns {Vector2}
	     */
	  }, {
	    key: 'abs',
	    value: function abs() {
	      this.x = Math.abs(this.x);
	      this.y = Math.abs(this.y);
	      return this;
	    }
	
	    /**
	     * Returns a string representation of this vector
	     * @return {String}
	     */
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return 'Vector2({ x: ' + this.x + ', y: ' + this.y + ' })';
	    }
	  }]);
	
	  return Vector2;
	})();
	
	exports['default'] = Vector2;
	module.exports = exports['default'];

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _renderer = __webpack_require__(6);
	
	var _renderer2 = _interopRequireDefault(_renderer);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	/**
	 * @class
	 * @alias ImglyKit.CanvasRenderer
	 * @extends {ImglyKit.Renderer}
	 * @private
	 */
	
	var CanvasRenderer = (function (_Renderer) {
	  _inherits(CanvasRenderer, _Renderer);
	
	  function CanvasRenderer() {
	    _classCallCheck(this, CanvasRenderer);
	
	    _get(Object.getPrototypeOf(CanvasRenderer.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(CanvasRenderer, [{
	    key: 'cache',
	
	    /**
	     * Caches the current canvas content for the given identifier
	     * @param {String} identifier
	     */
	    value: function cache(identifier) {
	      this._cache[identifier] = {
	        data: this._context.getImageData(0, 0, this._canvas.width, this._canvas.height),
	        size: new _libMathVector22['default'](this._canvas.width, this._canvas.height)
	      };
	    }
	
	    /**
	     * Draws the stored texture / image data for the given identifier
	     * @param {String} identifier
	     */
	  }, {
	    key: 'drawCached',
	    value: function drawCached(identifier) {
	      var _cache$identifier = this._cache[identifier];
	      var data = _cache$identifier.data;
	      var size = _cache$identifier.size;
	
	      this._canvas.width = size.x;
	      this._canvas.height = size.y;
	      this._context.putImageData(data, 0, 0);
	    }
	
	    /**
	     * Checks whether this type of renderer is supported in the current environment
	     * @abstract
	     * @returns {boolean}
	     */
	  }, {
	    key: '_getContext',
	
	    /**
	     * Gets the rendering context from the Canva
	     * @return {RenderingContext}
	     * @abstract
	     */
	    value: function _getContext() {
	      /* istanbul ignore next */
	      return this._canvas.getContext('2d');
	    }
	
	    /**
	     * Draws the given image on the canvas
	     * @param  {Image} image
	     * @returns {Promis}
	     */
	  }, {
	    key: 'drawImage',
	    value: function drawImage(image) {
	      this._context.drawImage(image, 0, 0, image.width, image.height, 0, 0, this._canvas.width, this._canvas.height);
	      return _vendorPromise2['default'].resolve();
	    }
	
	    /**
	     * Resizes the current canvas picture to the given dimensions
	     * @param  {Vector2} dimensions
	     * @return {Promise}
	     */
	  }, {
	    key: 'resizeTo',
	    value: function resizeTo(dimensions) {
	      dimensions = dimensions.clone().floor();
	      if (this._canvas.width === dimensions.x && this._canvas.height === dimensions.y) {
	        return;
	      }
	
	      // Create a temporary canvas to draw to
	      var newCanvas = this.createCanvas();
	      newCanvas.width = dimensions.x;
	      newCanvas.height = dimensions.y;
	      var newContext = newCanvas.getContext('2d');
	
	      // Draw the source canvas onto the new one
	      newContext.drawImage(this._canvas, 0, 0, this._canvas.width, this._canvas.height, 0, 0, newCanvas.width, newCanvas.height);
	
	      // Set the new canvas and context
	      this.setCanvas(newCanvas);
	    }
	
	    /**
	     * Returns a cloned version of the current canvas
	     * @return {Canvas}
	     */
	  }, {
	    key: 'cloneCanvas',
	    value: function cloneCanvas() {
	      var canvas = this.createCanvas();
	      var context = canvas.getContext('2d');
	
	      // Resize the canvas
	      canvas.width = this._canvas.width;
	      canvas.height = this._canvas.height;
	
	      // Draw the current canvas on the new one
	      context.drawImage(this._canvas, 0, 0);
	
	      return canvas;
	    }
	
	    /**
	     * Resets the renderer
	     * @param {Boolean} resetCache = false
	     * @override
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      var resetCache = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      if (resetCache) {
	        this._cache = [];
	      }
	    }
	
	    /**
	     * Returns the initial dimensions before any operations have been applied
	     * @param {Array.<Operation>} stack
	     * @param {ImageDimensions} dimensions
	     */
	  }, {
	    key: 'getInitialDimensionsForStack',
	    value: function getInitialDimensionsForStack(stack, dimensions) {
	      // Since canvas operations resize the canvas, the initial
	      // dimensions is the same as the image dimensions
	      return new _libMathVector22['default'](this._image.width, this._image.height);
	    }
	
	    /**
	     * Sets the canvas dimensions
	     * @param {Vector2} dimensions
	     */
	  }, {
	    key: 'setSize',
	    value: function setSize(dimensions) {
	      dimensions = dimensions.clone().floor();
	      if (this._canvas.width === dimensions.x && this._canvas.height === dimensions.y) {
	        return;
	      }
	
	      this._canvas.width = dimensions.x;
	      this._canvas.height = dimensions.y;
	      this._size.copy(dimensions);
	    }
	
	    /**
	     * Gets called after the rendering has been done. Resizes the canvas
	     * to its final size
	     * @param {ImageDimensions} dimensions
	     */
	  }, {
	    key: 'postRender',
	    value: function postRender(dimensions) {
	      var canvasDimensions = new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	      var newDimensions = dimensions.calculateFinalDimensions(canvasDimensions);
	      this.resizeTo(newDimensions);
	    }
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      var elem = this.prototype.createCanvas();
	      return !!(elem.getContext && elem.getContext('2d'));
	    }
	  }, {
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this renderer
	     * @type {String}
	     */
	    get: function get() {
	      return 'canvas';
	    }
	  }]);
	
	  return CanvasRenderer;
	})(_renderer2['default']);
	
	exports['default'] = CanvasRenderer;
	module.exports = exports['default'];

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint unused:false */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	/**
	 * @class
	 * @alias ImglyKit.Renderer
	 * @param {Vector2} dimensions
	 * @private
	 */
	
	var Renderer = (function (_EventEmitter) {
	  _inherits(Renderer, _EventEmitter);
	
	  function Renderer(dimensions, canvas, image) {
	    _classCallCheck(this, Renderer);
	
	    _get(Object.getPrototypeOf(Renderer.prototype), 'constructor', this).call(this);
	
	    this._size = new _libMathVector22['default'](image.width, image.height);
	
	    /**
	     * @type {Canvas}
	     * @private
	     */
	    this._canvas = canvas || this.createCanvas();
	
	    if (!canvas) {
	      this.setSize(dimensions);
	    }
	
	    /**
	     * @type {RenderingContext}
	     * @private
	     */
	    this._context = this._getContext();
	
	    /**
	     * The texture / image data cache
	     * @type {Object.<String, *>}
	     */
	    this._cache = {};
	
	    this._image = image;
	  }
	
	  /**
	   * A unique string that identifies this renderer
	   * @type {String}
	   */
	
	  _createClass(Renderer, [{
	    key: 'cache',
	
	    /**
	     * Caches the current canvas content for the given identifier
	     * @param {String} identifier
	     */
	    value: function cache(identifier) {}
	
	    /**
	     * Draws the stored texture / image data for the given identifier
	     * @param {String} identifier
	     */
	  }, {
	    key: 'drawCached',
	    value: function drawCached(identifier) {}
	
	    /**
	     * Creates a new canvas
	     * @param {Number} [width]
	     * @param {Number} [height]
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: 'createCanvas',
	    value: function createCanvas(width, height) {
	      var isBrowser = typeof window !== 'undefined';
	      var canvas;
	      if (isBrowser) {
	        /* istanbul ignore next */
	        canvas = document.createElement('canvas');
	      } else {
	        var Canvas = __webpack_require__(7);
	        canvas = new Canvas();
	      }
	
	      // Apply width
	      if (typeof width !== 'undefined') {
	        canvas.width = width;
	      }
	
	      // Apply height
	      if (typeof height !== 'undefined') {
	        canvas.height = height;
	      }
	
	      return canvas;
	    }
	
	    /**
	     * Returns the current size of the canvas
	     * @return {Vector2}
	     */
	  }, {
	    key: 'getSize',
	    value: function getSize() {
	      return new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	    }
	
	    /**
	     * Gets the rendering context from the Canva
	     * @return {RenderingContext}
	     * @abstract
	     */
	  }, {
	    key: '_getContext',
	    value: function _getContext() {
	      /* istanbul ignore next */
	      throw new Error('Renderer#_getContext is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Resizes the current canvas picture to the given dimensions
	     * @param  {Vector2} dimensions
	     * @return {Promise}
	     * @abstract
	     */
	  }, {
	    key: 'resizeTo',
	    value: function resizeTo(dimensions) {
	      /* istanbul ignore next */
	      throw new Error('Renderer#resizeTo is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Draws the given image on the canvas
	     * @param  {Image} image
	     * @abstract
	     */
	  }, {
	    key: 'drawImage',
	    value: function drawImage(image) {
	      /* istanbul ignore next */
	      throw new Error('Renderer#drawImage is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Gets called after the stack has been rendered
	     * @param  {Image} image
	     */
	  }, {
	    key: 'renderFinal',
	    value: function renderFinal() {}
	
	    /**
	     * Returns the canvas
	     * @return {Canvas}
	     */
	  }, {
	    key: 'getCanvas',
	    value: function getCanvas() {
	      return this._canvas;
	    }
	
	    /**
	     * Returns the context
	     * @return {RenderingContext}
	     */
	  }, {
	    key: 'getContext',
	    value: function getContext() {
	      return this._context;
	    }
	
	    /**
	     * Sets the current canvas to the given one
	     * @param {Canvas} canvas
	     */
	  }, {
	    key: 'setCanvas',
	    value: function setCanvas(canvas) {
	      this._canvas = canvas;
	      this._context = this._getContext();
	
	      this.emit('new-canvas', this._canvas);
	    }
	
	    /**
	     * Returns the canvas size after all operations have been applied
	     * @param {Array.<Operation>} stack
	     * @param {ImageDimensions} dimensions
	     */
	  }, {
	    key: 'getOutputDimensionsForStack',
	    value: function getOutputDimensionsForStack(stack, dimensions) {
	      var _this = this;
	
	      var size = new _libMathVector22['default'](this._image.width, this._image.height);
	      stack.forEach(function (operation) {
	        size = operation.getNewDimensions(_this, size);
	      });
	      if (dimensions) {
	        size = dimensions.calculateFinalDimensions(size);
	      }
	      return size;
	    }
	
	    /**
	     * Returns the initial dimensions before any operations have been applied
	     * @param {Array.<Operation>} stack
	     * @param {ImageDimensions} dimensions
	     */
	  }, {
	    key: 'getInitialDimensionsForStack',
	    value: function getInitialDimensionsForStack(stack, dimensions) {
	      return this.getOutputDimensionsForStack(stack, dimensions);
	    }
	
	    /**
	     * Sets the current context to the given one
	     * @param {RenderingContext2D} context
	     */
	  }, {
	    key: 'setContext',
	    value: function setContext(context) {
	      this._context = context;
	    }
	
	    /**
	     * Resets the renderer
	     * @param {Boolean} resetCache = false
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      var resetCache = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	    }
	
	    /**
	     * Gets called after the rendering has been done.
	     */
	  }, {
	    key: 'postRender',
	    value: function postRender(dimensions) {}
	  }, {
	    key: 'setSize',
	    value: function setSize(size) {
	      this._size.copy(size);
	    }
	  }, {
	    key: 'identifier',
	    get: function get() {
	      return null;
	    }
	
	    /**
	     * Checks whether this type of renderer is supported in the current environment
	     * @abstract
	     * @returns {boolean}
	     */
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      /* istanbul ignore next */
	      throw new Error('Renderer#isSupported is abstract and not implemented in inherited class.');
	    }
	  }]);
	
	  return Renderer;
	})(_libEventEmitter2['default']);
	
	exports['default'] = Renderer;
	module.exports = exports['default'];

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_7__;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var root = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : null;
	var p = root.Promise;
	
	if (!p) {
	  p = __webpack_require__(9);
	}
	
	exports['default'] = p;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
	 * Native Promise Only
	 * v0.8.0-a (c) Kyle Simpson
	 * MIT License: http://getify.mit-license.org
	 * @license
	 */
	
	"use strict";
	
	(function UMD(name, context, definition) {
	  // special form of UMD for polyfilling across evironments
	  context[name] = context[name] || definition();
	  if (typeof module != "undefined" && module.exports) {
	    module.exports = context[name];
	  } else if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function $AMD$() {
	      return context[name];
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	})("Promise", typeof global != "undefined" ? global : undefined, function DEF() {
	  /*jshint validthis:true */
	  "use strict";
	
	  var builtInProp,
	      cycle,
	      scheduling_queue,
	      ToString = Object.prototype.toString,
	      timer = typeof setImmediate != "undefined" ? function timer(fn) {
	    return setImmediate(fn);
	  } : setTimeout;
	
	  // dammit, IE8.
	  try {
	    Object.defineProperty({}, "x", {});
	    builtInProp = function builtInProp(obj, name, val, config) {
	      return Object.defineProperty(obj, name, {
	        value: val,
	        writable: true,
	        configurable: config !== false
	      });
	    };
	  } catch (err) {
	    builtInProp = function builtInProp(obj, name, val) {
	      obj[name] = val;
	      return obj;
	    };
	  }
	
	  // Note: using a queue instead of array for efficiency
	  scheduling_queue = (function Queue() {
	    var first, last, item;
	
	    function Item(fn, self) {
	      this.fn = fn;
	      this.self = self;
	      this.next = void 0;
	    }
	
	    return {
	      add: function add(fn, self) {
	        item = new Item(fn, self);
	        if (last) {
	          last.next = item;
	        } else {
	          first = item;
	        }
	        last = item;
	        item = void 0;
	      },
	      drain: function drain() {
	        var f = first;
	        first = last = cycle = void 0;
	
	        while (f) {
	          f.fn.call(f.self);
	          f = f.next;
	        }
	      }
	    };
	  })();
	
	  function schedule(fn, self) {
	    scheduling_queue.add(fn, self);
	    if (!cycle) {
	      cycle = timer(scheduling_queue.drain);
	    }
	  }
	
	  // promise duck typing
	  function isThenable(o) {
	    var _then,
	        o_type = typeof o;
	
	    if (o != null && (o_type == "object" || o_type == "function")) {
	      _then = o.then;
	    }
	    return typeof _then == "function" ? _then : false;
	  }
	
	  function notify() {
	    for (var i = 0; i < this.chain.length; i++) {
	      notifyIsolated(this, this.state === 1 ? this.chain[i].success : this.chain[i].failure, this.chain[i]);
	    }
	    this.chain.length = 0;
	  }
	
	  // NOTE: This is a separate function to isolate
	  // the `try..catch` so that other code can be
	  // optimized better
	  function notifyIsolated(self, cb, chain) {
	    var ret, _then;
	    try {
	      if (cb === false) {
	        chain.reject(self.msg);
	      } else {
	        if (cb === true) {
	          ret = self.msg;
	        } else {
	          ret = cb.call(void 0, self.msg);
	        }
	
	        if (ret === chain.promise) {
	          chain.reject(TypeError("Promise-chain cycle"));
	        } else if (_then = isThenable(ret)) {
	          _then.call(ret, chain.resolve, chain.reject);
	        } else {
	          chain.resolve(ret);
	        }
	      }
	    } catch (err) {
	      chain.reject(err);
	    }
	  }
	
	  function resolve(msg) {
	    var _then,
	        self = this;
	
	    // already triggered?
	    if (self.triggered) {
	      return;
	    }
	
	    self.triggered = true;
	
	    // unwrap
	    if (self.def) {
	      self = self.def;
	    }
	
	    try {
	      if (_then = isThenable(msg)) {
	        schedule(function () {
	          var def_wrapper = new MakeDefWrapper(self);
	          try {
	            _then.call(msg, function $resolve$() {
	              resolve.apply(def_wrapper, arguments);
	            }, function $reject$() {
	              reject.apply(def_wrapper, arguments);
	            });
	          } catch (err) {
	            reject.call(def_wrapper, err);
	          }
	        });
	      } else {
	        self.msg = msg;
	        self.state = 1;
	        if (self.chain.length > 0) {
	          schedule(notify, self);
	        }
	      }
	    } catch (err) {
	      reject.call(new MakeDefWrapper(self), err);
	    }
	  }
	
	  function reject(msg) {
	    var self = this;
	
	    // already triggered?
	    if (self.triggered) {
	      return;
	    }
	
	    self.triggered = true;
	
	    // unwrap
	    if (self.def) {
	      self = self.def;
	    }
	
	    self.msg = msg;
	    self.state = 2;
	    if (self.chain.length > 0) {
	      schedule(notify, self);
	    }
	  }
	
	  function iteratePromises(Constructor, arr, resolver, rejecter) {
	    for (var idx = 0; idx < arr.length; idx++) {
	      (function IIFE(idx) {
	        Constructor.resolve(arr[idx]).then(function $resolver$(msg) {
	          resolver(idx, msg);
	        }, rejecter);
	      })(idx);
	    }
	  }
	
	  function MakeDefWrapper(self) {
	    this.def = self;
	    this.triggered = false;
	  }
	
	  function MakeDef(self) {
	    this.promise = self;
	    this.state = 0;
	    this.triggered = false;
	    this.chain = [];
	    this.msg = void 0;
	  }
	
	  function Promise(executor) {
	    if (typeof executor != "function") {
	      throw TypeError("Not a function");
	    }
	
	    if (this.__NPO__ !== 0) {
	      throw TypeError("Not a promise");
	    }
	
	    // instance shadowing the inherited "brand"
	    // to signal an already "initialized" promise
	    this.__NPO__ = 1;
	
	    var def = new MakeDef(this);
	
	    this["then"] = function then(success, failure) {
	      var o = {
	        success: typeof success == "function" ? success : true,
	        failure: typeof failure == "function" ? failure : false
	      };
	      // Note: `then(..)` itself can be borrowed to be used against
	      // a different promise constructor for making the chained promise,
	      // by substituting a different `this` binding.
	      o.promise = new this.constructor(function extractChain(resolve, reject) {
	        if (typeof resolve != "function" || typeof reject != "function") {
	          throw TypeError("Not a function");
	        }
	
	        o.resolve = resolve;
	        o.reject = reject;
	      });
	      def.chain.push(o);
	
	      if (def.state !== 0) {
	        schedule(notify, def);
	      }
	
	      return o.promise;
	    };
	    this["catch"] = function $catch$(failure) {
	      return this.then(void 0, failure);
	    };
	
	    try {
	      executor.call(void 0, function publicResolve(msg) {
	        resolve.call(def, msg);
	      }, function publicReject(msg) {
	        reject.call(def, msg);
	      });
	    } catch (err) {
	      reject.call(def, err);
	    }
	  }
	
	  var PromisePrototype = builtInProp({}, "constructor", Promise,
	  /*configurable=*/false);
	
	  // Note: Android 4 cannot use `Object.defineProperty(..)` here
	  Promise.prototype = PromisePrototype;
	
	  // built-in "brand" to signal an "uninitialized" promise
	  builtInProp(PromisePrototype, "__NPO__", 0,
	  /*configurable=*/false);
	
	  builtInProp(Promise, "resolve", function Promise$resolve(msg) {
	    var Constructor = this;
	
	    // spec mandated checks
	    // note: best "isPromise" check that's practical for now
	    if (msg && typeof msg == "object" && msg.__NPO__ === 1) {
	      return msg;
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      resolve(msg);
	    });
	  });
	
	  builtInProp(Promise, "reject", function Promise$reject(msg) {
	    return new this(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      reject(msg);
	    });
	  });
	
	  builtInProp(Promise, "all", function Promise$all(arr) {
	    var Constructor = this;
	
	    // spec mandated checks
	    if (ToString.call(arr) != "[object Array]") {
	      return Constructor.reject(TypeError("Not an array"));
	    }
	    if (arr.length === 0) {
	      return Constructor.resolve([]);
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      var len = arr.length,
	          msgs = Array(len),
	          count = 0;
	
	      iteratePromises(Constructor, arr, function resolver(idx, msg) {
	        msgs[idx] = msg;
	        if (++count === len) {
	          resolve(msgs);
	        }
	      }, reject);
	    });
	  });
	
	  builtInProp(Promise, "race", function Promise$race(arr) {
	    var Constructor = this;
	
	    // spec mandated checks
	    if (ToString.call(arr) != "[object Array]") {
	      return Constructor.reject(TypeError("Not an array"));
	    }
	
	    return new Constructor(function executor(resolve, reject) {
	      if (typeof resolve != "function" || typeof reject != "function") {
	        throw TypeError("Not a function");
	      }
	
	      iteratePromises(Constructor, arr, function resolver(idx, msg) {
	        resolve(msg);
	      }, reject);
	    });
	  });
	
	  return Promise;
	});
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(10).setImmediate))

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(11).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };
	
	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);
	
	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};
	
	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);
	
	  immediateIds[id] = true;
	
	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });
	
	  return id;
	};
	
	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).setImmediate, __webpack_require__(10).clearImmediate))

/***/ },
/* 11 */
/***/ function(module, exports) {

	// shim for using process in browser
	
	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	/* global Image */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _renderer = __webpack_require__(6);
	
	var _renderer2 = _interopRequireDefault(_renderer);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	/**
	 * @class
	 * @alias ImglyKit.WebGLRenderer
	 * @extends {ImglyKit.Renderer}
	 * @private
	 */
	var MAX_CONTEXT_LOST_COUNT = 3;
	
	var WebGLRenderer = (function (_Renderer) {
	  _inherits(WebGLRenderer, _Renderer);
	
	  function WebGLRenderer() {
	    _classCallCheck(this, WebGLRenderer);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(WebGLRenderer.prototype), 'constructor', this).apply(this, args);
	    this._contextLostCount = 0;
	    this._handleContextLoss();
	
	    this._defaultProgram = this.setupGLSLProgram();
	    this.reset();
	
	    this.id = WebGLRenderer.contextId;
	    WebGLRenderer.contextId++;
	  }
	
	  /**
	   * Gets called when the webgl context has been lost
	   * @private
	   */
	
	  _createClass(WebGLRenderer, [{
	    key: '_handleContextLoss',
	    value: function _handleContextLoss() {
	      var _this = this;
	
	      this._canvas.addEventListener('webglcontextlost', function (e) {
	        e.preventDefault();
	        _this._contextLostCount++;
	
	        var err = new Error('WebGL context has been lost');
	        err.code = 'WEBGL_CONTEXT_LOST';
	        _this.emit('error', err);
	      });
	      this._canvas.addEventListener('webglcontextrestored', function () {
	        if (_this._contextLostCount >= MAX_CONTEXT_LOST_COUNT) {
	          var err = new Error('WebGL context has been lost and could not be restored');
	          err.code = 'WEBGL_CONTEXT_LOST_LIMIT';
	          return _this.emit('error', err);
	        }
	        _this.emit('reset');
	        _this.reset(true, true);
	      });
	    }
	
	    /**
	     * Returns the context options passed to getContext()
	     * @type {Object}
	     * @private
	     */
	  }, {
	    key: 'cache',
	
	    /**
	     * Caches the current canvas content for the given identifier
	     * @param {String} identifier
	     */
	    value: function cache(identifier) {
	      // Re-use FBO and textures
	      var fbo = undefined,
	          texture = undefined,
	          cacheObject = undefined;
	      if (!this._cache[identifier]) {
	        cacheObject = this._createFramebuffer();
	      } else {
	        cacheObject = this._cache[identifier];
	      }
	
	      // Extract FBO and texture
	      fbo = cacheObject.fbo;
	      texture = cacheObject.texture;
	
	      // Resize output texture
	      var gl = this._context;
	      gl.useProgram(this._defaultProgram);
	      this._setCoordinates(this._defaultProgram);
	
	      // Resize cached texture
	      gl.bindTexture(gl.TEXTURE_2D, texture);
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._size.x, this._size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	      // Render to FBO
	      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	      gl.viewport(0, 0, this._size.x, this._size.y);
	
	      // Use last fbo texture as input
	      gl.bindTexture(gl.TEXTURE_2D, this._lastTexture);
	
	      gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	      this._cache[identifier] = { fbo: fbo, texture: texture, size: this._size.clone() };
	    }
	
	    /**
	     * Draws the stored texture / image data for the given identifier
	     * @param {String} identifier
	     */
	  }, {
	    key: 'drawCached',
	    value: function drawCached(identifier) {
	      var _cache$identifier = this._cache[identifier];
	      var texture = _cache$identifier.texture;
	      var size = _cache$identifier.size;
	
	      var fbo = this.getCurrentFramebuffer();
	      var currentTexture = this.getCurrentTexture();
	
	      var gl = this._context;
	      gl.useProgram(this._defaultProgram);
	      this._setCoordinates(this._defaultProgram);
	
	      // Resize all textures
	      for (var i = 0; i < this._textures.length; i++) {
	        var otherTexture = this._textures[i];
	        gl.bindTexture(gl.TEXTURE_2D, otherTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size.x, size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	      }
	
	      // Select the current framebuffer to draw to
	      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	
	      // Resize the texture we're drawing to
	      gl.bindTexture(gl.TEXTURE_2D, currentTexture);
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size.x, size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	      // Use the cached texture as input
	      gl.bindTexture(gl.TEXTURE_2D, texture);
	
	      gl.viewport(0, 0, size.x, size.y);
	
	      // Clear
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	      // Draw the rectangle
	      gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	      this.setLastTexture(currentTexture);
	      this.selectNextBuffer();
	
	      this._size = size.clone();
	    }
	
	    /**
	     * The default vertex shader which just passes the texCoord to the
	     * fragment shader.
	     * @type {String}
	     * @private
	     */
	  }, {
	    key: '_getContext',
	
	    /**
	     * Gets the rendering context from the Canvas
	     * @return {RenderingContext}
	     * @abstract
	     */
	    value: function _getContext() {
	      /* istanbul ignore next */
	      var gl = this._canvas.getContext('webgl', this._contextOptions) || this._canvas.getContext('experimental-webgl', this._contextOptions);
	
	      if (window.WebGLDebugUtils) {
	        gl = window.WebGLDebugUtils.makeDebugContext(gl);
	      }
	
	      gl.disable(gl.DEPTH_TEST);
	      gl.disable(gl.CULL_FACE);
	
	      this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
	
	      return gl;
	    }
	
	    /**
	     * Draws the given image on the canvas
	     * @param  {Image} image
	     * @returns {Promise}
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'drawImage',
	    value: function drawImage(image) {
	      var _this2 = this;
	
	      var gl = this._context;
	      this._size = new _libMathVector22['default'](gl.drawingBufferWidth, gl.drawingBufferHeight);
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        gl.useProgram(_this2._defaultProgram);
	        _this2._setCoordinates(_this2._defaultProgram);
	
	        var fbo = _this2.getCurrentFramebuffer();
	        var currentTexture = _this2.getCurrentTexture();
	
	        // Select the current framebuffer
	        gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	        gl.viewport(0, 0, _this2._size.x, _this2._size.y);
	        gl.bindTexture(gl.TEXTURE_2D, currentTexture);
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, _this2._size.x, _this2._size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	        // Create the texture
	        var texture = _this2.createTexture();
	        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	        _this2._inputTexture = texture;
	        _this2.setLastTexture(texture);
	
	        // Set premultiplied alpha
	        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	        // Upload the image into the texture
	        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	
	        // Draw the rectangle
	        gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	        resolve();
	      });
	    }
	
	    /**
	     * Resizes the given image to fit the maximum texture size
	     * @param {Image}
	     * @returns {Promise}
	     * @private
	     */
	  }, {
	    key: 'prepareImage',
	    value: function prepareImage(image) {
	      if (image.width <= this._maxTextureSize && image.height <= this._maxTextureSize) {
	        return _vendorPromise2['default'].resolve(image);
	      }
	
	      // Calculate new size that fits the graphics card's max texture size
	      var maxSize = new _libMathVector22['default'](this._maxTextureSize, this._maxTextureSize);
	      var size = new _libMathVector22['default'](image.width, image.height);
	      var scale = Math.min(maxSize.x / size.x, maxSize.y / size.y);
	      var newSize = size.clone().multiply(scale);
	
	      // Create a new canvas to draw the image to
	      var canvas = this.createCanvas(newSize.x, newSize.y);
	      var context = canvas.getContext('2d');
	
	      // Draw the resized image
	      context.drawImage(image, 0, 0, size.x, size.y, 0, 0, newSize.x, newSize.y);
	
	      // Turn into a data url and make an image out of it
	      var data = canvas.toDataURL('image/jpeg');
	
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        var image = new Image();
	        image.addEventListener('load', function () {
	          resolve(image);
	        });
	        image.src = data;
	      });
	    }
	
	    /**
	     * Clears the WebGL context
	     * @param {WebGLRenderingContext} gl
	     * @private
	     */
	  }, {
	    key: '_clear',
	    value: function _clear(gl) {
	      gl.clearColor(0, 0, 0, 0);
	      gl.clear(gl.COLOR_BUFFER_BIT);
	    }
	  }, {
	    key: '_setCoordinates',
	    value: function _setCoordinates(program, textureCoordinates, triangleCoordinates) {
	      var gl = this._context;
	
	      // Lookup texture coordinates location
	      var positionLocation = gl.getAttribLocation(program, 'a_position');
	      var texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
	
	      textureCoordinates = textureCoordinates || new Float32Array([
	      // First triangle
	      0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
	
	      // Second triangle
	      0.0, 1.0, 1.0, 0.0, 1.0, 1.0]);
	
	      // Provide texture coordinates
	      var texCoordBuffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
	      gl.bufferData(gl.ARRAY_BUFFER, textureCoordinates, gl.STATIC_DRAW);
	      gl.enableVertexAttribArray(texCoordLocation);
	      gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);
	
	      triangleCoordinates = triangleCoordinates || new Float32Array([
	      // First triangle
	      -1.0, -1.0, 1.0, -1.0, -1.0, 1.0,
	
	      // Second triangle
	      -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]);
	
	      // Create a buffer for the rectangle positions
	      var buffer = gl.createBuffer();
	      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	      gl.enableVertexAttribArray(positionLocation);
	      gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
	      gl.bufferData(gl.ARRAY_BUFFER, triangleCoordinates, gl.STATIC_DRAW);
	    }
	  }, {
	    key: 'runProgram',
	    value: function runProgram(program, options) {
	      var gl = this._context;
	      gl.useProgram(program);
	      this._setCoordinates(program, options.textureCoordinates, options.triangleCoordinates);
	
	      var fbo = this.getCurrentFramebuffer();
	      var currentTexture = this.getCurrentTexture();
	
	      // Select the current framebuffer
	      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	      gl.viewport(0, 0, this._size.x, this._size.y);
	
	      // Resize the texture to canvas size
	      gl.bindTexture(gl.TEXTURE_2D, currentTexture);
	
	      // Set premultiplied alpha
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._size.x, this._size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	      // Make sure we select the current texture
	      gl.bindTexture(gl.TEXTURE_2D, this._lastTexture);
	
	      // Set the uniforms
	      for (var name in options.uniforms) {
	        var location = gl.getUniformLocation(program, name);
	        var uniform = options.uniforms[name];
	
	        switch (uniform.type) {
	          case 'i':
	          case '1i':
	            gl.uniform1i(location, uniform.value);
	            break;
	          case 'f':
	          case '1f':
	            gl.uniform1f(location, uniform.value);
	            break;
	          case '2f':
	            gl.uniform2f(location, uniform.value[0], uniform.value[1]);
	            break;
	          case '3f':
	            gl.uniform3f(location, uniform.value[0], uniform.value[1], uniform.value[2]);
	            break;
	          case '4f':
	            gl.uniform4f(location, uniform.value[0], uniform.value[1], uniform.value[2], uniform.value[3]);
	            break;
	          case '2fv':
	            gl.uniform2fv(location, uniform.value);
	            break;
	          case 'mat3fv':
	            gl.uniformMatrix3fv(location, false, uniform.value);
	            break;
	          default:
	            throw new Error('Unknown uniform type: ' + uniform.type);
	        }
	      }
	
	      // Clear
	      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	      // Draw the rectangle
	      gl.drawArrays(gl.TRIANGLES, 0, 6);
	
	      this.setLastTexture(currentTexture);
	      this.selectNextBuffer();
	    }
	
	    /**
	     * Runs the given shader
	     * @param  {String} [vertexShader]
	     * @param  {String} [fragmentShader]
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'runShader',
	    value: function runShader(vertexShader, fragmentShader, options) {
	      if (typeof options === 'undefined') options = {};
	      if (typeof options.uniforms === 'undefined') options.uniforms = {};
	
	      var program = this.setupGLSLProgram(vertexShader, fragmentShader);
	      this.runProgram(program, options);
	    }
	
	    /**
	     * Draws the last used buffer onto the canvas
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'renderFinal',
	    value: function renderFinal() {
	      var gl = this._context;
	      var program = this._defaultProgram;
	      gl.useProgram(program);
	
	      // Don't draw to framebuffer
	      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
	
	      // Make sure the viewport size is correct
	      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
	
	      // Select the last texture that has been rendered to
	      gl.bindTexture(gl.TEXTURE_2D, this._lastTexture);
	
	      // Clear
	      this._clear(gl);
	
	      // Draw the rectangle
	      gl.drawArrays(gl.TRIANGLES, 0, 6);
	    }
	
	    /**
	     * Sets up a GLSL program. Uses the default vertex and fragment shader
	     * if none are given.
	     * @param {String} [vertexShader]
	     * @param {String} [fragmentShader]
	     * @return {WebGLProgram}
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'setupGLSLProgram',
	    value: function setupGLSLProgram(vertexShader, fragmentShader, textureCoordinates) {
	      var gl = this._context;
	      var shaders = [];
	
	      // Use default vertex shader
	      vertexShader = this._createShader(gl.VERTEX_SHADER, vertexShader || WebGLRenderer.prototype.defaultVertexShader);
	      shaders.push(vertexShader);
	
	      // Use default fragment shader
	      fragmentShader = this._createShader(gl.FRAGMENT_SHADER, fragmentShader || WebGLRenderer.prototype.defaultFragmentShader);
	      shaders.push(fragmentShader);
	
	      // Create the program
	      var program = gl.createProgram();
	
	      // Attach the shaders
	      for (var i = 0; i < shaders.length; i++) {
	        gl.attachShader(program, shaders[i]);
	      }
	
	      // Link the program
	      gl.linkProgram(program);
	
	      // Check linking status
	      var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
	      if (!linked) {
	        var lastError = gl.getProgramInfoLog(program);
	        gl.deleteProgram(program);
	        throw new Error('WebGL program linking error: ' + lastError);
	      }
	
	      return program;
	    }
	
	    /**
	     * Creates a WebGL shader with the given type and source code
	     * @param  {WebGLShaderType} shaderType
	     * @param  {String} shaderSource
	     * @return {WebGLShader}
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_createShader',
	    value: function _createShader(shaderType, shaderSource) {
	      var gl = this._context;
	
	      // Create the shader and compile it
	      var shader = gl.createShader(shaderType);
	      gl.shaderSource(shader, shaderSource);
	      gl.compileShader(shader);
	
	      // Check compilation status
	      var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	      if (!compiled) {
	        var lastError = gl.getShaderInfoLog(shader);
	        gl.deleteShader(shader);
	        throw new Error('WebGL shader compilation error: ' + lastError);
	      }
	
	      return shader;
	    }
	
	    /**
	     * Creates an empty texture
	     * @return {WebGLTexture}
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'createTexture',
	    value: function createTexture() {
	      var gl = this._context;
	      var texture = gl.createTexture();
	
	      gl.bindTexture(gl.TEXTURE_2D, texture);
	
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
	
	      return texture;
	    }
	
	    /**
	     * Creates two textures and framebuffers that are used for the stack
	     * rendering
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_createFramebuffers',
	    value: function _createFramebuffers() {
	      for (var i = 0; i < 2; i++) {
	        var _createFramebuffer2 = this._createFramebuffer();
	
	        var fbo = _createFramebuffer2.fbo;
	        var texture = _createFramebuffer2.texture;
	
	        this._textures.push(texture);
	        this._framebuffers.push(fbo);
	      }
	    }
	
	    /**
	     * Creates and returns a frame buffer and texture
	     * @return {Object}
	     * @private
	     */
	  }, {
	    key: '_createFramebuffer',
	    value: function _createFramebuffer() {
	      var gl = this._context;
	
	      // Create texture
	      var texture = this.createTexture();
	
	      // Set premultiplied alpha
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this._size.x, this._size.y, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
	
	      // Create framebuffer
	      var fbo = gl.createFramebuffer();
	      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
	
	      // Attach the texture
	      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
	
	      return { fbo: fbo, texture: texture };
	    }
	
	    /**
	     * Resizes the current canvas picture to the given dimensions
	     * @param  {Vector2} dimensions
	     * @todo Use a downsampling shader for smoother image resizing
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'resizeTo',
	    value: function resizeTo(dimensions) {
	      var gl = this._context;
	
	      // Resize the canvas
	      this._canvas.width = dimensions.x;
	      this._canvas.height = dimensions.y;
	    }
	
	    /**
	     * Returns the current framebuffer
	     * @return {WebGLFramebuffer}
	     */
	  }, {
	    key: 'getCurrentFramebuffer',
	    value: function getCurrentFramebuffer() {
	      return this._framebuffers[this._bufferIndex % 2];
	    }
	
	    /**
	     * Returns the current texture
	     * @return {WebGLTexture}
	     */
	  }, {
	    key: 'getCurrentTexture',
	    value: function getCurrentTexture() {
	      return this._textures[this._bufferIndex % 2];
	    }
	
	    /**
	     * Increases the buffer index
	     */
	  }, {
	    key: 'selectNextBuffer',
	    value: function selectNextBuffer() {
	      this._bufferIndex++;
	    }
	
	    /**
	     * Returns the default program
	     * @return {WebGLProgram}
	     */
	  }, {
	    key: 'getDefaultProgram',
	    value: function getDefaultProgram() {
	      return this._defaultProgram;
	    }
	
	    /**
	     * Returns the last texture that has been drawn to
	     * @return {WebGLTexture}
	     */
	  }, {
	    key: 'getLastTexture',
	    value: function getLastTexture() {
	      return this._lastTexture;
	    }
	
	    /**
	     * Returns all textures
	     * @return {Array.<WebGLTexture>}
	     */
	  }, {
	    key: 'getTextures',
	    value: function getTextures() {
	      return this._textures;
	    }
	
	    /**
	     * Sets the last texture
	     * @param {WebGLTexture} texture
	     */
	  }, {
	    key: 'setLastTexture',
	    value: function setLastTexture(texture) {
	      this._lastTexture = texture;
	    }
	
	    /**
	     * Resets the renderer
	     * @param {Boolean} resetCache = false
	     * @param {Boolean} newContext = false
	     * @override
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      var resetCache = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	      var newContext = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	
	      this._lastTexture = null;
	      this._textures = [];
	      this._framebuffers = [];
	      this._bufferIndex = 0;
	
	      if (resetCache) {
	        this._cache = [];
	      }
	
	      if (newContext) {
	        this._inputTexture = null;
	        this._context = this._getContext();
	        this._defaultProgram = this.setupGLSLProgram();
	      }
	
	      this._createFramebuffers();
	      this.setLastTexture(this._inputTexture);
	    }
	  }, {
	    key: '_contextOptions',
	    get: function get() {
	      return {
	        alpha: true,
	        premultipliedAlpha: true
	      };
	    }
	
	    /**
	     * A unique string that identifies this renderer
	     * @type {String}
	     */
	  }, {
	    key: 'identifier',
	    get: function get() {
	      return 'webgl';
	    }
	  }, {
	    key: 'defaultVertexShader',
	    get: function get() {
	      var shader = '\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      varying vec2 v_texCoord;\n\n      void main() {\n        gl_Position = vec4(a_position, 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    ';
	      return shader;
	    }
	
	    /**
	     * The default fragment shader which will just look up the colors from the
	     * texture.
	     * @type {String}
	     * @private
	     */
	  }, {
	    key: 'defaultFragmentShader',
	    get: function get() {
	      var shader = '\n      precision mediump float;\n      uniform sampler2D u_image;\n      varying vec2 v_texCoord;\n\n      void main() {\n        gl_FragColor = texture2D(u_image, v_texCoord);\n      }\n    ';
	      return shader;
	    }
	
	    /**
	     * Checks whether this type of renderer is supported in the current environment
	     * @abstract
	     * @returns {boolean}
	     */
	  }, {
	    key: 'maxTextureSize',
	    get: function get() {
	      return this._maxTextureSize;
	    }
	  }], [{
	    key: 'isSupported',
	    value: function isSupported() {
	      if (typeof window === 'undefined') {
	        return false;
	      }
	
	      var canvas = document.createElement('canvas');
	      var gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
	      return !!gl;
	    }
	  }]);
	
	  return WebGLRenderer;
	})(_renderer2['default']);
	
	WebGLRenderer.contextId = 0;
	
	exports['default'] = WebGLRenderer;
	module.exports = exports['default'];

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* global HTMLElement */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _base64 = __webpack_require__(14);
	
	var _base642 = _interopRequireDefault(_base64);
	
	var _mathVector2 = __webpack_require__(4);
	
	var _mathVector22 = _interopRequireDefault(_mathVector2);
	
	var _classList = __webpack_require__(15);
	
	var _classList2 = _interopRequireDefault(_classList);
	
	/**
	 * Provides utility functions for internal use
	 * @class
	 * @alias ImglyKit.Utils
	 * @private
	 */
	
	var Utils = (function () {
	  function Utils() {
	    _classCallCheck(this, Utils);
	  }
	
	  _createClass(Utils, null, [{
	    key: 'isArray',
	
	    /**
	     * Checks if the given object is an Array
	     * @param  {Object}  object
	     * @return {Boolean}
	     */
	    value: function isArray(object) {
	      return Object.prototype.toString.call(object) === '[object Array]';
	    }
	
	    /**
	     * Returns the items selected by the given selector
	     * @param  {Array} items
	     * @param  {ImglyKit~Selector} selector - The selector
	     * @return {Array} The selected items
	     */
	  }, {
	    key: 'select',
	    value: function select(items) {
	      var selector = arguments.length <= 1 || arguments[1] === undefined ? null : arguments[1];
	
	      if (selector === null) {
	        return items;
	      }
	
	      // Turn string parameter into an array
	      if (typeof selector === 'string') {
	        selector = selector.split(',').map(function (identifier) {
	          return identifier.trim();
	        });
	      }
	
	      // Turn array parameter into an object with `only`
	      if (Utils.isArray(selector)) {
	        selector = { only: selector };
	      }
	
	      if (typeof selector.only !== 'undefined') {
	        if (typeof selector.only === 'string') {
	          selector.only = selector.only.split(',').map(function (identifier) {
	            return identifier.trim();
	          });
	        }
	
	        // Select only the given identifiers
	        return items.filter(function (item) {
	          return selector.only.indexOf(item) !== -1;
	        });
	      } else if (typeof selector.except !== 'undefined') {
	        if (typeof selector.except === 'string') {
	          selector.except = selector.except.split(',').map(function (identifier) {
	            return identifier.trim();
	          });
	        }
	
	        // Select all but the given identifiers
	        return items.filter(function (item) {
	          return selector.except.indexOf(item) === -1;
	        });
	      }
	
	      throw new Error('Utils#select failed to filter items.');
	    }
	
	    /**
	     * Returns the given object's values as an array
	     * @param {Object} object
	     * @returns {Array<*>}
	     */
	  }, {
	    key: 'values',
	    value: function values(object) {
	      var values = [];
	      for (var key in object) {
	        values.push(object[key]);
	      }
	      return values;
	    }
	
	    /**
	     * Checks if the given object is a DOM element
	     * @param  {Object}  o
	     * @return {Boolean}
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'isDOMElement',
	    value: function isDOMElement(o) {
	      return typeof HTMLElement === 'object' ? o instanceof HTMLElement : o && typeof o === 'object' && o !== null && o.nodeType === 1 && typeof o.nodeName === 'string';
	    }
	
	    /**
	     * Gets the x and y position for the given event.
	     * @param {Event} e
	     * @return {Vector2}
	     */
	  }, {
	    key: 'getEventPosition',
	    value: function getEventPosition(e) {
	      var x = e.clientX;
	      var y = e.clientY;
	      if (e.type.indexOf('touch') !== -1) {
	        x = e.touches[0].clientX;
	        y = e.touches[0].clientY;
	      }
	      return new _mathVector22['default'](x, y);
	    }
	
	    /**
	     * Checks if th given event is a touch event
	     * @param  {Event}  e
	     * @return {Boolean}
	     */
	  }, {
	    key: 'isTouchEvent',
	    value: function isTouchEvent(e) {
	      return e.type.indexOf('touch') !== -1;
	    }
	
	    /**
	     * Resizes the given vector to fit inside the given max size while maintaining
	     * the aspect ratio
	     * @param  {Vector2} vector
	     * @param  {Vector2} max
	     * @return {Vector2}
	     */
	  }, {
	    key: 'resizeVectorToFit',
	    value: function resizeVectorToFit(vector, max) {
	      var scale = Math.min(max.x / vector.x, max.y / vector.y);
	      var newSize = vector.clone().multiply(scale);
	      return newSize;
	    }
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object for all destination properties that resolve to undefined. Once a
	     * property is set, additional values of the same property are ignored.
	     * @param  {Object} object
	     * @param  {Object} ...sources
	     * @return {Object}
	     */
	  }, {
	    key: 'defaults',
	    value: function defaults(object) {
	      // Shallow clone
	      var newObject = {};
	      for (var key in object) {
	        newObject[key] = object[key];
	      }
	
	      // Clone sources
	
	      for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        sources[_key - 1] = arguments[_key];
	      }
	
	      for (var i = 0; i < sources.length; i++) {
	        var source = sources[i];
	        for (var key in source) {
	          if (typeof newObject[key] === 'undefined') {
	            newObject[key] = source[key];
	          }
	        }
	      }
	
	      return newObject;
	    }
	
	    /**
	     * Assigns own enumerable properties of source object(s) to the destination
	     * object. Subsequent sources overwrite property assignments of previous
	     * sources.
	     * @param {Object} object
	     * @param {Object} ...sources
	     * @return {Object}
	     */
	  }, {
	    key: 'extend',
	    value: function extend(object) {
	      // Shallow clone
	      var newObject = {};
	      for (var key in object) {
	        newObject[key] = object[key];
	      }
	
	      // Extend sources
	
	      for (var _len2 = arguments.length, sources = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
	        sources[_key2 - 1] = arguments[_key2];
	      }
	
	      for (var i = 0; i < sources.length; i++) {
	        var source = sources[i];
	        for (var key in source) {
	          newObject[key] = source[key];
	        }
	      }
	
	      return newObject;
	    }
	
	    /**
	     * Gets the property value at `path` of `object`
	     * @param  {Object} object
	     * @param  {String} key
	     * @param  {?} [defaultValue]
	     * @return {?}
	     */
	  }, {
	    key: 'fetch',
	    value: function fetch(object, path, defaultValue) {
	      // Replace indexes with property accessors
	      path = path.replace(/\[(\w+)\]/g, '.$1');
	      // Strip leading dot (when path begins with [0] for example)
	      path = path.replace(/^\./, '');
	
	      var pathSegments = path.split('.');
	      for (var i = 0; i < pathSegments.length; i++) {
	        var segment = pathSegments[i];
	        object = object[segment];
	        if (!object) {
	          break;
	        }
	      }
	
	      if (typeof object === 'undefined') {
	        object = defaultValue;
	      }
	
	      return object;
	    }
	
	    /**
	     * Creates a Blob URI from the given Data URI
	     * @param {String} data
	     */
	  }, {
	    key: 'createBlobURIFromDataURI',
	    value: function createBlobURIFromDataURI(data) {
	      if (!window.Blob || !window.URL || !ArrayBuffer || !Uint8Array) {
	        return data;
	      }
	
	      var rawData = _base642['default'].decode(data.split(',')[1]);
	      var mimeString = data.split(',')[0].split(':')[1].split(';')[0];
	
	      // write the bytes of the string to an ArrayBuffer
	      var arrayBuffer = new ArrayBuffer(rawData.length);
	      var intArray = new Uint8Array(arrayBuffer);
	      for (var i = 0; i < rawData.length; i++) {
	        intArray[i] = rawData[i];
	      }
	
	      // write the ArrayBuffer to a blob, and you're done
	      var blob = new window.Blob([arrayBuffer], {
	        type: mimeString
	      });
	      return window.URL.createObjectURL(blob);
	    }
	
	    /**
	     * Returns a `ClassList` instance for the given element
	     * @param  {DOMElement} el
	     * @return {ClassList}
	     */
	  }, {
	    key: 'classList',
	    value: function classList(el) {
	      return new _classList2['default'](el);
	    }
	  }, {
	    key: 'requestAnimationFrame',
	    value: function requestAnimationFrame(cb) {
	      var fallback = function fallback(callback) {
	        setTimeout(callback, 1000 / 60);
	      };
	
	      if (typeof window === 'undefined') {
	        return fallback(cb);
	      }
	
	      return (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || fallback)(cb);
	    }
	  }]);
	
	  return Utils;
	})();
	
	exports['default'] = Utils;
	module.exports = exports['default'];

/***/ },
/* 14 */
/***/ function(module, exports) {

	/*!
	 * Extracted from MinifyJpeg (Copyright (c) 2014 Hiroaki Matoba, MIT License):
	 * https://github.com/hMatoba/MinifyJpeg
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var KEY_STR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	
	exports['default'] = {
	  encode: function encode(input) {
	    var output = '',
	        chr1 = undefined,
	        chr2 = undefined,
	        chr3 = '',
	        enc1 = undefined,
	        enc2 = undefined,
	        enc3 = undefined,
	        enc4 = '',
	        i = 0;
	
	    do {
	      chr1 = input[i++];
	      chr2 = input[i++];
	      chr3 = input[i++];
	
	      enc1 = chr1 >> 2;
	      enc2 = (chr1 & 3) << 4 | chr2 >> 4;
	      enc3 = (chr2 & 15) << 2 | chr3 >> 6;
	      enc4 = chr3 & 63;
	
	      if (isNaN(chr2)) {
	        enc3 = enc4 = 64;
	      } else if (isNaN(chr3)) {
	        enc4 = 64;
	      }
	
	      output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
	      chr1 = chr2 = chr3 = '';
	      enc1 = enc2 = enc3 = enc4 = '';
	    } while (i < input.length);
	
	    return output;
	  },
	
	  decode: function decode(input) {
	    var chr1 = undefined,
	        chr2 = undefined,
	        chr3 = '',
	        enc1 = undefined,
	        enc2 = undefined,
	        enc3 = undefined,
	        enc4 = '',
	        i = 0,
	        buf = [];
	
	    // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
	    var base64test = /[^A-Za-z0-9\+\/\=]/g;
	    if (base64test.exec(input)) {
	      throw new Error('There were invalid base64 characters in the input text.\n' + 'Valid base64 characters are A-Z, a-z, 0-9, \'+\', \'/\',and \'=\'\n' + 'Expect errors in decoding.');
	    }
	    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
	
	    do {
	      enc1 = KEY_STR.indexOf(input.charAt(i++));
	      enc2 = KEY_STR.indexOf(input.charAt(i++));
	      enc3 = KEY_STR.indexOf(input.charAt(i++));
	      enc4 = KEY_STR.indexOf(input.charAt(i++));
	
	      chr1 = enc1 << 2 | enc2 >> 4;
	      chr2 = (enc2 & 15) << 4 | enc3 >> 2;
	      chr3 = (enc3 & 3) << 6 | enc4;
	
	      buf.push(chr1);
	
	      if (enc3 !== 64) {
	        buf.push(chr2);
	      }
	      if (enc4 !== 64) {
	        buf.push(chr3);
	      }
	
	      chr1 = chr2 = chr3 = '';
	      enc1 = enc2 = enc3 = enc4 = '';
	    } while (i < input.length);
	
	    return buf;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 15 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var ClassList = (function () {
	  function ClassList(el) {
	    _classCallCheck(this, ClassList);
	
	    this._el = el;
	  }
	
	  _createClass(ClassList, [{
	    key: 'add',
	    value: function add(className) {
	      var classNames = this._el.className.split(' ');
	      classNames.push(className);
	      this._el.className = classNames.join(' ');
	    }
	  }, {
	    key: 'remove',
	    value: function remove(className) {
	      var classNames = this._el.className.split(' ');
	      classNames = classNames.filter(function (cl) {
	        return cl !== className;
	      });
	      this._el.className = classNames.join(' ');
	    }
	  }]);
	
	  return ClassList;
	})();
	
	exports['default'] = ClassList;
	module.exports = exports['default'];

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/* global Image */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _constants = __webpack_require__(17);
	
	var _utils = __webpack_require__(13);
	
	var _utils2 = _interopRequireDefault(_utils);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	var _exif = __webpack_require__(18);
	
	var _exif2 = _interopRequireDefault(_exif);
	
	/**
	 * @class
	 * @alias ImglyKit.ImageExporter
	 * @private
	 */
	
	var ImageExporter = (function () {
	  function ImageExporter() {
	    _classCallCheck(this, ImageExporter);
	  }
	
	  _createClass(ImageExporter, null, [{
	    key: 'validateSettings',
	    value: function validateSettings(renderType, imageFormat) {
	      var settings = {
	        renderType: renderType,
	        imageFormat: imageFormat
	      };
	
	      // Validate RenderType
	      if (typeof settings.renderType !== 'undefined' && settings.renderType !== null && _utils2['default'].values(_constants.RenderType).indexOf(settings.renderType) === -1) {
	        throw new Error('Invalid render type: ' + settings.renderType);
	      } else if (typeof renderType === 'undefined') {
	        settings.renderType = _constants.RenderType.DATAURL;
	      }
	
	      // Validate ImageFormat
	      if (typeof settings.imageFormat !== 'undefined' && settings.imageFormat !== null && _utils2['default'].values(_constants.ImageFormat).indexOf(settings.imageFormat) === -1) {
	        throw new Error('Invalid image format: ' + settings.imageFormat);
	      } else if (typeof imageFormat === 'undefined') {
	        settings.imageFormat = _constants.ImageFormat.PNG;
	      }
	
	      // Render type 'buffer' only available in node
	      if (settings.renderType === _constants.RenderType.BUFFER && typeof process === 'undefined') {
	        throw new Error('Render type \'buffer\' is only available when using node.js');
	      }
	
	      return settings;
	    }
	
	    /**
	     * Exports the image from the given canvas with the given options
	     * @param  {ImglyKit} kit
	     * @param  {Image} image
	     * @param  {Canvas} canvas
	     * @param  {ImglyKit.RenderType} renderType
	     * @param  {ImglyKit.ImageFormat} imageFormat
	     * @param  {Number} quality = 0.8
	     * @return {Promise}
	     */
	  }, {
	    key: 'export',
	    value: function _export(kit, image, canvas, renderType, imageFormat) {
	      var quality = arguments.length <= 5 || arguments[5] === undefined ? 0.8 : arguments[5];
	
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        var result = undefined;
	        if (renderType === _constants.RenderType.IMAGE || renderType === _constants.RenderType.DATAURL) {
	          if (typeof window === 'undefined') {
	            // Quality not supported in node environment / node-canvas
	            result = canvas.toDataURL(imageFormat);
	          } else {
	            result = canvas.toDataURL(imageFormat, quality);
	          }
	
	          // When image's `src` attribute is a jpeg data url, we can restore
	          // the exif information
	          if (_exif2['default'].isJPEG(image.src) && _exif2['default'].isJPEG(result)) {
	            var exif = kit.exif;
	
	            if (exif) {
	              result = exif.restoreExifTags(result);
	            }
	          }
	        }
	
	        if (renderType === _constants.RenderType.IMAGE) {
	          var outputImage = undefined;
	
	          /* istanbul ignore else  */
	          if (typeof window === 'undefined') {
	            // Not a browser environment
	            var CanvasImage = __webpack_require__(7).Image;
	            outputImage = new CanvasImage();
	          } else {
	            outputImage = new Image();
	          }
	
	          outputImage.src = result;
	          resolve(outputImage);
	        } else if (renderType === _constants.RenderType.DATAURL) {
	          resolve(result);
	        } else if (renderType === _constants.RenderType.BUFFER) {
	          resolve(canvas.toBuffer());
	        } else if (renderType === _constants.RenderType.MSBLOB) {
	          resolve(canvas.msToBlob());
	        } else if (renderType === _constants.RenderType.BLOB) {
	          canvas.toBlob(function (blob) {
	            resolve(blob);
	          }, imageFormat, quality);
	        }
	      });
	    }
	  }]);
	
	  return ImageExporter;
	})();
	
	exports['default'] = ImageExporter;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 17 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * The available render types
	 * @enum {string}
	 * @alias ImglyKit.RenderType
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	var RenderType = {
	  IMAGE: 'image',
	  DATAURL: 'data-url',
	  BUFFER: 'buffer',
	  BLOB: 'blob',
	  MSBLOB: 'ms-blob'
	};
	
	exports.RenderType = RenderType;
	/**
	 * The available output image formats
	 * @enum {string}
	 * @alias ImglyKit.ImageFormat
	 */
	var ImageFormat = {
	  PNG: 'image/png',
	  JPEG: 'image/jpeg'
	};
	exports.ImageFormat = ImageFormat;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/*!
	 * Based on https://github.com/exif-js/exif-js by Jacob Seidelin
	 * Licensed under MIT
	 */
	
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _base64 = __webpack_require__(14);
	
	var _base642 = _interopRequireDefault(_base64);
	
	var _arrayStream = __webpack_require__(19);
	
	var _arrayStream2 = _interopRequireDefault(_arrayStream);
	
	var EXIF_TAGS = {
	  0x0100: 'ImageWidth',
	  0x0101: 'ImageHeight',
	  0x8769: 'ExifIFDPointer',
	  0x8825: 'GPSInfoIFDPointer',
	  0xA005: 'InteroperabilityIFDPointer',
	  0x0102: 'BitsPerSample',
	  0x0103: 'Compression',
	  0x0106: 'PhotometricInterpretation',
	  0x0112: 'Orientation',
	  0x0115: 'SamplesPerPixel',
	  0x011C: 'PlanarConfiguration',
	  0x0212: 'YCbCrSubSampling',
	  0x0213: 'YCbCrPositioning',
	  0x011A: 'XResolution',
	  0x011B: 'YResolution',
	  0x0128: 'ResolutionUnit',
	  0x0111: 'StripOffsets',
	  0x0116: 'RowsPerStrip',
	  0x0117: 'StripByteCounts',
	  0x0201: 'JPEGInterchangeFormat',
	  0x0202: 'JPEGInterchangeFormatLength',
	  0x012D: 'TransferFunction',
	  0x013E: 'WhitePoint',
	  0x013F: 'PrimaryChromaticities',
	  0x0211: 'YCbCrCoefficients',
	  0x0214: 'ReferenceBlackWhite',
	  0x0132: 'DateTime',
	  0x010E: 'ImageDescription',
	  0x010F: 'Make',
	  0x0110: 'Model',
	  0x0131: 'Software',
	  0x013B: 'Artist',
	  0x8298: 'Copyright'
	};
	
	var DATA_JPEG_PREFIX = 'data:image/jpeg;base64,';
	var JPEG_REGEX = new RegExp('^' + DATA_JPEG_PREFIX, 'i');
	
	var Exif = (function () {
	  function Exif(buf) {
	    _classCallCheck(this, Exif);
	
	    this._buf = buf;
	    this._stream = new _arrayStream2['default'](this._buf);
	    this._stream.setHead(0);
	
	    this._segments = this._sliceIntoSegments(this._buf);
	    this._exifBuffer = this._getExifBuffer();
	    this._exifStream = new _arrayStream2['default'](this._exifBuffer);
	    this._parseExif();
	  }
	
	  _createClass(Exif, [{
	    key: 'getTags',
	    value: function getTags() {
	      return this._tags;
	    }
	  }, {
	    key: 'getTagData',
	    value: function getTagData() {
	      return this._tagData;
	    }
	
	    /**
	     * Restores the exif tags into the given data url
	     * @return {String} base64String
	     */
	  }, {
	    key: 'restoreExifTags',
	    value: function restoreExifTags(base64String) {
	      // First, make the given string a data array
	      var raw = base64String.replace(DATA_JPEG_PREFIX, '');
	      var data = _base642['default'].decode(raw);
	
	      var segments = this._sliceIntoSegments(data);
	
	      var _segments$1 = _slicedToArray(segments[1], 2);
	
	      var segmentStart = _segments$1[0];
	      var segmentEnd = _segments$1[1];
	
	      var dataBefore = data.slice(0, segmentStart);
	      var dataAfter = data.slice(segmentStart);
	
	      var newData = dataBefore.concat(this._exifBuffer);
	      newData = newData.concat(dataAfter);
	
	      // Make it a base64 string again
	      return DATA_JPEG_PREFIX + _base642['default'].encode(newData);
	    }
	
	    /**
	     * Overwrites the orientation with the given 16 bit integer
	     * @param {Number} orientation
	     */
	  }, {
	    key: 'setOrientation',
	    value: function setOrientation(orientation) {
	      if (this._tagData.Orientation) {
	        var entryOffset = this._tagData.Orientation.entryOffset;
	
	        // Replace value in buffer
	        this._exifStream.setHead(entryOffset + 8);
	        this._exifStream.writeInt16(orientation);
	      }
	    }
	
	    /**
	     * Checks whether the given base64 data url is a jpeg image
	     * @param  {String}  base64String
	     * @return {Boolean}
	     */
	  }, {
	    key: '_parseExif',
	
	    /**
	     * Parses the exif tags
	     * @return {Object}
	     * @private
	     */
	    value: function _parseExif() {
	      this._exifStream.setHead(0);
	      // Skip marker
	      this._exifStream.readInt16();
	      // Skip length
	      this._exifStream.readInt16();
	
	      var header = this._exifStream.readString(4);
	      if (header !== 'Exif') {
	        return;
	      }
	
	      // Skip 2 bytes
	      this._exifStream.readInt16();
	
	      var tiffOffset = this._exifStream.getHead();
	
	      // Find endian type
	      var bigEndian = false;
	      var endian = this._exifStream.readInt16();
	      if (endian === 0x4949) {
	        bigEndian = false;
	      } else if (endian === 0x4d4d) {
	        bigEndian = true;
	      } else {
	        throw new Error('Invalid TIFF data: No endian type found');
	      }
	
	      if (this._exifStream.readInt16(!bigEndian) !== 0x002A) {
	        throw new Error('Invalid TIFF data: No 0x002A');
	      }
	
	      var firstIFDOffset = this._exifStream.readInt32(!bigEndian);
	      if (firstIFDOffset < 8) {
	        throw new Error('Invalid TIFF data: First IFD offset < 8');
	      }
	
	      var ifdOffset = tiffOffset + firstIFDOffset;
	      var tags = this._readTags(this._exifStream, tiffOffset, ifdOffset, bigEndian);
	      this._tags = tags.tags;
	      this._tagData = tags.tagData;
	    }
	
	    /**
	     * Reads the TIFF tags from the stream
	     * @param  {ArrayBuffer} stream
	     * @param  {Number} tiffStart The position where tiff data starts
	     * @param  {Number} ifdStart  The position where the IFD starts
	     * @param  {Boolean} bigEndian
	     * @return {Object}
	     * @private
	     */
	  }, {
	    key: '_readTags',
	    value: function _readTags(stream, tiffStart, ifdStart, bigEndian) {
	      stream.setHead(ifdStart);
	      var entriesCount = stream.readInt16(!bigEndian);
	      var tags = {};
	      var tagData = [];
	
	      for (var i = 0; i < entriesCount; i++) {
	        var entryOffset = ifdStart + i * 12 + 2;
	        stream.setHead(entryOffset);
	        var tag = stream.readInt16(!bigEndian);
	        var type = undefined;
	        var numValues = undefined;
	        var valueOffset = undefined;
	        if (EXIF_TAGS[tag]) {
	          tag = EXIF_TAGS[tag];
	          type = stream.readInt16(!bigEndian);
	          numValues = stream.readInt32(!bigEndian);
	          valueOffset = stream.readInt32(!bigEndian) + tiffStart;
	          var value = null;
	
	          switch (type) {
	            case 1: // byte, 8-bit unsigned int
	            case 7:
	              // undefined, 8-bit byte, value depending on field
	              if (numValues === 1) {
	                value = stream.readInt8(!bigEndian);
	              } else {
	                value = [];
	                for (var _i = 0; _i < numValues; _i++) {
	                  value.push(stream.readInt8(!bigEndian));
	                }
	              }
	              break;
	            case 2:
	              // 8-bit ascii char
	              stream.setHead(numValues > 4 ? valueOffset : entryOffset + 8);
	              value = stream.readString(numValues);
	              break;
	            case 3:
	              // short
	              stream.setHead(numValues > 2 ? valueOffset : entryOffset + 8);
	              if (numValues === 1) {
	                value = stream.readInt16(!bigEndian);
	              } else {
	                value = [];
	                for (var _i2 = 0; _i2 < numValues; _i2++) {
	                  value.push(stream.readInt16(!bigEndian));
	                }
	              }
	              break;
	            case 4: // long
	            case 9:
	              // slong
	              stream.setHead(numValues > 1 ? valueOffset : entryOffset + 8);
	              if (numValues === 1) {
	                value = stream.readInt32(!bigEndian);
	              } else {
	                value = [];
	                for (var _i3 = 0; _i3 < numValues; _i3++) {
	                  value.push(stream.readInt32(!bigEndian));
	                }
	              }
	              break;
	            case 5: // rational (two long values, first numerator, second denominator)
	            case 10:
	              // rational (two slongs)
	              stream.setHead(valueOffset);
	              if (numValues === 1) {
	                var numerator = stream.readInt32(!bigEndian);
	                var denominator = stream.readInt32(!bigEndian);
	                value = numerator / denominator;
	              } else {
	                value = [];
	                for (var _i4 = 0; _i4 < numValues; _i4++) {
	                  var numerator = stream.readInt32(!bigEndian);
	                  var denominator = stream.readInt32(!bigEndian);
	                  var val = numerator / denominator;
	                  value.push(val);
	                }
	              }
	              break;
	          }
	
	          tags[tag] = value;
	          tagData[tag] = {
	            value: value,
	            numValues: numValues,
	            entryOffset: entryOffset,
	            valueOffset: valueOffset,
	            type: type
	          };
	        }
	      }
	
	      return { tags: tags, tagData: tagData };
	    }
	
	    /**
	     * Returns a new buffer containing the Exif segment
	     * @return {Array}
	     * @private
	     */
	  }, {
	    key: '_getExifBuffer',
	    value: function _getExifBuffer() {
	      var segments = this._segments;
	      for (var i = 0; i < segments.length; i++) {
	        var _segments$i = _slicedToArray(segments[i], 2);
	
	        var offset = _segments$i[0];
	        var end = _segments$i[1];
	
	        this._stream.setHead(offset);
	        var marker = this._stream.peekInt16();
	        if (marker === 0xffe1) {
	          return this._buf.slice(offset, end);
	        }
	      }
	      return false;
	    }
	
	    /**
	     * Slices the array into segments
	     * @param  {Array.<Number>} buf
	     * @return {Array}
	     * @private
	     */
	  }, {
	    key: '_sliceIntoSegments',
	    value: function _sliceIntoSegments(buf) {
	      var stream = new _arrayStream2['default'](buf);
	      var segments = [];
	      while (stream.getHead() < buf.length) {
	        var marker = stream.readInt16();
	        if (marker === 0xffd8) {
	          continue;
	        } // SOI
	        if (marker === 0xffda) {
	          break;
	        } // SOS Marker
	
	        if (marker >= 0xff00 && marker <= 0xffff) {
	          // Marker (FF-XX-HL-LL)
	          var _length = stream.readInt16();
	          var end = stream.getHead() + _length - 2;
	          segments.push([stream.getHead() - 4, end]);
	          stream.setHead(end);
	        } else {
	          throw new Error('Invalid marker: 0x' + marker.toString(16));
	        }
	      }
	
	      this._stream.setHead(0);
	
	      return segments;
	    }
	  }, {
	    key: 'dispose',
	    value: function dispose() {
	      this._buf = [];
	      this._exifBuffer = [];
	      this._segments = [];
	    }
	  }], [{
	    key: 'isJPEG',
	    value: function isJPEG(base64String) {
	      return JPEG_REGEX.test(base64String);
	    }
	
	    /**
	     * Creates a new instance of Exif from the given base64-encoded
	     * string
	     * @param  {String} base64String
	     * @return {Exif}
	     */
	  }, {
	    key: 'fromBase64String',
	    value: function fromBase64String(base64String) {
	      var raw = base64String.replace(DATA_JPEG_PREFIX, '');
	      var data = _base642['default'].decode(raw);
	      return new Exif(data);
	    }
	  }]);
	
	  return Exif;
	})();
	
	exports['default'] = Exif;
	module.exports = exports['default'];

/***/ },
/* 19 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var ArrayStream = (function () {
	  function ArrayStream(buf) {
	    _classCallCheck(this, ArrayStream);
	
	    this._head = 0;
	    this._buf = buf;
	  }
	
	  _createClass(ArrayStream, [{
	    key: 'getHead',
	    value: function getHead() {
	      return this._head;
	    }
	  }, {
	    key: 'setHead',
	    value: function setHead(head) {
	      this._head = head;
	    }
	  }, {
	    key: 'peekInt8',
	    value: function peekInt8() {
	      return this._buf[this._head];
	    }
	  }, {
	    key: 'peekInt16',
	    value: function peekInt16() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var a = this._buf[this._head];
	      var b = this._buf[this._head + 1];
	      if (!littleEndian) {
	        return (a << 8) + b;
	      } else {
	        return (b << 8) + a;
	      }
	    }
	  }, {
	    key: 'peekInt24',
	    value: function peekInt24() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var a = this._buf[this._head];
	      var b = this._buf[this._head + 1];
	      var c = this._buf[this._head + 2];
	      if (!littleEndian) {
	        return (a << 16) + (b << 8) + c;
	      } else {
	        return (c << 16) + (b << 8) + a;
	      }
	    }
	  }, {
	    key: 'peekInt32',
	    value: function peekInt32() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var a = this._buf[this._head];
	      var b = this._buf[this._head + 1];
	      var c = this._buf[this._head + 2];
	      var d = this._buf[this._head + 3];
	      if (!littleEndian) {
	        return (a << 32) + (b << 16) + (c << 8) + d;
	      } else {
	        return (d << 32) + (c << 16) + (b << 8) + a;
	      }
	    }
	  }, {
	    key: 'writeInt16',
	    value: function writeInt16(num) {
	      this._buf[this._head] = num >> 8; // upper
	      this._buf[this._head + 1] = num & 0xff; // lower
	    }
	  }, {
	    key: 'readInt8',
	    value: function readInt8() {
	      var num = this.peekInt8();
	      this._head += 1;
	      return num;
	    }
	  }, {
	    key: 'readInt16',
	    value: function readInt16() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var num = this.peekInt16(littleEndian);
	      this._head += 2;
	      return num;
	    }
	  }, {
	    key: 'readInt24',
	    value: function readInt24() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var num = this.peekInt24(littleEndian);
	      this._head += 3;
	      return num;
	    }
	  }, {
	    key: 'readInt32',
	    value: function readInt32() {
	      var littleEndian = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
	
	      var num = this.peekInt32(littleEndian);
	      this._head += 4;
	      return num;
	    }
	  }, {
	    key: 'readString',
	    value: function readString(length) {
	      var str = '';
	      for (var i = 0; i < length; i++) {
	        var character = this.readInt8();
	        str += String.fromCharCode(character);
	      }
	      return str;
	    }
	  }]);
	
	  return ArrayStream;
	})();
	
	exports['default'] = ArrayStream;
	module.exports = exports['default'];

/***/ },
/* 20 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var VERSION_CHECK_FN = 'imglySDKVersionCallback';
	var VERSION_CHECK_URL = 'https://www.photoeditorsdk.com/version.json?sdk=html5&jsoncallback=' + VERSION_CHECK_FN;
	
	var VersionChecker = (function () {
	  function VersionChecker(version) {
	    _classCallCheck(this, VersionChecker);
	
	    this._version = version;
	    this._check();
	  }
	
	  /**
	   * Checks if this version of the SDK is outdated
	   * @private
	   */
	
	  _createClass(VersionChecker, [{
	    key: '_check',
	    value: function _check() {
	      var self = this;
	      window[VERSION_CHECK_FN] = function (response) {
	        if (response.outdated) {
	          console.warn('imgly-sdk-html5: Your version ' + self._version + ' is outdated.');
	          console.warn('imgly-sdk-html5: Current version is ' + response.version + '.');
	        }
	      };
	
	      var script = document.createElement('script');
	      script.src = VERSION_CHECK_URL + '&version=' + this._version;
	      script.async = true;
	      document.getElementsByTagName('head')[0].appendChild(script);
	    }
	  }]);
	
	  return VersionChecker;
	})();
	
	exports['default'] = VersionChecker;
	module.exports = exports['default'];

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	/**
	 * An operation that can crop out a part of the image and rotates it
	 *
	 * @class
	 * @alias ImglyKit.Operations.RotationOperation
	 * @extends ImglyKit.Operation
	 */
	
	var RotationOperation = (function (_Operation) {
	  _inherits(RotationOperation, _Operation);
	
	  function RotationOperation() {
	    _classCallCheck(this, RotationOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(RotationOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this.vertexShader = '\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      varying vec2 v_texCoord;\n      uniform mat3 u_matrix;\n\n      void main() {\n        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    ';
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Rotates the image using WebGL
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(RotationOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var actualDegrees = this._options.degrees % 360;
	
	      // Build the rotation matrix
	      var radians = actualDegrees * (Math.PI / 180);
	      var c = Math.cos(radians);
	      var s = Math.sin(radians);
	      var rotationMatrix = [c, -s, 0, s, c, 0, 0, 0, 1];
	
	      // Run the shader
	      renderer.runShader(this.vertexShader, null, {
	        uniforms: {
	          u_matrix: { type: 'mat3fv', value: rotationMatrix }
	        }
	      });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var actualDegrees = this._options.degrees % 360;
	      var newDimensions = this.getNewDimensions(renderer);
	
	      // Create a rotated canvas
	      var newCanvas = renderer.createCanvas();
	      newCanvas.width = newDimensions.x;
	      newCanvas.height = newDimensions.y;
	      var newContext = newCanvas.getContext('2d');
	
	      newContext.save();
	
	      // Translate the canvas
	      newContext.translate(newCanvas.width / 2, newCanvas.height / 2);
	
	      // Rotate the canvas
	      newContext.rotate(actualDegrees * (Math.PI / 180));
	
	      // Create a temporary canvas so that we can draw the image
	      // with the applied transformation
	      var tempCanvas = renderer.cloneCanvas();
	      newContext.drawImage(tempCanvas, -canvas.width / 2, -canvas.height / 2);
	
	      // Restore old transformation
	      newContext.restore();
	
	      renderer.setCanvas(newCanvas);
	    }
	
	    /**
	     * Gets the new dimensions
	     * @param {Renderer} renderer
	     * @param {Vector2} [dimensions]
	     * @return {Vector2}
	     */
	  }, {
	    key: 'getNewDimensions',
	    value: function getNewDimensions(renderer, dimensions) {
	      dimensions = dimensions || renderer.getSize();
	
	      var actualDegrees = this._options.degrees % 360;
	      if (actualDegrees % 180 !== 0) {
	        dimensions.flip();
	      }
	
	      return dimensions;
	    }
	  }]);
	
	  return RotationOperation;
	})(_operation2['default']);
	
	RotationOperation.prototype.identifier = 'rotation';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	RotationOperation.prototype.availableOptions = {
	  degrees: { type: 'number', 'default': 0, validation: function validation(value) {
	      if (value % 90 !== 0) {
	        throw new Error('RotationOperation: `rotation` has to be a multiple of 90.');
	      }
	    } }
	};
	
	exports['default'] = RotationOperation;
	module.exports = exports['default'];

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused:false */
	/* jshint -W083 */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	/**
	 * Base class for Operations. Extendable via {@link ImglyKit.Operation#extend}.
	 * @class
	 * @alias ImglyKit.Operation
	 */
	
	/**
	 * To create an {@link ImglyKit.Operation} class of your own, call this
	 * method and provide instance properties and functions.
	 * @function
	 */
	
	var _libExtend = __webpack_require__(24);
	
	var _libExtend2 = _interopRequireDefault(_libExtend);
	
	var Operation = (function (_EventEmitter) {
	  _inherits(Operation, _EventEmitter);
	
	  function Operation(kit, options) {
	    _classCallCheck(this, Operation);
	
	    _get(Object.getPrototypeOf(Operation.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this.availableOptions = _libUtils2['default'].extend(this.availableOptions || {}, {
	      numberFormat: { type: 'string', 'default': 'relative', available: ['absolute', 'relative'] }
	    });
	    this._dirty = true;
	
	    this._glslPrograms = {};
	    this._uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
	      var r = Math.random() * 16 | 0;
	      var v = c === 'x' ? r : r & 0x3 | 0x8;
	      return v.toString(16);
	    });
	
	    this._initOptions(options || {});
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Checks whether this Operation can be applied the way it is configured
	   * @return {Promise}
	   */
	
	  _createClass(Operation, [{
	    key: 'validateSettings',
	    value: function validateSettings() {
	      var _this = this;
	
	      var identifier = this.identifier;
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        // Check for required options
	        for (var optionName in _this.availableOptions) {
	          var optionConfig = _this.availableOptions[optionName];
	          if (optionConfig.required && typeof _this._options[optionName] === 'undefined') {
	            return reject(new Error('Operation `' + identifier + '`: Option `' + optionName + '` is required.'));
	          }
	        }
	
	        resolve();
	      });
	    }
	
	    /**
	     * Applies this operation
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     * @abstract
	     */
	  }, {
	    key: 'render',
	    value: function render(renderer) {
	      var renderFn = undefined;
	      if (renderer.identifier === 'webgl') {
	        /* istanbul ignore next */
	        renderFn = this._renderWebGL.bind(this);
	      } else {
	        renderFn = this._renderCanvas.bind(this);
	      }
	
	      // Handle caching
	      if (this._dirty) {
	        renderFn(renderer);
	        renderer.cache(this._uuid);
	        this._dirty = false;
	      } else {
	        renderer.drawCached(this._uuid);
	      }
	    }
	
	    /**
	     * Applies this operation using WebGL
	     * @return {WebGLRenderer} renderer
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL() {
	      throw new Error('Operation#_renderWebGL is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Applies this operation using Canvas2D
	     * @return {CanvasRenderer} renderer
	     * @private
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas() {
	      throw new Error('Operation#_renderCanvas is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Goes through the available options, sets _options defaults
	     * @param {Object} userOptions
	     * @private
	     */
	  }, {
	    key: '_initOptions',
	    value: function _initOptions(userOptions) {
	      this._options = {};
	
	      // Set defaults, create getters and setters
	      var optionName, option, capitalized;
	      var self = this;
	      for (optionName in this.availableOptions) {
	        capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
	        option = this.availableOptions[optionName];
	
	        // Create setter and getter
	        var fn = function fn(optionName, option) {
	          self['set' + capitalized] = function (value) {
	            self._setOption(optionName, value);
	          };
	
	          // Default getter
	          self['get' + capitalized] = function () {
	            return self._getOption(optionName);
	          };
	        };
	        fn(optionName, option);
	
	        // Set default if available
	        if (typeof option['default'] !== 'undefined') {
	          this['set' + capitalized](option['default']);
	        }
	      }
	
	      // Overwrite options with the ones given by user
	      for (optionName in userOptions) {
	        // Check if option is available
	        if (typeof this.availableOptions[optionName] === 'undefined') {
	          throw new Error('Invalid option: ' + optionName);
	        }
	
	        // Call setter
	        capitalized = optionName.charAt(0).toUpperCase() + optionName.slice(1);
	        this['set' + capitalized](userOptions[optionName]);
	      }
	    }
	
	    /**
	     * Sets the given options
	     * @param {Object} options
	     */
	  }, {
	    key: 'set',
	    value: function set(options) {
	      for (var optionName in options) {
	        this._setOption(optionName, options[optionName], false);
	      }
	
	      this.emit('update');
	    }
	
	    /**
	     * Returns the value for the given option
	     * @param {String} optionName
	     * @return {*}
	     * @private
	     */
	  }, {
	    key: '_getOption',
	    value: function _getOption(optionName) {
	      return this._options[optionName];
	    }
	
	    /**
	     * Sets the value for the given option, validates it
	     * @param {String} optionName
	     * @param {*} value
	     * @param {Boolean} update
	     * @private
	     */
	  }, {
	    key: '_setOption',
	    value: function _setOption(optionName, value) {
	      var update = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	      var optionConfig = this.availableOptions[optionName];
	      var identifier = this.identifier;
	
	      if (typeof optionConfig.setter !== 'undefined') {
	        value = optionConfig.setter.call(this, value);
	      }
	
	      if (typeof optionConfig.validation !== 'undefined') {
	        optionConfig.validation(value);
	      }
	
	      switch (optionConfig.type) {
	        // String options
	        case 'string':
	          if (typeof value !== 'string') {
	            throw new Error('Operation `' + identifier + '`: Option `' + optionName + '` has to be a string.');
	          }
	
	          // String value restrictions
	          var available = optionConfig.available;
	          if (typeof available !== 'undefined' && available.indexOf(value) === -1) {
	            throw new Error('Operation `' + identifier + '`: Invalid value for `' + optionName + '` (valid values are: ' + optionConfig.available.join(', ') + ')');
	          }
	
	          this._options[optionName] = value;
	          break;
	
	        // Number options
	        case 'number':
	          if (typeof value !== 'number') {
	            throw new Error('Operation `' + identifier + '`: Option `' + optionName + '` has to be a number.');
	          }
	
	          this._options[optionName] = value;
	          break;
	
	        // Boolean options
	        case 'boolean':
	          if (typeof value !== 'boolean') {
	            throw new Error('Operation `' + identifier + '`: Option `' + optionName + '` has to be a boolean.');
	          }
	
	          this._options[optionName] = value;
	          break;
	
	        // Vector2 options
	        case 'vector2':
	          if (!(value instanceof _libMathVector22['default'])) {
	            throw new Error('Operation `' + identifier + '`: Option `' + optionName + '` has to be an instance of ImglyKit.Vector2.');
	          }
	
	          this._options[optionName] = value.clone();
	
	          break;
	
	        // Color options
	        case 'color':
	          if (!(value instanceof _libColor2['default'])) {
	            throw new Error('Operation `' + identifier + '`: Option `' + optionName + '` has to be an instance of ImglyKit.Color.');
	          }
	
	          this._options[optionName] = value;
	          break;
	
	        // Object options
	        case 'object':
	          this._options[optionName] = value;
	          break;
	
	        // Array options
	        case 'array':
	          this._options[optionName] = value.slice(0);
	          break;
	      }
	
	      this._dirty = true;
	      if (update) {
	        this.emit('update');
	      }
	    }
	
	    /**
	     * Gets the new dimensions
	     * @param {Renderer} renderer
	     * @param {Vector2} [dimensions]
	     * @return {Vector2}
	     * @private
	     */
	  }, {
	    key: 'getNewDimensions',
	    value: function getNewDimensions(renderer, dimensions) {
	      var canvas = renderer.getCanvas();
	      dimensions = dimensions || new _libMathVector22['default'](canvas.width, canvas.height);
	
	      return dimensions;
	    }
	
	    /**
	     * Gets called when this operation has been marked as dirty
	     * @protected
	     */
	  }, {
	    key: '_onDirty',
	    value: function _onDirty() {}
	
	    /**
	     * Resets this operation
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this._dirty = true;
	      this._glslPrograms = {};
	    }
	
	    /**
	     * Sets this operation to dirty, so that it will re-render next time
	     * @param {Boolean} dirty = true
	     */
	  }, {
	    key: 'dirty',
	    set: function set(dirty) {
	      this._dirty = dirty;
	      this._onDirty && this._onDirty();
	    },
	
	    /**
	     * Returns the dirty state
	     * @type {Boolean}
	     */
	    get: function get() {
	      return this._dirty;
	    }
	  }]);
	
	  return Operation;
	})(_libEventEmitter2['default']);
	
	Operation.prototype.identifier = null;
	Operation.extend = _libExtend2['default'];
	
	exports['default'] = Operation;
	module.exports = exports['default'];

/***/ },
/* 23 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Represents a color
	 * @class
	 * @alias ImglyKit.Color
	 * @param {Number} r
	 * @param {Number} g
	 * @param {Number} b
	 * @param {Number} [a]
	 * @private
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Color = (function () {
	  function Color(r, g, b, a) {
	    _classCallCheck(this, Color);
	
	    if (typeof a === 'undefined') {
	      a = 1.0;
	    }
	
	    this.r = r;
	    this.g = g;
	    this.b = b;
	    this.a = a;
	  }
	
	  /**
	   * Returns an rgba() representation of this color
	   * @return {String}
	   */
	
	  _createClass(Color, [{
	    key: 'toRGBA',
	    value: function toRGBA() {
	      var colors = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255), this.a];
	      return 'rgba(' + colors.join(',') + ')';
	    }
	
	    /**
	     * Returns a hex representation of this color
	     * @return {String}
	     */
	  }, {
	    key: 'toHex',
	    value: function toHex() {
	      var components = [this._componentToHex(Math.round(this.r * 255)), this._componentToHex(Math.round(this.g * 255)), this._componentToHex(Math.round(this.b * 255))];
	      return '#' + components.join('');
	    }
	
	    /**
	     * Returns an array with 4 values (0...1)
	     * @return {Array.<Number>}
	     */
	  }, {
	    key: 'toGLColor',
	    value: function toGLColor() {
	      return [this.r, this.g, this.b, this.a];
	    }
	
	    /**
	     * Returns an array with 3 values (0...1)
	     * @return {Array.<Number>}
	     */
	  }, {
	    key: 'toRGBGLColor',
	    value: function toRGBGLColor() {
	      return [this.r, this.g, this.b];
	    }
	
	    /**
	     * Converts the RGB value to HSV
	     * @return {Array.<Number>}
	     */
	  }, {
	    key: 'toHSV',
	    value: function toHSV() {
	      var max = Math.max(this.r, this.g, this.b);
	      var min = Math.min(this.r, this.g, this.b);
	      var h = undefined;
	      var s = undefined;
	      var v = max;
	      var d = max - min;
	      s = max === 0 ? 0 : d / max;
	
	      if (max === min) {
	        h = 0; // achromatic
	      } else {
	          switch (max) {
	            case this.r:
	              h = (this.g - this.b) / d + (this.g < this.b ? 6 : 0);
	              break;
	            case this.g:
	              h = (this.b - this.r) / d + 2;
	              break;
	            case this.b:
	              h = (this.r - this.g) / d + 4;
	              break;
	          }
	          h /= 6;
	        }
	
	      return [h, s, v];
	    }
	
	    /**
	     * Sets the RGB values of this color to match the given HSV values
	     * @param {Number} h
	     * @param {Number} s
	     * @param {Number} v
	     */
	  }, {
	    key: 'fromHSV',
	    value: function fromHSV(h, s, v) {
	      var r = this.r;
	      var g = this.g;
	      var b = this.b;
	
	      var i = Math.floor(h * 6);
	      var f = h * 6 - i;
	      var p = v * (1 - s);
	      var q = v * (1 - f * s);
	      var t = v * (1 - (1 - f) * s);
	
	      switch (i % 6) {
	        case 0:
	          r = v;
	          g = t;
	          b = p;
	          break;
	        case 1:
	          r = q;
	          g = v;
	          b = p;
	          break;
	        case 2:
	          r = p;
	          g = v;
	          b = t;
	          break;
	        case 3:
	          r = p;
	          g = q;
	          b = v;
	          break;
	        case 4:
	          r = t;
	          g = p;
	          b = v;
	          break;
	        case 5:
	          r = v;
	          g = p;
	          b = q;
	          break;
	      }
	
	      this.r = r;
	      this.g = g;
	      this.b = b;
	    }
	
	    /**
	     * Returns a clone of the current color
	     * @return {Color}
	     */
	  }, {
	    key: 'clone',
	    value: function clone() {
	      return new Color(this.r, this.g, this.b, this.a);
	    }
	
	    /**
	     * Returns the given number as hex
	     * @param  {Number} component
	     * @return {String}
	     * @private
	     */
	  }, {
	    key: '_componentToHex',
	    value: function _componentToHex(component) {
	      var hex = component.toString(16);
	      return hex.length === 1 ? '0' + hex : hex;
	    }
	
	    /**
	     * Returns the string representation of this color
	     * @returns {String}
	     */
	  }, {
	    key: 'toString',
	    value: function toString() {
	      return 'Color(' + this.r + ', ' + this.g + ', ' + this.b + ', ' + this.a + ')';
	    }
	  }]);
	
	  return Color;
	})();
	
	exports['default'] = Color;
	module.exports = exports['default'];

/***/ },
/* 24 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Helper function to correctly set up the prototype chain
	 * Based on the backbone.js extend function:
	 * https://github.com/jashkenas/backbone/blob/master/backbone.js
	 * @param  {Object} prototypeProperties
	 * @param  {Object} classProperties
	 * @return {Object}
	 */
	'use strict';
	
	module.exports = function (prototypeProperties, classProperties) {
	  /*jshint validthis:true*/
	  var parent = this;
	  var child;
	
	  // The constructor function for the new subclass is either defined by you
	  // (the 'constructor' property in your `extend` definition), or defaulted
	  // by us to simply call the parent's constructor.
	  if (prototypeProperties && prototypeProperties.hasOwnProperty('constructor')) {
	    child = prototypeProperties.constructor;
	  } else {
	    child = function () {
	      return parent.apply(this, arguments);
	    };
	  }
	
	  // Add static properties to the constructor function, if supplied.
	  var key;
	  for (key in parent) {
	    child[key] = parent[key];
	  }
	  if (typeof classProperties !== 'undefined') {
	    for (key in classProperties) {
	      child[key] = classProperties[key];
	    }
	  }
	
	  // Set the prototype chain to inherit from `parent`, without calling
	  // `parent`'s constructor function.
	  var Surrogate = function Surrogate() {
	    this.constructor = child;
	  };
	  Surrogate.prototype = parent.prototype;
	  child.prototype = new Surrogate();
	
	  // Add prototype properties (instance properties) to the subclass,
	  // if supplied.
	  if (prototypeProperties) {
	    for (key in prototypeProperties) {
	      child.prototype[key] = prototypeProperties[key];
	    }
	  }
	
	  // Set a convenience property in case the parent's prototype is needed
	  // later.
	  child.__super__ = parent.prototype;
	
	  return child;
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	/**
	 * An operation that can flip the canvas
	 *
	 * @class
	 * @alias ImglyKit.Operations.FlipOperation
	 * @extends ImglyKit.Operation
	 */
	
	var FlipOperation = (function (_Operation) {
	  _inherits(FlipOperation, _Operation);
	
	  function FlipOperation() {
	    _classCallCheck(this, FlipOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(FlipOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this.fragmentShader = '\n      precision mediump float;\n      uniform sampler2D u_image;\n      varying vec2 v_texCoord;\n      uniform bool u_flipVertical;\n      uniform bool u_flipHorizontal;\n\n      void main() {\n        vec2 texCoord = vec2(v_texCoord);\n        if (u_flipVertical) {\n          texCoord.y = 1.0 - texCoord.y;\n        }\n        if (u_flipHorizontal) {\n          texCoord.x = 1.0 - texCoord.x;\n        }\n        gl_FragColor = texture2D(u_image, texCoord);\n      }\n    ';
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(FlipOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      renderer.runShader(null, this.fragmentShader, {
	        uniforms: {
	          u_flipVertical: { type: 'f', value: this._options.vertical },
	          u_flipHorizontal: { type: 'f', value: this._options.horizontal }
	        }
	      });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var context = renderer.getContext();
	
	      var scaleX = 1,
	          scaleY = 1;
	      var translateX = 0,
	          translateY = 0;
	
	      if (this._options.horizontal) {
	        scaleX = -1;
	        translateX = canvas.width;
	      }
	
	      if (this._options.vertical) {
	        scaleY = -1;
	        translateY = canvas.height;
	      }
	
	      // Save the current state
	      context.save();
	
	      // Apply the transformation
	      context.translate(translateX, translateY);
	      context.scale(scaleX, scaleY);
	
	      // Create a temporary canvas so that we can draw the image
	      // with the applied transformation
	      var tempCanvas = renderer.cloneCanvas();
	      context.drawImage(tempCanvas, 0, 0);
	
	      // Restore old transformation
	      context.restore();
	    }
	  }]);
	
	  return FlipOperation;
	})(_operation2['default']);
	
	FlipOperation.prototype.identifier = 'flip';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	FlipOperation.prototype.availableOptions = {
	  horizontal: { type: 'boolean', 'default': false },
	  vertical: { type: 'boolean', 'default': false }
	};
	
	exports['default'] = FlipOperation;
	module.exports = exports['default'];

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	var process = process || {};
	(function () {
	  "use strict";
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	var isWindows = process.platform === 'win32';
	var util = __webpack_require__(27);
	
	
	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }
	
	  return parts;
	}
	
	
	if (isWindows) {
	  // Regex to split a windows path into three parts: [*, device, slash,
	  // tail] windows-only
	  var splitDeviceRe =
	      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	
	  // Regex to split the tail part of the above into [*, dir, basename, ext]
	  var splitTailRe =
	      /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
	
	  // Function to split a filename into [root, dir, basename, ext]
	  // windows version
	  var splitPath = function(filename) {
	    // Separate device+slash from tail
	    var result = splitDeviceRe.exec(filename),
	        device = (result[1] || '') + (result[2] || ''),
	        tail = result[3] || '';
	    // Split the tail into dir, basename and extension
	    var result2 = splitTailRe.exec(tail),
	        dir = result2[1],
	        basename = result2[2],
	        ext = result2[3];
	    return [device, dir, basename, ext];
	  };
	
	  var normalizeUNCRoot = function(device) {
	    return '\\\\' + device.replace(/^[\\\/]+/, '').replace(/[\\\/]+/g, '\\');
	  };
	
	  // path.resolve([from ...], to)
	  // windows version
	  exports.resolve = function() {
	    var resolvedDevice = '',
	        resolvedTail = '',
	        resolvedAbsolute = false;
	
	    for (var i = arguments.length - 1; i >= -1; i--) {
	      var path;
	      if (i >= 0) {
	        path = arguments[i];
	      } else if (!resolvedDevice) {
	        path = process.cwd();
	      } else {
	        // Windows has the concept of drive-specific current working
	        // directories. If we've resolved a drive letter but not yet an
	        // absolute path, get cwd for that drive. We're sure the device is not
	        // an unc path at this points, because unc paths are always absolute.
	        path = process.env['=' + resolvedDevice];
	        // Verify that a drive-local cwd was found and that it actually points
	        // to our drive. If not, default to the drive's root.
	        if (!path || path.substr(0, 3).toLowerCase() !==
	            resolvedDevice.toLowerCase() + '\\') {
	          path = resolvedDevice + '\\';
	        }
	      }
	
	      // Skip empty and invalid entries
	      if (!util.isString(path)) {
	        throw new TypeError('Arguments to path.resolve must be strings');
	      } else if (!path) {
	        continue;
	      }
	
	      var result = splitDeviceRe.exec(path),
	          device = result[1] || '',
	          isUnc = device && device.charAt(1) !== ':',
	          isAbsolute = exports.isAbsolute(path),
	          tail = result[3];
	
	      if (device &&
	          resolvedDevice &&
	          device.toLowerCase() !== resolvedDevice.toLowerCase()) {
	        // This path points to another device so it is not applicable
	        continue;
	      }
	
	      if (!resolvedDevice) {
	        resolvedDevice = device;
	      }
	      if (!resolvedAbsolute) {
	        resolvedTail = tail + '\\' + resolvedTail;
	        resolvedAbsolute = isAbsolute;
	      }
	
	      if (resolvedDevice && resolvedAbsolute) {
	        break;
	      }
	    }
	
	    // Convert slashes to backslashes when `resolvedDevice` points to an UNC
	    // root. Also squash multiple slashes into a single one where appropriate.
	    if (isUnc) {
	      resolvedDevice = normalizeUNCRoot(resolvedDevice);
	    }
	
	    // At this point the path should be resolved to a full absolute path,
	    // but handle relative paths to be safe (might happen when process.cwd()
	    // fails)
	
	    // Normalize the tail path
	
	    function f(p) {
	      return !!p;
	    }
	
	    resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/).filter(f),
	                                  !resolvedAbsolute).join('\\');
	
	    return (resolvedDevice + (resolvedAbsolute ? '\\' : '') + resolvedTail) ||
	           '.';
	  };
	
	  // windows version
	  exports.normalize = function(path) {
	    var result = splitDeviceRe.exec(path),
	        device = result[1] || '',
	        isUnc = device && device.charAt(1) !== ':',
	        isAbsolute = exports.isAbsolute(path),
	        tail = result[3],
	        trailingSlash = /[\\\/]$/.test(tail);
	
	    // If device is a drive letter, we'll normalize to lower case.
	    if (device && device.charAt(1) === ':') {
	      device = device[0].toLowerCase() + device.substr(1);
	    }
	
	    // Normalize the tail path
	    tail = normalizeArray(tail.split(/[\\\/]+/).filter(function(p) {
	      return !!p;
	    }), !isAbsolute).join('\\');
	
	    if (!tail && !isAbsolute) {
	      tail = '.';
	    }
	    if (tail && trailingSlash) {
	      tail += '\\';
	    }
	
	    // Convert slashes to backslashes when `device` points to an UNC root.
	    // Also squash multiple slashes into a single one where appropriate.
	    if (isUnc) {
	      device = normalizeUNCRoot(device);
	    }
	
	    return device + (isAbsolute ? '\\' : '') + tail;
	  };
	
	  // windows version
	  exports.isAbsolute = function(path) {
	    var result = splitDeviceRe.exec(path),
	        device = result[1] || '',
	        isUnc = !!device && device.charAt(1) !== ':';
	    // UNC paths are always absolute
	    return !!result[2] || isUnc;
	  };
	
	  // windows version
	  exports.join = function() {
	    function f(p) {
	      if (!util.isString(p)) {
	        throw new TypeError('Arguments to path.join must be strings');
	      }
	      return p;
	    }
	
	    var paths = Array.prototype.filter.call(arguments, f);
	    var joined = paths.join('\\');
	
	    // Make sure that the joined path doesn't start with two slashes, because
	    // normalize() will mistake it for an UNC path then.
	    //
	    // This step is skipped when it is very clear that the user actually
	    // intended to point at an UNC path. This is assumed when the first
	    // non-empty string arguments starts with exactly two slashes followed by
	    // at least one more non-slash character.
	    //
	    // Note that for normalize() to treat a path as an UNC path it needs to
	    // have at least 2 components, so we don't filter for that here.
	    // This means that the user can use join to construct UNC paths from
	    // a server name and a share name; for example:
	    //   path.join('//server', 'share') -> '\\\\server\\share\')
	    if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
	      joined = joined.replace(/^[\\\/]{2,}/, '\\');
	    }
	
	    return exports.normalize(joined);
	  };
	
	  // path.relative(from, to)
	  // it will solve the relative path from 'from' to 'to', for instance:
	  // from = 'C:\\orandea\\test\\aaa'
	  // to = 'C:\\orandea\\impl\\bbb'
	  // The output of the function should be: '..\\..\\impl\\bbb'
	  // windows version
	  exports.relative = function(from, to) {
	    from = exports.resolve(from);
	    to = exports.resolve(to);
	
	    // windows is not case sensitive
	    var lowerFrom = from.toLowerCase();
	    var lowerTo = to.toLowerCase();
	
	    function trim(arr) {
	      var start = 0;
	      for (; start < arr.length; start++) {
	        if (arr[start] !== '') break;
	      }
	
	      var end = arr.length - 1;
	      for (; end >= 0; end--) {
	        if (arr[end] !== '') break;
	      }
	
	      if (start > end) return [];
	      return arr.slice(start, end + 1);
	    }
	
	    var toParts = trim(to.split('\\'));
	
	    var lowerFromParts = trim(lowerFrom.split('\\'));
	    var lowerToParts = trim(lowerTo.split('\\'));
	
	    var length = Math.min(lowerFromParts.length, lowerToParts.length);
	    var samePartsLength = length;
	    for (var i = 0; i < length; i++) {
	      if (lowerFromParts[i] !== lowerToParts[i]) {
	        samePartsLength = i;
	        break;
	      }
	    }
	
	    if (samePartsLength == 0) {
	      return to;
	    }
	
	    var outputParts = [];
	    for (var i = samePartsLength; i < lowerFromParts.length; i++) {
	      outputParts.push('..');
	    }
	
	    outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	    return outputParts.join('\\');
	  };
	
	  exports.sep = '\\';
	  exports.delimiter = ';';
	
	} else /* posix */ {
	
	  // Split a filename into [root, dir, basename, ext], unix version
	  // 'root' is just a slash, or nothing.
	  var splitPathRe =
	      /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	  var splitPath = function(filename) {
	    return splitPathRe.exec(filename).slice(1);
	  };
	
	  // path.resolve([from ...], to)
	  // posix version
	  exports.resolve = function() {
	    var resolvedPath = '',
	        resolvedAbsolute = false;
	
	    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	      var path = (i >= 0) ? arguments[i] : process.cwd();
	
	      // Skip empty and invalid entries
	      if (!util.isString(path)) {
	        throw new TypeError('Arguments to path.resolve must be strings');
	      } else if (!path) {
	        continue;
	      }
	
	      resolvedPath = path + '/' + resolvedPath;
	      resolvedAbsolute = path.charAt(0) === '/';
	    }
	
	    // At this point the path should be resolved to a full absolute path, but
	    // handle relative paths to be safe (might happen when process.cwd() fails)
	
	    // Normalize the path
	    resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {
	      return !!p;
	    }), !resolvedAbsolute).join('/');
	
	    return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	  };
	
	  // path.normalize(path)
	  // posix version
	  exports.normalize = function(path) {
	    var isAbsolute = exports.isAbsolute(path),
	        trailingSlash = path[path.length - 1] === '/',
	        segments = path.split('/'),
	        nonEmptySegments = [];
	
	    // Normalize the path
	    for (var i = 0; i < segments.length; i++) {
	      if (segments[i]) {
	        nonEmptySegments.push(segments[i]);
	      }
	    }
	    path = normalizeArray(nonEmptySegments, !isAbsolute).join('/');
	
	    if (!path && !isAbsolute) {
	      path = '.';
	    }
	    if (path && trailingSlash) {
	      path += '/';
	    }
	
	    return (isAbsolute ? '/' : '') + path;
	  };
	
	  // posix version
	  exports.isAbsolute = function(path) {
	    return path.charAt(0) === '/';
	  };
	
	  // posix version
	  exports.join = function() {
	    var path = '';
	    for (var i = 0; i < arguments.length; i++) {
	      var segment = arguments[i];
	      if (!util.isString(segment)) {
	        throw new TypeError('Arguments to path.join must be strings');
	      }
	      if (segment) {
	        if (!path) {
	          path += segment;
	        } else {
	          path += '/' + segment;
	        }
	      }
	    }
	    return exports.normalize(path);
	  };
	
	
	  // path.relative(from, to)
	  // posix version
	  exports.relative = function(from, to) {
	    from = exports.resolve(from).substr(1);
	    to = exports.resolve(to).substr(1);
	
	    function trim(arr) {
	      var start = 0;
	      for (; start < arr.length; start++) {
	        if (arr[start] !== '') break;
	      }
	
	      var end = arr.length - 1;
	      for (; end >= 0; end--) {
	        if (arr[end] !== '') break;
	      }
	
	      if (start > end) return [];
	      return arr.slice(start, end + 1);
	    }
	
	    var fromParts = trim(from.split('/'));
	    var toParts = trim(to.split('/'));
	
	    var length = Math.min(fromParts.length, toParts.length);
	    var samePartsLength = length;
	    for (var i = 0; i < length; i++) {
	      if (fromParts[i] !== toParts[i]) {
	        samePartsLength = i;
	        break;
	      }
	    }
	
	    var outputParts = [];
	    for (var i = samePartsLength; i < fromParts.length; i++) {
	      outputParts.push('..');
	    }
	
	    outputParts = outputParts.concat(toParts.slice(samePartsLength));
	
	    return outputParts.join('/');
	  };
	
	  exports.sep = '/';
	  exports.delimiter = ':';
	}
	
	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];
	
	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }
	
	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }
	
	  return root + dir;
	};
	
	
	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};
	
	
	exports.extname = function(path) {
	  return splitPath(path)[3];
	};
	
	
	exports.exists = util.deprecate(function(path, callback) {
	  __webpack_require__(30).exists(path, callback);
	}, 'path.exists is now called `fs.exists`.');
	
	
	exports.existsSync = util.deprecate(function(path) {
	  return __webpack_require__(30).existsSync(path);
	}, 'path.existsSync is now called `fs.existsSync`.');
	
	
	if (isWindows) {
	  exports._makeLong = function(path) {
	    // Note: this will *probably* throw somewhere.
	    if (!util.isString(path))
	      return path;
	
	    if (!path) {
	      return '';
	    }
	
	    var resolvedPath = exports.resolve(path);
	
	    if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
	      // path is local filesystem path, which needs to be converted
	      // to long UNC path.
	      return '\\\\?\\' + resolvedPath;
	    } else if (/^\\\\[^?.]/.test(resolvedPath)) {
	      // path is network UNC path, which needs to be converted
	      // to long UNC path.
	      return '\\\\?\\UNC\\' + resolvedPath.substring(2);
	    }
	
	    return path;
	  };
	} else {
	  exports._makeLong = function(path) {
	    return path;
	  };
	}
	}());


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }
	
	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};
	
	
	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }
	
	  if (process.noDeprecation === true) {
	    return fn;
	  }
	
	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }
	
	  return deprecated;
	};
	
	
	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};
	
	
	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;
	
	
	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};
	
	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};
	
	
	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];
	
	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}
	
	
	function stylizeNoColor(str, styleType) {
	  return str;
	}
	
	
	function arrayToHash(array) {
	  var hash = {};
	
	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });
	
	  return hash;
	}
	
	
	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }
	
	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }
	
	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);
	
	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }
	
	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }
	
	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }
	
	  var base = '', array = false, braces = ['{', '}'];
	
	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }
	
	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }
	
	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }
	
	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }
	
	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }
	
	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }
	
	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }
	
	  ctx.seen.push(value);
	
	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }
	
	  ctx.seen.pop();
	
	  return reduceToSingleString(output, base, braces);
	}
	
	
	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}
	
	
	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}
	
	
	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}
	
	
	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }
	
	  return name + ': ' + str;
	}
	
	
	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);
	
	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }
	
	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}
	
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = __webpack_require__(28);
	
	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	
	
	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}
	
	
	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];
	
	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}
	
	
	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};
	
	
	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(29);
	
	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;
	
	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};
	
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(11)))

/***/ },
/* 28 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 29 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 30 */
/***/ function(module, exports) {



/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint unused: false */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Base class for filters. Extendable via {@link ImglyKit.Filter#extend}
	 * @class
	 * @alias ImglyKit.Filter
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Filter = (function () {
	  function Filter() {
	    _classCallCheck(this, Filter);
	  }
	
	  /**
	   * To create an {@link ImglyKit.Filter} class of your own, call this
	   * method and provide instance properties and functions.
	   * @function
	   */
	
	  _createClass(Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      /* istanbul ignore next */
	      throw new Error('Filter#render is abstract and not implemented in inherited class.');
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return null;
	    }
	  }]);
	
	  return Filter;
	})();
	
	Filter.extend = __webpack_require__(24);
	
	// Exposed classes
	Filter.PrimitivesStack = __webpack_require__(32);
	Filter.Primitives = {};
	Filter.Primitives.Saturation = __webpack_require__(33);
	Filter.Primitives.LookupTable = __webpack_require__(35);
	Filter.Primitives.ToneCurve = __webpack_require__(36);
	Filter.Primitives.SoftColorOverlay = __webpack_require__(37);
	Filter.Primitives.Desaturation = __webpack_require__(38);
	Filter.Primitives.X400 = __webpack_require__(39);
	Filter.Primitives.Grayscale = __webpack_require__(40);
	Filter.Primitives.Contrast = __webpack_require__(41);
	Filter.Primitives.Glow = __webpack_require__(42);
	Filter.Primitives.Gobblin = __webpack_require__(43);
	Filter.Primitives.Brightness = __webpack_require__(44);
	
	exports['default'] = Filter;
	module.exports = exports['default'];

/***/ },
/* 32 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * A helper class that can collect {@link Primitive} instances and render
	 * the stack
	 * @class
	 * @alias ImglyKit.Filter.PrimitivesStack
	 */
	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var PrimitivesStack = (function () {
	  function PrimitivesStack() {
	    _classCallCheck(this, PrimitivesStack);
	
	    /**
	     * The stack of {@link ImglyKit.Filter.Primitive} instances
	     * @type {Array}
	     * @private
	     */
	    this._stack = [];
	  }
	
	  /**
	   * Adds the given primitive to the stack
	   * @param {ImglyKit.Filter.Primitive} primitive
	   */
	
	  _createClass(PrimitivesStack, [{
	    key: "add",
	    value: function add(primitive) {
	      this._stack.push(primitive);
	    }
	
	    /**
	     * Renders the stack of primitives on the renderer
	     * @param  {Renderer} renderer
	     */
	  }, {
	    key: "render",
	    value: function render(renderer) {
	      for (var i = 0; i < this._stack.length; i++) {
	        var primitive = this._stack[i];
	        primitive.render(renderer);
	      }
	    }
	  }]);
	
	  return PrimitivesStack;
	})();
	
	exports["default"] = PrimitivesStack;
	module.exports = exports["default"];

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Saturation primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Saturation
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Saturation = (function (_Primitive) {
	  _inherits(Saturation, _Primitive);
	
	  function Saturation() {
	    _classCallCheck(this, Saturation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Saturation.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      saturation: 0
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_saturation;\n\n      const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float luminance = dot(texColor.rgb, luminanceWeighting);\n\n        vec3 greyScaleColor = vec3(luminance);\n\n        gl_FragColor = vec4(mix(greyScaleColor, texColor.rgb, u_saturation) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(Saturation, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], {
	        uniforms: {
	          u_saturation: { type: 'f', value: this._options.saturation }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     * @return {Promise}
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var saturation = this._options.saturation;
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
	          imageData.data[index] = luminance * (1 - saturation) + imageData.data[index] * saturation;
	          imageData.data[index + 1] = luminance * (1 - saturation) + imageData.data[index + 1] * saturation;
	          imageData.data[index + 2] = luminance * (1 - saturation) + imageData.data[index + 2] * saturation;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Saturation;
	})(_primitive2['default']);
	
	exports['default'] = Saturation;
	module.exports = exports['default'];

/***/ },
/* 34 */
/***/ function(module, exports) {

	/* jshint unused: false */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	/**
	 * Base class for primitives. Extendable via {@link ImglyKit.Filter.Primitive#extend}
	 * @class
	 * @alias ImglyKit.Filter.Primitive
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Primitive = (function () {
	  function Primitive(options) {
	    _classCallCheck(this, Primitive);
	
	    options = options || {};
	
	    this._glslPrograms = {};
	    this._options = options;
	  }
	
	  /**
	   * Renders the primitive
	   * @param  {Renderer} renderer
	   * @return {Promise}
	   */
	
	  _createClass(Primitive, [{
	    key: 'render',
	    value: function render(renderer) {
	      if (renderer.identifier === 'webgl') {
	        this.renderWebGL(renderer);
	      } else {
	        this.renderCanvas(renderer);
	      }
	    }
	
	    /**
	     * Renders the primitive (WebGL)
	     * @param  {CanvasRenderer} renderer
	     */
	    /* istanbul ignore next */
	  }, {
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      /* istanbul ignore next */
	      throw new Error('Primitive#renderWebGL is abstract and not implemented in inherited class.');
	    }
	
	    /**
	     * Renders the primitive (Canvas2D)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      /* istanbul ignore next */
	      throw new Error('Primitive#renderCanvas is abstract and not implemented in inherited class.');
	    }
	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    }
	  }]);
	
	  return Primitive;
	})();
	
	exports['default'] = Primitive;
	module.exports = exports['default'];

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Stores a 256 byte long lookup table in a 2d texture which will be
	 * used to look up the corresponding value for each channel.
	 * @class
	 * @alias ImglyKit.Filter.Primitives.LookupTable
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var LookupTable = (function (_Primitive) {
	  _inherits(LookupTable, _Primitive);
	
	  function LookupTable() {
	    _classCallCheck(this, LookupTable);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(LookupTable.prototype), 'constructor', this).apply(this, args);
	
	    this._textureIndex = 3;
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_lookupTable;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float r = texture2D(u_lookupTable, vec2(texColor.r, 0.0)).r;\n        float g = texture2D(u_lookupTable, vec2(texColor.g, 0.0)).g;\n        float b = texture2D(u_lookupTable, vec2(texColor.b, 0.0)).b;\n\n        gl_FragColor = vec4(vec3(r, g, b) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(LookupTable, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      this._updateTexture(renderer);
	
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_lookupTable: { type: 'i', value: 3 }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var table = this._options.data;
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var r = imageData.data[index];
	          imageData.data[index] = table[r * 4];
	          var g = imageData.data[index + 1];
	          imageData.data[index + 1] = table[1 + g * 4];
	          var b = imageData.data[index + 2];
	          imageData.data[index + 2] = table[2 + b * 4];
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	
	    /**
	     * Updates the lookup table texture (WebGL only)
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_updateTexture',
	    value: function _updateTexture(renderer) {
	      var gl = renderer.getContext();
	
	      if (typeof this._options.data === 'undefined') {
	        throw new Error('LookupTable: No data specified.');
	      }
	
	      var dataTypedArray = new Uint8Array(this._options.data);
	
	      gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
	      if (!this._texture) {
	        this._texture = gl.createTexture();
	      }
	      gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 256, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, dataTypedArray);
	      gl.activeTexture(gl.TEXTURE0);
	    }
	  }]);
	
	  return LookupTable;
	})(_primitive2['default']);
	
	exports['default'] = LookupTable;
	module.exports = exports['default'];

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _lookupTable = __webpack_require__(35);
	
	var _lookupTable2 = _interopRequireDefault(_lookupTable);
	
	/**
	 * Tone curve primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.ToneCurve
	 * @extends {ImglyKit.Filter.Primitives.LookupTable}
	 */
	
	var ToneCurve = (function (_LookupTable) {
	  _inherits(ToneCurve, _LookupTable);
	
	  function ToneCurve() {
	    _classCallCheck(this, ToneCurve);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(ToneCurve.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      rgbControlPoints: {
	        red: this._options.controlPoints,
	        green: this._options.controlPoints,
	        blue: this._options.controlPoints
	      }
	    });
	
	    if (typeof this._options.rgbControlPoints !== 'undefined') {
	      this._updateLookupTable();
	    }
	  }
	
	  /**
	   * Calculates the lookup table
	   * @private
	   */
	
	  _createClass(ToneCurve, [{
	    key: '_updateLookupTable',
	    value: function _updateLookupTable() {
	      var r = this._calculateSplineCurve(this._options.rgbControlPoints.red);
	      var g = this._calculateSplineCurve(this._options.rgbControlPoints.green);
	      var b = this._calculateSplineCurve(this._options.rgbControlPoints.blue);
	
	      this._options.data = this._buildLookupTable(r, g, b);
	    }
	
	    /**
	     * Builds the lookup table
	     * @param  {Array} r
	     * @param  {Array} g
	     * @param  {Array} b
	     * @return {Array}
	     * @private
	     */
	  }, {
	    key: '_buildLookupTable',
	    value: function _buildLookupTable(r, g, b) {
	      var data = [];
	
	      for (var i = 0; i < 256; i++) {
	        data.push(Math.min(Math.max(i + r[i], 0), 255));
	        data.push(Math.min(Math.max(i + g[i], 0), 255));
	        data.push(Math.min(Math.max(i + b[i], 0), 255));
	        data.push(255);
	      }
	
	      return data;
	    }
	
	    /**
	     * Calculates the spline curve data for the given points
	     * @param  {Array.<Array.<Number>>} points
	     * @return {Array.<Number>}
	     */
	  }, {
	    key: '_calculateSplineCurve',
	    value: function _calculateSplineCurve(points) {
	      points = points.sort(function (a, b) {
	        return a[0] > b[0];
	      });
	
	      var splinePoints = this._getSplineCurve(points);
	      var firstSplinePoint = splinePoints[0];
	      var i;
	
	      if (firstSplinePoint[0] > 0) {
	        for (i = 0; i < firstSplinePoint[0]; i++) {
	          splinePoints.unshift([0, 0]);
	        }
	      }
	
	      var preparedPoints = [];
	      for (i = 0; i < splinePoints.length; i++) {
	        var newPoint = splinePoints[i];
	        var origPoint = [newPoint[0], newPoint[0]];
	
	        var distance = Math.sqrt(Math.pow(origPoint[0] - newPoint[0], 2) + Math.pow(origPoint[1] - newPoint[1], 2));
	
	        if (origPoint[1] > newPoint[1]) {
	          distance = -distance;
	        }
	
	        preparedPoints.push(distance);
	      }
	
	      return preparedPoints;
	    }
	  }, {
	    key: '_getSplineCurve',
	    value: function _getSplineCurve(points) {
	      var sdA = this._secondDerivative(points);
	
	      var n = sdA.length;
	      var sd = [];
	      var i;
	
	      for (i = 0; i < n; i++) {
	        sd[i] = sdA[i];
	      }
	
	      var output = [];
	
	      for (i = 0; i < n - 1; i++) {
	        var cur = points[i];
	        var next = points[i + 1];
	
	        for (var x = cur[0]; x < next[0]; x++) {
	          var t = (x - cur[0]) / (next[0] - cur[0]);
	
	          var a = 1 - t;
	          var b = t;
	          var h = next[0] - cur[0];
	
	          var y = a * cur[1] + b * next[1] + h * h / 6 * ((a * a * a - a) * sd[i] + (b * b * b - b) * sd[i + 1]);
	
	          if (y > 255) {
	            y = 255;
	          } else if (y < 0) {
	            y = 0;
	          }
	
	          output.push([x, y]);
	        }
	      }
	
	      if (output.length === 255) {
	        output.push(points[points.length - 1]);
	      }
	
	      return output;
	    }
	  }, {
	    key: '_secondDerivative',
	    value: function _secondDerivative(points) {
	      var n = points.length;
	      if (n <= 0 || n === 1) {
	        return null;
	      }
	
	      var matrix = [];
	      var result = [];
	      var i, k;
	
	      matrix[0] = [0, 1, 0];
	
	      for (i = 1; i < n - 1; i++) {
	        var P1 = points[i - 1];
	        var P2 = points[i];
	        var P3 = points[i + 1];
	
	        matrix[i] = matrix[i] || [];
	        matrix[i][0] = (P2[0] - P1[0]) / 6;
	        matrix[i][1] = (P3[0] - P1[0]) / 3;
	        matrix[i][2] = (P3[0] - P2[0]) / 6;
	        result[i] = (P3[1] - P2[1]) / (P3[0] - P2[0]) - (P2[1] - P1[1]) / (P2[0] - P1[0]);
	      }
	
	      result[0] = 0;
	      result[n - 1] = 0;
	
	      matrix[n - 1] = [0, 1, 0];
	
	      // Pass 1
	      for (i = 1; i < n; i++) {
	        k = matrix[1][0] / matrix[i - 1][1];
	        matrix[i][1] -= k * matrix[i - 1][2];
	        matrix[i][0] = 0;
	        result[i] -= k * result[i - 1];
	      }
	
	      // Pass 2
	      for (i = n - 2; i > 0; i--) {
	        k = matrix[i][2] / matrix[i + 1][1];
	        matrix[i][1] -= k * matrix[i + 1][0];
	        matrix[i][2] = 0;
	        result[i] -= k * result[i + 1];
	      }
	
	      var y2 = [];
	      for (i = 0; i < n; i++) {
	        y2[i] = result[i] / matrix[i][1];
	      }
	
	      return y2;
	    }
	  }]);
	
	  return ToneCurve;
	})(_lookupTable2['default']);
	
	exports['default'] = ToneCurve;
	module.exports = exports['default'];

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	/**
	 * SoftColorOverlay primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.SoftColorOverlay
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var SoftColorOverlay = (function (_Primitive) {
	  _inherits(SoftColorOverlay, _Primitive);
	
	  function SoftColorOverlay() {
	    _classCallCheck(this, SoftColorOverlay);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(SoftColorOverlay.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      color: new _libColor2['default'](1.0, 1.0, 1.0)
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform vec3 u_overlay;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        vec4 overlayVec4 = vec4(u_overlay, texColor.a);\n        gl_FragColor = max(overlayVec4 * texColor.a, texColor);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(SoftColorOverlay, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_overlay: { type: '3f', value: this._options.color.toRGBGLColor() }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          imageData.data[index] = Math.max(this._options.color.r, imageData.data[index]);
	          imageData.data[index + 1] = Math.max(this._options.color.g, imageData.data[index + 1]);
	          imageData.data[index + 2] = Math.max(this._options.color.b, imageData.data[index + 2]);
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return SoftColorOverlay;
	})(_primitive2['default']);
	
	exports['default'] = SoftColorOverlay;
	module.exports = exports['default'];

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Desaturation primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Desaturation
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Desaturation = (function (_Primitive) {
	  _inherits(Desaturation, _Primitive);
	
	  function Desaturation() {
	    _classCallCheck(this, Desaturation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Desaturation.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      desaturation: 1.0
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_desaturation;\n\n      const vec3 luminanceWeighting = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        vec3 grayXfer = vec3(0.3, 0.59, 0.11);\n        vec3 gray = vec3(dot(grayXfer, texColor.xyz));\n        gl_FragColor = vec4(mix(texColor.xyz, gray, u_desaturation) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   * @return {Promise}
	   */
	  /* istanbul ignore next */
	
	  _createClass(Desaturation, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_desaturation: { type: 'f', value: this._options.desaturation }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var desaturation = this._options.desaturation;
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var luminance = imageData.data[index] * 0.3 + imageData.data[index + 1] * 0.59 + imageData.data[index + 2] * 0.11;
	          imageData.data[index] = luminance * (1 - desaturation) + imageData.data[index] * desaturation;
	          imageData.data[index + 1] = luminance * (1 - desaturation) + imageData.data[index + 1] * desaturation;
	          imageData.data[index + 2] = luminance * (1 - desaturation) + imageData.data[index + 2] * desaturation;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Desaturation;
	})(_primitive2['default']);
	
	exports['default'] = Desaturation;
	module.exports = exports['default'];

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * X400 primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.X400
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var X400 = (function (_Primitive) {
	  _inherits(X400, _Primitive);
	
	  function X400() {
	    _classCallCheck(this, X400);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(X400.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float gray = texColor.r * 0.3 + texColor.g * 0.3 + texColor.b * 0.3;\n        gray -= 0.2;\n        gray = clamp(gray, 0.0, 1.0);\n        gray += 0.15;\n        gray *= 1.4;\n        gl_FragColor = vec4(vec3(gray) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(X400, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader);
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var gray = imageData.data[index] / 255 * 0.3 + imageData.data[index + 1] / 255 * 0.3 + imageData.data[index + 2] / 255 * 0.3;
	          gray -= 0.2;
	          gray = Math.max(0.0, Math.min(1.0, gray));
	          gray += 0.15;
	          gray *= 1.4;
	
	          gray *= 255;
	          imageData.data[index] = gray;
	          imageData.data[index + 1] = gray;
	          imageData.data[index + 2] = gray;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return X400;
	})(_primitive2['default']);
	
	exports['default'] = X400;
	module.exports = exports['default'];

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Grayscale primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Grayscale
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Grayscale = (function (_Primitive) {
	  _inherits(Grayscale, _Primitive);
	
	  function Grayscale() {
	    _classCallCheck(this, Grayscale);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Grayscale.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      vec3 W = vec3(0.2125, 0.7154, 0.0721);\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        float luminance = dot(texColor.rgb, W);\n        gl_FragColor = vec4(vec3(luminance) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   * @return {Promise}
	   */
	  /* istanbul ignore next */
	
	  _createClass(Grayscale, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader);
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var luminance = imageData.data[index] * 0.2125 + imageData.data[index + 1] * 0.7154 + imageData.data[index + 2] * 0.0721;
	
	          imageData.data[index] = luminance;
	          imageData.data[index + 1] = luminance;
	          imageData.data[index + 2] = luminance;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Grayscale;
	})(_primitive2['default']);
	
	exports['default'] = Grayscale;
	module.exports = exports['default'];

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Contrast primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Contrast
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Contrast = (function (_Primitive) {
	  _inherits(Contrast, _Primitive);
	
	  function Contrast() {
	    _classCallCheck(this, Contrast);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Contrast.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      contrast: 1.0
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_contrast;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        gl_FragColor = vec4(((texColor.rgb - vec3(0.5)) * u_contrast + vec3(0.5) * texColor.a), texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(Contrast, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], {
	        uniforms: {
	          u_contrast: { type: 'f', value: this._options.contrast }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var contrast = this._options.contrast;
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          imageData.data[index] = (imageData.data[index] - 127) * contrast + 127;
	          imageData.data[index + 1] = (imageData.data[index + 1] - 127) * contrast + 127;
	          imageData.data[index + 2] = (imageData.data[index + 2] - 127) * contrast + 127;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Contrast;
	})(_primitive2['default']);
	
	exports['default'] = Contrast;
	module.exports = exports['default'];

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	/**
	 * Glow primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Glow
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Glow = (function (_Primitive) {
	  _inherits(Glow, _Primitive);
	
	  function Glow() {
	    _classCallCheck(this, Glow);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Glow.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      color: new _libColor2['default'](1, 1, 1)
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      uniform vec3 u_color;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n\n        vec2 textureCoord = v_texCoord - vec2(0.5, 0.5);\n        textureCoord /= 0.75;\n\n        float d = 1.0 - dot(textureCoord, textureCoord);\n        d = clamp(d, 0.2, 1.0);\n        vec3 newColor = texColor.rgb * d * u_color.rgb;\n        gl_FragColor = vec4(vec3(newColor) * texColor.a, texColor.a);\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   * @return {Promise}
	   */
	  /* istanbul ignore next */
	
	  _createClass(Glow, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_color: { type: '3f', value: this._options.color.toRGBGLColor() }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     * @return {Promise}
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var color = this._options.color;
	
	      var d;
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          var x01 = x / canvas.width;
	          var y01 = y / canvas.height;
	
	          var nx = (x01 - 0.5) / 0.75;
	          var ny = (y01 - 0.5) / 0.75;
	
	          var scalarX = nx * nx;
	          var scalarY = ny * ny;
	          d = 1 - (scalarX + scalarY);
	          d = Math.min(Math.max(d, 0.1), 1.0);
	
	          imageData.data[index] = imageData.data[index] * (d * color.r);
	          imageData.data[index + 1] = imageData.data[index + 1] * (d * color.g);
	          imageData.data[index + 2] = imageData.data[index + 2] * (d * color.b);
	          imageData.data[index + 3] = 255;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Glow;
	})(_primitive2['default']);
	
	exports['default'] = Glow;
	module.exports = exports['default'];

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Gobblin primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Gobblin
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Gobblin = (function (_Primitive) {
	  _inherits(Gobblin, _Primitive);
	
	  function Gobblin() {
	    _classCallCheck(this, Gobblin);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Gobblin.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        texColor.b = texColor.g * 0.33;\n        texColor.r = texColor.r * 0.6;\n        texColor.b += texColor.r * 0.33;\n        texColor.g = texColor.g * 0.7;\n        gl_FragColor = texColor;\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   * @return {Promise}
	   */
	  /* istanbul ignore next */
	
	  _createClass(Gobblin, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      renderer.runShader(null, this._fragmentShader);
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          imageData.data[index + 2] = imageData.data[index + 1] * 0.33;
	          imageData.data[index] = imageData.data[index] * 0.6;
	          imageData.data[index + 2] += imageData.data[index] * 0.33;
	          imageData.data[index + 1] = imageData.data[index + 1] * 0.7;
	          imageData.data[index + 3] = 255;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Gobblin;
	})(_primitive2['default']);
	
	exports['default'] = Gobblin;
	module.exports = exports['default'];

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _primitive = __webpack_require__(34);
	
	var _primitive2 = _interopRequireDefault(_primitive);
	
	/**
	 * Brightness primitive
	 * @class
	 * @alias ImglyKit.Filter.Primitives.Brightness
	 * @extends {ImglyKit.Filter.Primitive}
	 */
	
	var Brightness = (function (_Primitive) {
	  _inherits(Brightness, _Primitive);
	
	  function Brightness() {
	    _classCallCheck(this, Brightness);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(Brightness.prototype), 'constructor', this).apply(this, args);
	
	    this._options = _libUtils2['default'].defaults(this._options, {
	      brightness: 1.0
	    });
	
	    /**
	     * The fragment shader for this primitive
	     * @return {String}
	     * @private
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform float u_brightness;\n\n      void main() {\n        vec4 texColor = texture2D(u_image, v_texCoord);\n        gl_FragColor = vec4((texColor.rgb + vec3(u_brightness) * texColor.a), texColor.a);;\n      }\n    ';
	  }
	
	  /**
	   * Renders the primitive (WebGL)
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(Brightness, [{
	    key: 'renderWebGL',
	    value: function renderWebGL(renderer) {
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], {
	        uniforms: {
	          u_brightness: { type: 'f', value: this._options.brightness }
	        }
	      });
	    }
	
	    /**
	     * Renders the primitive (Canvas)
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: 'renderCanvas',
	    value: function renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var imageData = renderer.getContext().getImageData(0, 0, canvas.width, canvas.height);
	      var brightness = this._options.brightness;
	
	      for (var x = 0; x < canvas.width; x++) {
	        for (var y = 0; y < canvas.height; y++) {
	          var index = (canvas.width * y + x) * 4;
	
	          imageData.data[index] = imageData.data[index] + brightness * 255;
	          imageData.data[index + 1] = imageData.data[index + 1] + brightness * 255;
	          imageData.data[index + 2] = imageData.data[index + 2] + brightness * 255;
	        }
	      }
	
	      renderer.getContext().putImageData(imageData, 0, 0);
	    }
	  }]);
	
	  return Brightness;
	})(_primitive2['default']);
	
	exports['default'] = Brightness;
	module.exports = exports['default'];

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _filtersIdentityFilter = __webpack_require__(46);
	
	var _filtersIdentityFilter2 = _interopRequireDefault(_filtersIdentityFilter);
	
	/**
	 * An operation that can apply a selected filter
	 *
	 * @class
	 * @alias ImglyKit.Operations.FiltersOperation
	 * @extends ImglyKit.Operation
	 */
	
	var FiltersOperation = (function (_Operation) {
	  _inherits(FiltersOperation, _Operation);
	
	  function FiltersOperation() {
	    _classCallCheck(this, FiltersOperation);
	
	    _get(Object.getPrototypeOf(FiltersOperation.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  _createClass(FiltersOperation, [{
	    key: '_renderWebGL',
	
	    /**
	     * Renders the filter using WebGL
	     * @param  {WebGLRenderer} renderer
	     * @override
	     */
	    /* istanbul ignore next */
	    value: function _renderWebGL(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the filter using Canvas2D
	     * @param {CanvasRenderer} renderer
	     * @override
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the filter (all renderers supported)
	     * @param {Renderer} renderer
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render(renderer) {
	      this._selectedFilter.render(renderer);
	    }
	  }]);
	
	  return FiltersOperation;
	})(_operation2['default']);
	
	FiltersOperation.prototype.identifier = 'filters';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	FiltersOperation.prototype.availableOptions = {
	  filter: { type: 'object', 'default': _filtersIdentityFilter2['default'],
	    setter: function setter(Filter) {
	      this._selectedFilter = new Filter();
	      return Filter;
	    }
	  }
	};
	
	exports['default'] = FiltersOperation;
	module.exports = exports['default'];

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Identity Filter
	 * @class
	 * @alias ImglyKit.Filters.IdentityFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var IdentityFilter = (function (_Filter) {
	  _inherits(IdentityFilter, _Filter);
	
	  function IdentityFilter() {
	    _classCallCheck(this, IdentityFilter);
	
	    _get(Object.getPrototypeOf(IdentityFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(IdentityFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @return {Promise}
	     */
	    value: function render() {
	      // This is the identity filter, it doesn't have any effect.
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Original';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'identity';
	    }
	  }]);
	
	  return IdentityFilter;
	})(_filter2['default']);
	
	exports['default'] = IdentityFilter;
	module.exports = exports['default'];

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _renderersWebglRendererJs = __webpack_require__(12);
	
	var _renderersWebglRendererJs2 = _interopRequireDefault(_renderersWebglRendererJs);
	
	/**
	 * An operation that can crop out a part of the image
	 *
	 * @class
	 * @alias ImglyKit.Operations.CropOperation
	 * @extends ImglyKit.Operation
	 */
	
	var CropOperation = (function (_Operation) {
	  _inherits(CropOperation, _Operation);
	
	  function CropOperation() {
	    _classCallCheck(this, CropOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(CropOperation.prototype), 'constructor', this).apply(this, args);
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Rotates and crops the image using WebGL
	   * @param  {WebGLRenderer} renderer
	   * @override
	   * @private
	   */
	  /* istanbul ignore next */
	
	  _createClass(CropOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var start = this._options.start.clone();
	      var end = this._options.end.clone();
	      var size = end.clone().subtract(start);
	      var fragmentShader = null;
	
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, fragmentShader, textureCoordinates);
	      }
	
	      var textureCoordinates = new Float32Array([
	      // First triangle
	      start.x, 1.0 - end.y, end.x, 1.0 - end.y, start.x, 1.0 - start.y,
	
	      // Second triangle
	      start.x, 1.0 - start.y, end.x, 1.0 - end.y, end.x, 1.0 - start.y]);
	      renderer.runProgram(this._glslPrograms[renderer.id], { textureCoordinates: textureCoordinates });
	    }
	
	    /**
	     * Crops the image using Canvas
	     * @param {CanvasRenderer} renderer
	     * @override
	     * @private
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var dimensions = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var newDimensions = this.getNewDimensions(renderer);
	
	      // Create a temporary canvas to draw to
	      var newCanvas = renderer.createCanvas();
	      newCanvas.width = newDimensions.x;
	      newCanvas.height = newDimensions.y;
	      var newContext = newCanvas.getContext('2d');
	
	      // The upper left corner of the cropped area on the original image
	      var startPosition = this._options.start.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        startPosition.multiply(dimensions);
	      }
	
	      // Draw the source canvas onto the new one
	      newContext.drawImage(canvas, startPosition.x, startPosition.y, // source x, y
	      newDimensions.x, newDimensions.y, // source dimensions
	      0, 0, // destination x, y
	      newDimensions.x, newDimensions.y // destination dimensions
	      );
	
	      // Set the new canvas
	      renderer.setCanvas(newCanvas);
	    }
	
	    /**
	     * Gets the new dimensions
	     * @param {Renderer} renderer
	     * @param {Vector2} [dimensions]
	     * @return {Vector2}
	     */
	  }, {
	    key: 'getNewDimensions',
	    value: function getNewDimensions(renderer, dimensions) {
	      var canvas = renderer.getCanvas();
	      dimensions = dimensions || new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var newDimensions = this._options.end.clone().subtract(this._options.start);
	
	      if (this._options.numberFormat === 'relative') {
	        newDimensions.multiply(dimensions);
	      }
	
	      return newDimensions;
	    }
	  }]);
	
	  return CropOperation;
	})(_operation2['default']);
	
	CropOperation.prototype.identifier = 'crop';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	CropOperation.prototype.availableOptions = {
	  start: { type: 'vector2', required: true, 'default': new _libMathVector22['default'](0, 0) },
	  end: { type: 'vector2', required: true, 'default': new _libMathVector22['default'](1, 1) }
	};
	
	exports['default'] = CropOperation;
	module.exports = exports['default'];

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _filtersPrimitivesStack = __webpack_require__(32);
	
	var _filtersPrimitivesStack2 = _interopRequireDefault(_filtersPrimitivesStack);
	
	var _filtersPrimitivesSaturation = __webpack_require__(33);
	
	var _filtersPrimitivesSaturation2 = _interopRequireDefault(_filtersPrimitivesSaturation);
	
	/**
	 * @class
	 * @alias ImglyKit.Operations.SaturationOperation
	 * @extends ImglyKit.Operation
	 */
	
	var SaturationOperation = (function (_Operation) {
	  _inherits(SaturationOperation, _Operation);
	
	  function SaturationOperation() {
	    _classCallCheck(this, SaturationOperation);
	
	    _get(Object.getPrototypeOf(SaturationOperation.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  _createClass(SaturationOperation, [{
	    key: '_renderWebGL',
	
	    /**
	     * Renders the saturation using WebGL
	     * @param  {WebGLRenderer} renderer
	     * @override
	     */
	    /* istanbul ignore next */
	    value: function _renderWebGL(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the saturation using Canvas2D
	     * @param {CanvasRenderer} renderer
	     * @override
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the saturation (all renderers supported)
	     * @param  {Renderer} renderer
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render(renderer) {
	      if (!this._stack) {
	        this._stack = new _filtersPrimitivesStack2['default']();
	        this._primitive = new _filtersPrimitivesSaturation2['default']({
	          saturation: this._options.saturation
	        });
	        this._stack.add(this._primitive);
	      }
	
	      // @TODO
	      // Primitives should have the same option logic as operations - which
	      // should allow us to do `this._primitive.setSaturation`
	      this._primitive.options.saturation = this._options.saturation;
	      this._stack.render(renderer);
	    }
	  }]);
	
	  return SaturationOperation;
	})(_operation2['default']);
	
	SaturationOperation.prototype.identifier = 'saturation';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	SaturationOperation.prototype.availableOptions = {
	  saturation: { type: 'number', 'default': 1.0 }
	};
	
	exports['default'] = SaturationOperation;
	module.exports = exports['default'];

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _filtersPrimitivesStack = __webpack_require__(32);
	
	var _filtersPrimitivesStack2 = _interopRequireDefault(_filtersPrimitivesStack);
	
	var _filtersPrimitivesContrast = __webpack_require__(41);
	
	var _filtersPrimitivesContrast2 = _interopRequireDefault(_filtersPrimitivesContrast);
	
	/**
	 * @class
	 * @alias ImglyKit.Operations.ContrastOperation
	 * @extends ImglyKit.Operation
	 */
	
	var ContrastOperation = (function (_Operation) {
	  _inherits(ContrastOperation, _Operation);
	
	  function ContrastOperation() {
	    _classCallCheck(this, ContrastOperation);
	
	    _get(Object.getPrototypeOf(ContrastOperation.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  _createClass(ContrastOperation, [{
	    key: '_renderWebGL',
	
	    /**
	     * Renders the contrast using WebGL
	     * @param  {WebGLRenderer} renderer
	     * @override
	     */
	    /* istanbul ignore next */
	    value: function _renderWebGL(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the contrast using Canvas2D
	     * @param {CanvasRenderer} renderer
	     * @override
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the contrast (all renderers supported)
	     * @param  {Renderer} renderer
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render(renderer) {
	      if (!this._stack) {
	        this._stack = new _filtersPrimitivesStack2['default']();
	        this._primitive = new _filtersPrimitivesContrast2['default']({
	          contrast: this._options.contrast
	        });
	        this._stack.add(this._primitive);
	      }
	
	      // @TODO
	      // Primitives should have the same option logic as operations - which
	      // should allow us to do `this._primitive.setContrast`
	      this._primitive.options.contrast = this._options.contrast;
	      this._stack.render(renderer);
	    }
	  }]);
	
	  return ContrastOperation;
	})(_operation2['default']);
	
	ContrastOperation.prototype.identifier = 'contrast';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	ContrastOperation.prototype.availableOptions = {
	  contrast: { type: 'number', 'default': 1.0 }
	};
	
	exports['default'] = ContrastOperation;
	module.exports = exports['default'];

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _filtersPrimitivesStack = __webpack_require__(32);
	
	var _filtersPrimitivesStack2 = _interopRequireDefault(_filtersPrimitivesStack);
	
	var _filtersPrimitivesBrightness = __webpack_require__(44);
	
	var _filtersPrimitivesBrightness2 = _interopRequireDefault(_filtersPrimitivesBrightness);
	
	/**
	 * @class
	 * @alias ImglyKit.Operations.BrightnessOperation
	 * @extends ImglyKit.Operation
	 */
	
	var BrightnessOperation = (function (_Operation) {
	  _inherits(BrightnessOperation, _Operation);
	
	  function BrightnessOperation() {
	    _classCallCheck(this, BrightnessOperation);
	
	    _get(Object.getPrototypeOf(BrightnessOperation.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  _createClass(BrightnessOperation, [{
	    key: '_renderWebGL',
	
	    /**
	     * Renders the brightness using WebGL
	     * @param  {WebGLRenderer} renderer
	     * @override
	     */
	    /* istanbul ignore next */
	    value: function _renderWebGL(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the brightness using Canvas2D
	     * @param {CanvasRenderer} renderer
	     * @override
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      this._render(renderer);
	    }
	
	    /**
	     * Renders the brightness (all renderers supported)
	     * @param {Renderer} renderer
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render(renderer) {
	      if (!this._stack) {
	        this._stack = new _filtersPrimitivesStack2['default']();
	        this._primitive = new _filtersPrimitivesBrightness2['default']({
	          brightness: this._options.brightness
	        });
	        this._stack.add(this._primitive);
	      }
	
	      // @TODO
	      // Primitives should have the same option logic as operations - which
	      // should allow us to do `this._primitive.setBrightness`
	      this._primitive.options.brightness = this._options.brightness;
	      this._stack.render(renderer);
	    }
	  }]);
	
	  return BrightnessOperation;
	})(_operation2['default']);
	
	BrightnessOperation.prototype.identifier = 'brightness';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	BrightnessOperation.prototype.availableOptions = {
	  brightness: { type: 'number', 'default': 0 }
	};
	
	exports['default'] = BrightnessOperation;
	module.exports = exports['default'];

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ('value' in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _vendorStackBlur = __webpack_require__(52);
	
	var _vendorStackBlur2 = _interopRequireDefault(_vendorStackBlur);
	
	/**
	 * An operation that can crop out a part of the image
	 *
	 * @class
	 * @alias ImglyKit.Operations.TiltShiftOperation
	 * @extends ImglyKit.Operation
	 */
	
	var TiltShiftOperation = (function (_Operation) {
	  _inherits(TiltShiftOperation, _Operation);
	
	  function TiltShiftOperation() {
	    _classCallCheck(this, TiltShiftOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(TiltShiftOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader used for this operation
	     * @internal Based on evanw's glfx.js tilt shift shader:
	     *           https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      uniform sampler2D u_image;\n      uniform float blurRadius;\n      uniform float gradientRadius;\n      uniform vec2 start;\n      uniform vec2 end;\n      uniform vec2 delta;\n      uniform vec2 texSize;\n      varying vec2 v_texCoord;\n\n      float random(vec3 scale, float seed) {\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n      }\n\n      void main() {\n          vec4 color = vec4(0.0);\n          float total = 0.0;\n\n          float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n\n          vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));\n          float radius = smoothstep(0.0, 1.0, abs(dot(v_texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;\n          for (float t = -30.0; t <= 30.0; t++) {\n              float percent = (t + offset - 0.5) / 30.0;\n              float weight = 1.0 - abs(percent);\n              vec4 sample = texture2D(u_image, v_texCoord + delta * percent * radius / texSize);\n\n              sample.rgb *= sample.a;\n\n              color += sample * weight;\n              total += weight;\n          }\n\n          gl_FragColor = color / total;\n          gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n      }\n    ';
	
	    this._cachedBlurredCanvas = null;
	    this._lastBlurRadius = this._options.blurRadius;
	    this._lastGradientRadius = this._options.gradientRadius;
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(TiltShiftOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var canvas = renderer.getCanvas();
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var start = this._options.start.clone();
	      var end = this._options.end.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        start.multiply(canvasSize);
	        end.multiply(canvasSize);
	      }
	
	      start.y = canvasSize.y - start.y;
	      end.y = canvasSize.y - end.y;
	
	      var delta = end.clone().subtract(start);
	      var d = Math.sqrt(delta.x * delta.x + delta.y * delta.y);
	
	      var uniforms = {
	        blurRadius: { type: 'f', value: this._options.blurRadius },
	        gradientRadius: { type: 'f', value: this._options.gradientRadius },
	        start: { type: '2f', value: [start.x, start.y] },
	        end: { type: '2f', value: [end.x, end.y] },
	        delta: { type: '2f', value: [delta.x / d, delta.y / d] },
	        texSize: { type: '2f', value: [canvas.width, canvas.height] }
	      };
	
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], { uniforms: uniforms });
	
	      // Update delta for second pass
	      uniforms.delta.value = [-delta.y / d, delta.x / d];
	
	      renderer.runProgram(this._glslPrograms[renderer.id], { uniforms: uniforms });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var optionsChanged = this._options.blurRadius !== this._lastBlurRadius || this._options.gradientRadius !== this._lastGradientRadius;
	      var blurryCanvas = undefined;
	      if (optionsChanged || this._cachedBlurredCanvas === null) {
	        // Blur and cache canvas
	        blurryCanvas = this._blurCanvas(renderer);
	        this._cachedBlurredCanvas = blurryCanvas;
	        this._lastBlurRadius = this._options.blurRadius;
	        this._lastGradientRadius = this._options.gradientRadius;
	      } else {
	        // Use cached canvas
	        blurryCanvas = this._cachedBlurredCanvas;
	      }
	
	      var maskCanvas = this._createMask(renderer);
	
	      this._applyMask(canvas, blurryCanvas, maskCanvas);
	    }
	
	    /**
	     * Creates a blurred copy of the canvas
	     * @param  {CanvasRenderer} renderer
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: '_blurCanvas',
	    value: function _blurCanvas(renderer) {
	      var newCanvas = renderer.cloneCanvas();
	      var blurryContext = newCanvas.getContext('2d');
	      var blurryImageData = blurryContext.getImageData(0, 0, newCanvas.width, newCanvas.height);
	      _vendorStackBlur2['default'].stackBlurCanvasRGBA(blurryImageData, 0, 0, newCanvas.width, newCanvas.height, this._options.blurRadius);
	      blurryContext.putImageData(blurryImageData, 0, 0);
	
	      return newCanvas;
	    }
	
	    /**
	     * Creates the mask canvas
	     * @param  {CanvasRenderer} renderer
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: '_createMask',
	    value: function _createMask(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var gradientRadius = this._options.gradientRadius;
	
	      var maskCanvas = renderer.createCanvas(canvas.width, canvas.height);
	      var maskContext = maskCanvas.getContext('2d');
	
	      var start = this._options.start.clone();
	      var end = this._options.end.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        start.multiply(canvasSize);
	        end.multiply(canvasSize);
	      }
	
	      var dist = end.clone().subtract(start);
	      var middle = start.clone().add(dist.clone().divide(2));
	
	      var totalDist = Math.sqrt(Math.pow(dist.x, 2) + Math.pow(dist.y, 2));
	      var factor = dist.clone().divide(totalDist);
	
	      var gradientStart = middle.clone().add(gradientRadius * factor.y, -gradientRadius * factor.x);
	      var gradientEnd = middle.clone().add(-gradientRadius * factor.y, gradientRadius * factor.x);
	
	      // Build gradient
	      var gradient = maskContext.createLinearGradient(gradientStart.x, gradientStart.y, gradientEnd.x, gradientEnd.y);
	      gradient.addColorStop(0, '#000000');
	      gradient.addColorStop(0.5, '#FFFFFF');
	      gradient.addColorStop(1, '#000000');
	
	      // Draw gradient
	      maskContext.fillStyle = gradient;
	      maskContext.fillRect(0, 0, canvas.width, canvas.height);
	
	      return maskCanvas;
	    }
	
	    /**
	     * Applies the blur and mask to the input canvas
	     * @param  {Canvas} inputCanvas
	     * @param  {Canvas} blurryCanvas
	     * @param  {Canvas} maskCanvas
	     * @private
	     */
	  }, {
	    key: '_applyMask',
	    value: function _applyMask(inputCanvas, blurryCanvas, maskCanvas) {
	      var inputContext = inputCanvas.getContext('2d');
	      var blurryContext = blurryCanvas.getContext('2d');
	      var maskContext = maskCanvas.getContext('2d');
	
	      var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	      var pixels = inputImageData.data;
	      var blurryPixels = blurryContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	      var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	
	      for (var i = 0; i < maskPixels.length; i++) {
	        var alpha = maskPixels[i] / 255;
	        pixels[i] = alpha * pixels[i] + (1 - alpha) * blurryPixels[i];
	      }
	
	      inputContext.putImageData(inputImageData, 0, 0);
	    }
	
	    /**
	     * Sets the dirty state of this operation
	     * @param {Boolean} dirty
	     * @comment Since blur operations do seperate caching of the
	     *          blurred canvas, we need to invalidate the cache when the
	     *          dirty state changes.
	     */
	  }, {
	    key: 'dirty',
	    set: function set(dirty) {
	      _set(Object.getPrototypeOf(TiltShiftOperation.prototype), 'dirty', dirty, this);
	      this._cachedBlurredCanvas = null;
	    },
	
	    /**
	     * Returns the dirty state
	     * @type {Boolean}
	     */
	    get: function get() {
	      return _get(Object.getPrototypeOf(TiltShiftOperation.prototype), 'dirty', this);
	    }
	  }]);
	
	  return TiltShiftOperation;
	})(_operation2['default']);
	
	TiltShiftOperation.prototype.identifier = 'tilt-shift';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	TiltShiftOperation.prototype.availableOptions = {
	  start: { type: 'vector2', 'default': new _libMathVector22['default'](0.0, 0.5) },
	  end: { type: 'vector2', 'default': new _libMathVector22['default'](1.0, 0.5) },
	  blurRadius: { type: 'number', 'default': 30 },
	  gradientRadius: { type: 'number', 'default': 50 }
	};
	
	exports['default'] = TiltShiftOperation;
	module.exports = exports['default'];

/***/ },
/* 52 */
/***/ function(module, exports) {

	"use strict";
	/*!
	
	StackBlur - a fast almost Gaussian Blur For Canvas
	
	Version:  0.5
	Author:   Mario Klingemann
	Contact:  mario@quasimondo.com
	Website:  http://www.quasimondo.com/StackBlurForCanvas
	Twitter:  @quasimondo
	
	In case you find this class useful - especially in commercial projects -
	I am not totally unhappy for a small donation to my PayPal account
	mario@quasimondo.de
	
	Or support me on flattr:
	https://flattr.com/thing/72791/StackBlur-a-fast-almost-Gaussian-Blur-Effect-for-CanvasJavascript
	
	Copyright (c) 2010 Mario Klingemann
	
	Permission is hereby granted, free of charge, to any person
	obtaining a copy of this software and associated documentation
	files (the "Software"), to deal in the Software without
	restriction, including without limitation the rights to use,
	copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the
	Software is furnished to do so, subject to the following
	conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
	OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
	HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
	WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	OTHER DEALINGS IN THE SOFTWARE.
	*/
	
	var mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
	
	var shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
	
	function stackBlurCanvasRGBA(imageData, top_x, top_y, width, height, radius) {
	  if (isNaN(radius) || radius < 1) return;
	  radius |= 0;
	
	  var pixels = imageData.data;
	
	  var x, y, i, p, yp, yi, yw, r_sum, g_sum, b_sum, a_sum, r_out_sum, g_out_sum, b_out_sum, a_out_sum, r_in_sum, g_in_sum, b_in_sum, a_in_sum, pr, pg, pb, pa, rbs;
	
	  var div = radius + radius + 1;
	  var widthMinus1 = width - 1;
	  var heightMinus1 = height - 1;
	  var radiusPlus1 = radius + 1;
	  var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
	
	  var stackStart = new BlurStack();
	  var stackEnd;
	  var stack = stackStart;
	  for (i = 1; i < div; i++) {
	    stack = stack.next = new BlurStack();
	    if (i == radiusPlus1) stackEnd = stack;
	  }
	  stack.next = stackStart;
	  var stackIn = null;
	  var stackOut = null;
	
	  yw = yi = 0;
	
	  var mul_sum = mul_table[radius];
	  var shg_sum = shg_table[radius];
	
	  for (y = 0; y < height; y++) {
	    r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
	
	    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	
	    r_sum += sumFactor * pr;
	    g_sum += sumFactor * pg;
	    b_sum += sumFactor * pb;
	    a_sum += sumFactor * pa;
	
	    stack = stackStart;
	
	    for (i = 0; i < radiusPlus1; i++) {
	      stack.r = pr;
	      stack.g = pg;
	      stack.b = pb;
	      stack.a = pa;
	      stack = stack.next;
	    }
	
	    for (i = 1; i < radiusPlus1; i++) {
	      p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
	      r_sum += (stack.r = pr = pixels[p]) * (rbs = radiusPlus1 - i);
	      g_sum += (stack.g = pg = pixels[p + 1]) * rbs;
	      b_sum += (stack.b = pb = pixels[p + 2]) * rbs;
	      a_sum += (stack.a = pa = pixels[p + 3]) * rbs;
	
	      r_in_sum += pr;
	      g_in_sum += pg;
	      b_in_sum += pb;
	      a_in_sum += pa;
	
	      stack = stack.next;
	    }
	
	    stackIn = stackStart;
	    stackOut = stackEnd;
	    for (x = 0; x < width; x++) {
	      pixels[yi + 3] = pa = a_sum * mul_sum >> shg_sum;
	      if (pa !== 0) {
	        pa = 255 / pa;
	        pixels[yi] = (r_sum * mul_sum >> shg_sum) * pa;
	        pixels[yi + 1] = (g_sum * mul_sum >> shg_sum) * pa;
	        pixels[yi + 2] = (b_sum * mul_sum >> shg_sum) * pa;
	      } else {
	        pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
	      }
	
	      r_sum -= r_out_sum;
	      g_sum -= g_out_sum;
	      b_sum -= b_out_sum;
	      a_sum -= a_out_sum;
	
	      r_out_sum -= stackIn.r;
	      g_out_sum -= stackIn.g;
	      b_out_sum -= stackIn.b;
	      a_out_sum -= stackIn.a;
	
	      p = yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1) << 2;
	
	      r_in_sum += stackIn.r = pixels[p];
	      g_in_sum += stackIn.g = pixels[p + 1];
	      b_in_sum += stackIn.b = pixels[p + 2];
	      a_in_sum += stackIn.a = pixels[p + 3];
	
	      r_sum += r_in_sum;
	      g_sum += g_in_sum;
	      b_sum += b_in_sum;
	      a_sum += a_in_sum;
	
	      stackIn = stackIn.next;
	
	      r_out_sum += pr = stackOut.r;
	      g_out_sum += pg = stackOut.g;
	      b_out_sum += pb = stackOut.b;
	      a_out_sum += pa = stackOut.a;
	
	      r_in_sum -= pr;
	      g_in_sum -= pg;
	      b_in_sum -= pb;
	      a_in_sum -= pa;
	
	      stackOut = stackOut.next;
	
	      yi += 4;
	    }
	    yw += width;
	  }
	
	  for (x = 0; x < width; x++) {
	    g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
	
	    yi = x << 2;
	    r_out_sum = radiusPlus1 * (pr = pixels[yi]);
	    g_out_sum = radiusPlus1 * (pg = pixels[yi + 1]);
	    b_out_sum = radiusPlus1 * (pb = pixels[yi + 2]);
	    a_out_sum = radiusPlus1 * (pa = pixels[yi + 3]);
	
	    r_sum += sumFactor * pr;
	    g_sum += sumFactor * pg;
	    b_sum += sumFactor * pb;
	    a_sum += sumFactor * pa;
	
	    stack = stackStart;
	
	    for (i = 0; i < radiusPlus1; i++) {
	      stack.r = pr;
	      stack.g = pg;
	      stack.b = pb;
	      stack.a = pa;
	      stack = stack.next;
	    }
	
	    yp = width;
	
	    for (i = 1; i <= radius; i++) {
	      yi = yp + x << 2;
	
	      r_sum += (stack.r = pr = pixels[yi]) * (rbs = radiusPlus1 - i);
	      g_sum += (stack.g = pg = pixels[yi + 1]) * rbs;
	      b_sum += (stack.b = pb = pixels[yi + 2]) * rbs;
	      a_sum += (stack.a = pa = pixels[yi + 3]) * rbs;
	
	      r_in_sum += pr;
	      g_in_sum += pg;
	      b_in_sum += pb;
	      a_in_sum += pa;
	
	      stack = stack.next;
	
	      if (i < heightMinus1) {
	        yp += width;
	      }
	    }
	
	    yi = x;
	    stackIn = stackStart;
	    stackOut = stackEnd;
	    for (y = 0; y < height; y++) {
	      p = yi << 2;
	      pixels[p + 3] = pa = a_sum * mul_sum >> shg_sum;
	      if (pa > 0) {
	        pa = 255 / pa;
	        pixels[p] = (r_sum * mul_sum >> shg_sum) * pa;
	        pixels[p + 1] = (g_sum * mul_sum >> shg_sum) * pa;
	        pixels[p + 2] = (b_sum * mul_sum >> shg_sum) * pa;
	      } else {
	        pixels[p] = pixels[p + 1] = pixels[p + 2] = 0;
	      }
	
	      r_sum -= r_out_sum;
	      g_sum -= g_out_sum;
	      b_sum -= b_out_sum;
	      a_sum -= a_out_sum;
	
	      r_out_sum -= stackIn.r;
	      g_out_sum -= stackIn.g;
	      b_out_sum -= stackIn.b;
	      a_out_sum -= stackIn.a;
	
	      p = x + ((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * width << 2;
	
	      r_sum += r_in_sum += stackIn.r = pixels[p];
	      g_sum += g_in_sum += stackIn.g = pixels[p + 1];
	      b_sum += b_in_sum += stackIn.b = pixels[p + 2];
	      a_sum += a_in_sum += stackIn.a = pixels[p + 3];
	
	      stackIn = stackIn.next;
	
	      r_out_sum += pr = stackOut.r;
	      g_out_sum += pg = stackOut.g;
	      b_out_sum += pb = stackOut.b;
	      a_out_sum += pa = stackOut.a;
	
	      r_in_sum -= pr;
	      g_in_sum -= pg;
	      b_in_sum -= pb;
	      a_in_sum -= pa;
	
	      stackOut = stackOut.next;
	
	      yi += width;
	    }
	  }
	}
	
	function BlurStack() {
	  this.r = 0;
	  this.g = 0;
	  this.b = 0;
	  this.a = 0;
	  this.next = null;
	}
	
	module.exports = {
	  stackBlurCanvasRGBA: stackBlurCanvasRGBA
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _set = function set(object, property, value, receiver) { var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent !== null) { set(parent, property, value, receiver); } } else if ('value' in desc && desc.writable) { desc.value = value; } else { var setter = desc.set; if (setter !== undefined) { setter.call(receiver, value); } } return value; };
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _vendorStackBlur = __webpack_require__(52);
	
	var _vendorStackBlur2 = _interopRequireDefault(_vendorStackBlur);
	
	/**
	 * An operation that can crop out a part of the image
	 *
	 * @class
	 * @alias ImglyKit.Operations.RadialBlurOperation
	 * @extends ImglyKit.Operation
	 */
	
	var RadialBlurOperation = (function (_Operation) {
	  _inherits(RadialBlurOperation, _Operation);
	
	  function RadialBlurOperation() {
	    _classCallCheck(this, RadialBlurOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(RadialBlurOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The fragment shader used for this operation
	     * @internal Based on evanw's glfx.js tilt shift shader:
	     *           https://github.com/evanw/glfx.js/blob/master/src/filters/blur/tiltshift.js
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      uniform sampler2D u_image;\n      uniform float blurRadius;\n      uniform float gradientRadius;\n      uniform vec2 position;\n      uniform vec2 delta;\n      uniform vec2 texSize;\n      varying vec2 v_texCoord;\n\n      float random(vec3 scale, float seed) {\n        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n      }\n\n      void main() {\n          vec4 color = vec4(0.0);\n          float total = 0.0;\n\n          float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n          float radius = smoothstep(0.0, 1.0, abs(distance(v_texCoord * texSize, position)) / (gradientRadius * 2.0)) * blurRadius;\n          for (float t = -30.0; t <= 30.0; t++) {\n              float percent = (t + offset - 0.5) / 30.0;\n              float weight = 1.0 - abs(percent);\n              vec4 sample = texture2D(u_image, v_texCoord + delta * percent * radius / texSize);\n\n              sample.rgb *= sample.a;\n\n              color += sample * weight;\n              total += weight;\n          }\n\n          gl_FragColor = color / total;\n          gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n      }\n    ';
	
	    this._cachedBlurredCanvas = null;
	    this._lastBlurRadius = this._options.blurRadius;
	    this._lastGradientRadius = this._options.gradientRadius;
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(RadialBlurOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var canvas = renderer.getCanvas();
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var position = this._options.position.clone();
	      position.y = 1 - position.y;
	
	      if (this._options.numberFormat === 'relative') {
	        position.multiply(canvasSize);
	      }
	
	      var uniforms = {
	        blurRadius: { type: 'f', value: this._options.blurRadius },
	        gradientRadius: { type: 'f', value: this._options.gradientRadius },
	        position: { type: '2f', value: [position.x, position.y] },
	        texSize: { type: '2f', value: [canvas.width, canvas.height] },
	        delta: { type: '2f', value: [1, 1] }
	      };
	
	      // Setup program
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], { uniforms: uniforms });
	
	      // Update delta for second pass
	      uniforms.delta.value = [-1, 1];
	
	      renderer.runProgram(this._glslPrograms[renderer.id], { uniforms: uniforms });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var blurRadiusChanged = this._options.blurRadius !== this._lastBlurRadius;
	      var blurryCanvas = undefined;
	      if (blurRadiusChanged || this._cachedBlurredCanvas === null) {
	        // Blur and cache canvas
	        blurryCanvas = this._blurCanvas(renderer);
	        this._cachedBlurredCanvas = blurryCanvas;
	        this._lastBlurRadius = this._options.blurRadius;
	        this._lastGradientRadius = this._options.gradientRadius;
	      } else {
	        // Use cached canvas
	        blurryCanvas = this._cachedBlurredCanvas;
	      }
	
	      var maskCanvas = this._createMask(renderer);
	
	      this._applyMask(canvas, blurryCanvas, maskCanvas);
	    }
	
	    /**
	     * Creates a blurred copy of the canvas
	     * @param  {CanvasRenderer} renderer
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: '_blurCanvas',
	    value: function _blurCanvas(renderer) {
	      var newCanvas = renderer.cloneCanvas();
	      var blurryContext = newCanvas.getContext('2d');
	      var blurryImageData = blurryContext.getImageData(0, 0, newCanvas.width, newCanvas.height);
	      _vendorStackBlur2['default'].stackBlurCanvasRGBA(blurryImageData, 0, 0, newCanvas.width, newCanvas.height, this._options.blurRadius);
	      blurryContext.putImageData(blurryImageData, 0, 0);
	
	      return newCanvas;
	    }
	
	    /**
	     * Creates the mask canvas
	     * @param  {CanvasRenderer} renderer
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: '_createMask',
	    value: function _createMask(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var gradientRadius = this._options.gradientRadius;
	
	      var maskCanvas = renderer.createCanvas(canvas.width, canvas.height);
	      var maskContext = maskCanvas.getContext('2d');
	
	      var position = this._options.position.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        position.multiply(canvasSize);
	      }
	
	      // Build gradient
	      var gradient = maskContext.createRadialGradient(position.x, position.y, 0, position.x, position.y, gradientRadius);
	      gradient.addColorStop(0, '#FFFFFF');
	      gradient.addColorStop(1, '#000000');
	
	      // Draw gradient
	      maskContext.fillStyle = gradient;
	      maskContext.fillRect(0, 0, canvas.width, canvas.height);
	
	      return maskCanvas;
	    }
	
	    /**
	     * Applies the blur and mask to the input canvas
	     * @param  {Canvas} inputCanvas
	     * @param  {Canvas} blurryCanvas
	     * @param  {Canvas} maskCanvas
	     * @private
	     */
	  }, {
	    key: '_applyMask',
	    value: function _applyMask(inputCanvas, blurryCanvas, maskCanvas) {
	      var inputContext = inputCanvas.getContext('2d');
	      var blurryContext = blurryCanvas.getContext('2d');
	      var maskContext = maskCanvas.getContext('2d');
	
	      var inputImageData = inputContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height);
	      var pixels = inputImageData.data;
	      var blurryPixels = blurryContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	      var maskPixels = maskContext.getImageData(0, 0, inputCanvas.width, inputCanvas.height).data;
	
	      var index, alpha;
	      for (var y = 0; y < inputCanvas.height; y++) {
	        for (var x = 0; x < inputCanvas.width; x++) {
	          index = (y * inputCanvas.width + x) * 4;
	          alpha = maskPixels[index] / 255;
	
	          pixels[index] = alpha * pixels[index] + (1 - alpha) * blurryPixels[index];
	          pixels[index + 1] = alpha * pixels[index + 1] + (1 - alpha) * blurryPixels[index + 1];
	          pixels[index + 2] = alpha * pixels[index + 2] + (1 - alpha) * blurryPixels[index + 2];
	        }
	      }
	
	      inputContext.putImageData(inputImageData, 0, 0);
	    }
	
	    /**
	     * Sets the dirty state of this operation
	     * @param {Boolean} dirty
	     * @comment Since blur operations do seperate caching of the
	     *          blurred canvas, we need to invalidate the cache when the
	     *          dirty state changes.
	     */
	  }, {
	    key: 'dirty',
	    set: function set(dirty) {
	      _set(Object.getPrototypeOf(RadialBlurOperation.prototype), 'dirty', dirty, this);
	      this._cachedBlurredCanvas = null;
	    },
	
	    /**
	     * Returns the dirty state
	     * @type {Boolean}
	     */
	    get: function get() {
	      return _get(Object.getPrototypeOf(RadialBlurOperation.prototype), 'dirty', this);
	    }
	  }]);
	
	  return RadialBlurOperation;
	})(_operation2['default']);
	
	RadialBlurOperation.prototype.identifier = 'radial-blur';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	RadialBlurOperation.prototype.availableOptions = {
	  position: { type: 'vector2', 'default': new _libMathVector22['default'](0.5, 0.5) },
	  gradientRadius: { type: 'number', 'default': 50 },
	  blurRadius: { type: 'number', 'default': 20 }
	};
	
	exports['default'] = RadialBlurOperation;
	module.exports = exports['default'];

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	/**
	 * An operation that can draw text on the canvas
	 *
	 * @class
	 * @alias ImglyKit.Operations.TextOperation
	 * @extends ImglyKit.Operation
	 */
	
	var TextOperation = (function (_Operation) {
	  _inherits(TextOperation, _Operation);
	
	  function TextOperation() {
	    _classCallCheck(this, TextOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(TextOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The texture index used for the text
	     * @type {Number}
	     * @private
	     */
	    this._textureIndex = 1;
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textImage;\n      uniform vec2 u_position;\n      uniform vec2 u_size;\n\n      void main() {\n        vec4 color0 = texture2D(u_image, v_texCoord);\n        vec2 relative = (v_texCoord - u_position) / u_size;\n\n        if (relative.x >= 0.0 && relative.x <= 1.0 &&\n          relative.y >= 0.0 && relative.y <= 1.0) {\n\n            vec4 color1 = texture2D(u_textImage, relative);\n\n            // GL_SOURCE_ALPHA, GL_ONE_MINUS_SOURCE_ALPHA\n            gl_FragColor = color1 + color0 * (1.0 - color1.a);\n\n        } else {\n\n          gl_FragColor = color0;\n\n        }\n      }\n    ';
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   */
	  /* istanbul ignore next */
	
	  _createClass(TextOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var textCanvas = this._renderTextCanvas(renderer);
	
	      var canvas = renderer.getCanvas();
	      var gl = renderer.getContext();
	
	      var position = this._options.position.clone();
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var size = new _libMathVector22['default'](textCanvas.width, textCanvas.height).divide(canvasSize);
	
	      if (this._options.numberFormat === 'absolute') {
	        position.divide(canvasSize);
	      }
	
	      position.y = 1 - position.y; // Invert y
	      position.y -= size.y; // Fix y
	
	      // Adjust vertical alignment
	      if (this._options.verticalAlignment === 'center') {
	        position.y += size.y / 2;
	      } else if (this._options.verticalAlignment === 'bottom') {
	        position.y += size.y;
	      }
	
	      // Adjust horizontal alignment
	      if (this._options.alignment === 'center') {
	        position.x -= size.x / 2;
	      } else if (this._options.alignment === 'right') {
	        position.x -= size.x;
	      }
	
	      // Upload the texture
	      gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
	      this._texture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	
	      // Set premultiplied alpha
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textCanvas);
	      gl.activeTexture(gl.TEXTURE0);
	
	      // Execute the shader
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_textImage: { type: 'i', value: this._textureIndex },
	          u_position: { type: '2f', value: [position.x, position.y] },
	          u_size: { type: '2f', value: [size.x, size.y] }
	        }
	      });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var textCanvas = this._renderTextCanvas(renderer);
	
	      var canvas = renderer.getCanvas();
	      var context = renderer.getContext();
	
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var scaledPosition = this._options.position.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        scaledPosition.multiply(canvasSize);
	      }
	
	      // Adjust vertical alignment
	      if (this._options.verticalAlignment === 'center') {
	        scaledPosition.y -= textCanvas.height / 2;
	      } else if (this._options.verticalAlignment === 'bottom') {
	        scaledPosition.y -= textCanvas.height;
	      }
	
	      // Adjust horizontal alignment
	      if (this._options.alignment === 'center') {
	        scaledPosition.x -= textCanvas.width / 2;
	      } else if (this._options.alignment === 'right') {
	        scaledPosition.x -= textCanvas.width;
	      }
	
	      context.drawImage(textCanvas, scaledPosition.x, scaledPosition.y);
	    }
	
	    /**
	     * Renders the text canvas that will be used as a texture in WebGL
	     * and as an image in canvas
	     * @return {Canvas}
	     * @private
	     */
	  }, {
	    key: '_renderTextCanvas',
	    value: function _renderTextCanvas(renderer) {
	      var line = undefined,
	          lineNum = undefined;
	      var canvas = renderer.createCanvas();
	      var context = canvas.getContext('2d');
	
	      var outputCanvas = renderer.getCanvas();
	      var canvasSize = new _libMathVector22['default'](outputCanvas.width, outputCanvas.height);
	
	      var maxWidth = this._options.maxWidth;
	      var actualFontSize = this._options.fontSize * canvasSize.y;
	      var actualLineHeight = this._options.lineHeight * actualFontSize;
	
	      if (this._options.numberFormat === 'relative') {
	        maxWidth *= renderer.getCanvas().width;
	      }
	
	      // Apply text options
	      this._applyTextOptions(renderer, context);
	
	      var boundingBox = new _libMathVector22['default']();
	
	      var lines = this._options.text.split('\n');
	      if (typeof maxWidth !== 'undefined') {
	        // Calculate the bounding box
	        boundingBox.x = maxWidth;
	        lines = this._buildOutputLines(context, maxWidth);
	      } else {
	        for (lineNum = 0; lineNum < lines.length; lineNum++) {
	          line = lines[lineNum];
	          boundingBox.x = Math.max(boundingBox.x, context.measureText(line).width);
	        }
	      }
	
	      // Calculate boundingbox height
	      boundingBox.y = actualLineHeight * lines.length;
	
	      // Resize the canvas
	      canvas.width = boundingBox.x;
	      canvas.height = boundingBox.y;
	
	      // Get the context again
	      context = canvas.getContext('2d');
	
	      // Render background color
	      context.fillStyle = this._options.backgroundColor.toRGBA();
	      context.fillRect(0, 0, canvas.width, canvas.height);
	
	      // Apply text options
	      this._applyTextOptions(renderer, context);
	
	      // Draw lines
	      for (lineNum = 0; lineNum < lines.length; lineNum++) {
	        line = lines[lineNum];
	        this._drawText(context, line, actualLineHeight * lineNum);
	      }
	
	      return canvas;
	    }
	
	    /**
	     * Applies the text options on the given context
	     * @param  {Renderer} renderer
	     * @param  {RenderingContext2D} context
	     * @private
	     */
	  }, {
	    key: '_applyTextOptions',
	    value: function _applyTextOptions(renderer, context) {
	      var canvas = renderer.getCanvas();
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var actualFontSize = this._options.fontSize * canvasSize.y;
	
	      context.font = this._options.fontWeight + ' ' + actualFontSize + 'px ' + this._options.fontFamily;
	      context.textBaseline = 'top';
	      context.textAlign = this._options.alignment;
	      context.fillStyle = this._options.color.toRGBA();
	    }
	
	    /**
	     * Iterate over all lines and split them into multiple lines, depending
	     * on the width they need
	     * @param {RenderingContext2d} context
	     * @param {Number} maxWidth
	     * @return {Array.<string>}
	     * @private
	     */
	  }, {
	    key: '_buildOutputLines',
	    value: function _buildOutputLines(context, maxWidth) {
	      var inputLines = this._options.text.split('\n');
	      var outputLines = [];
	      var currentChars = [];
	
	      for (var lineNum = 0; lineNum < inputLines.length; lineNum++) {
	        var inputLine = inputLines[lineNum];
	        var lineChars = inputLine.split('');
	
	        if (lineChars.length === 0) {
	          outputLines.push('');
	        }
	
	        for (var charNum = 0; charNum < lineChars.length; charNum++) {
	          var currentChar = lineChars[charNum];
	          currentChars.push(currentChar);
	          var currentLine = currentChars.join('');
	          var lineWidth = context.measureText(currentLine).width;
	
	          if (lineWidth > maxWidth && currentChars.length === 1) {
	            outputLines.push(currentChars[0]);
	            currentChars = [];
	          } else if (lineWidth > maxWidth) {
	            // Remove the last word
	            var lastWord = currentChars.pop();
	
	            // Add the line, clear the words
	            outputLines.push(currentChars.join(''));
	            currentChars = [];
	
	            // Make sure to use the last word for the next line
	            currentChars = [lastWord];
	          } else if (charNum === lineChars.length - 1) {
	            // Add the line, clear the words
	            outputLines.push(currentChars.join(''));
	            currentChars = [];
	          }
	        }
	
	        // Line ended, but there's words left
	        if (currentChars.length) {
	          outputLines.push(currentChars.join(''));
	          currentChars = [];
	        }
	      }
	
	      return outputLines;
	    }
	
	    /**
	     * Draws the given line onto the given context at the given Y position
	     * @param  {RenderingContext2D} context
	     * @param  {String} text
	     * @param  {Number} y
	     * @private
	     */
	  }, {
	    key: '_drawText',
	    value: function _drawText(context, text, y) {
	      var canvas = context.canvas;
	      if (this._options.alignment === 'center') {
	        context.fillText(text, canvas.width / 2, y);
	      } else if (this._options.alignment === 'left') {
	        context.fillText(text, 0, y);
	      } else if (this._options.alignment === 'right') {
	        context.fillText(text, canvas.width, y);
	      }
	    }
	  }]);
	
	  return TextOperation;
	})(_operation2['default']);
	
	TextOperation.prototype.identifier = 'text';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	TextOperation.prototype.availableOptions = {
	  fontSize: { type: 'number', 'default': 0.1 },
	  lineHeight: { type: 'number', 'default': 1.1 },
	  fontFamily: { type: 'string', 'default': 'Times New Roman' },
	  fontWeight: { type: 'string', 'default': 'normal' },
	  alignment: { type: 'string', 'default': 'left', available: ['left', 'center', 'right'] },
	  verticalAlignment: { type: 'string', 'default': 'top', available: ['top', 'center', 'bottom'] },
	  color: { type: 'color', 'default': new _libColor2['default'](1, 1, 1, 1) },
	  backgroundColor: { type: 'color', 'default': new _libColor2['default'](0, 0, 0, 0) },
	  position: { type: 'vector2', 'default': new _libMathVector22['default'](0, 0) },
	  text: { type: 'string', required: true },
	  maxWidth: { type: 'number', 'default': 1.0 }
	};
	
	exports['default'] = TextOperation;
	module.exports = exports['default'];

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* global Image */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	/**
	 * An operation that can draw text on the canvas
	 *
	 * @class
	 * @alias ImglyKit.Operations.StickersOperation
	 * @extends ImglyKit.Operation
	 */
	
	var StickersOperation = (function (_Operation) {
	  _inherits(StickersOperation, _Operation);
	
	  function StickersOperation() {
	    _classCallCheck(this, StickersOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(StickersOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The texture index used for the sticker
	     * @type {Number}
	     * @private
	     */
	    this._textureIndex = 1;
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_stickerImage;\n      uniform vec2 u_position;\n      uniform vec2 u_size;\n\n      void main() {\n        vec4 color0 = texture2D(u_image, v_texCoord);\n        vec2 relative = (v_texCoord - u_position) / u_size;\n\n        if (relative.x >= 0.0 && relative.x <= 1.0 &&\n          relative.y >= 0.0 && relative.y <= 1.0) {\n\n            vec4 color1 = texture2D(u_stickerImage, relative);\n\n            // GL_SOURCE_ALPHA, GL_ONE_MINUS_SOURCE_ALPHA\n            gl_FragColor = color1 + color0 * (1.0 - color1.a);\n\n        } else {\n\n          gl_FragColor = color0;\n\n        }\n      }\n    ';
	
	    this._loadedStickers = {};
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Applies this operation
	   * @param  {Renderer} renderer
	   * @return {Promise}
	   * @abstract
	   */
	
	  _createClass(StickersOperation, [{
	    key: 'render',
	    value: function render(renderer) {
	      var self = this;
	      return this._loadSticker().then(function (image) {
	        if (renderer.identifier === 'webgl') {
	          /* istanbul ignore next */
	          return self._renderWebGL(renderer, image);
	        } else {
	          return self._renderCanvas(renderer, image);
	        }
	      });
	    }
	
	    /**
	     * Crops this image using WebGL
	     * @param  {WebGLRenderer} renderer
	     * @param  {Image} image
	     * @private
	     */
	    /* istanbul ignore next */
	  }, {
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer, image) {
	      var canvas = renderer.getCanvas();
	      var gl = renderer.getContext();
	
	      var position = this._options.position.clone();
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      if (this._options.numberFormat === 'absolute') {
	        position.divide(canvasSize);
	      }
	
	      var size = new _libMathVector22['default'](image.width, image.height);
	      if (typeof this._options.size !== 'undefined') {
	        size.copy(this._options.size);
	
	        if (this._options.numberFormat === 'relative') {
	          size.multiply(canvasSize);
	        }
	
	        // Calculate image ratio, scale by width
	        var ratio = image.height / image.width;
	        size.y = size.x * ratio;
	      }
	      size.divide(canvasSize);
	
	      position.y = 1 - position.y; // Invert y
	      position.y -= size.y; // Fix y
	
	      // Upload the texture
	      gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
	      this._texture = gl.createTexture();
	
	      gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	
	      // Set premultiplied alpha
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
	      gl.activeTexture(gl.TEXTURE0);
	
	      // Execute the shader
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_stickerImage: { type: 'i', value: this._textureIndex },
	          u_position: { type: '2f', value: [position.x, position.y] },
	          u_size: { type: '2f', value: [size.x, size.y] }
	        }
	      });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     * @param  {Image} image
	     * @private
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer, image) {
	      var canvas = renderer.getCanvas();
	      var context = renderer.getContext();
	
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var scaledPosition = this._options.position.clone();
	
	      if (this._options.numberFormat === 'relative') {
	        scaledPosition.multiply(canvasSize);
	      }
	
	      var size = new _libMathVector22['default'](image.width, image.height);
	      if (typeof this._options.size !== 'undefined') {
	        size.copy(this._options.size);
	
	        if (this._options.numberFormat === 'relative') {
	          size.multiply(canvasSize);
	        }
	      }
	
	      context.drawImage(image, 0, 0, image.width, image.height, scaledPosition.x, scaledPosition.y, size.x, size.y);
	    }
	
	    /**
	     * Loads the sticker
	     * @return {Promise}
	     * @private
	     */
	  }, {
	    key: '_loadSticker',
	    value: function _loadSticker() {
	      var isBrowser = typeof window !== 'undefined';
	      if (isBrowser) {
	        return this._loadImageBrowser(this._options.sticker);
	      } else {
	        return this._loadImageNode(this._options.sticker);
	      }
	    }
	
	    /**
	     * Loads the given image using the browser's `Image` class
	     * @param  {String} fileName
	     * @return {Promise}
	     * @private
	     */
	  }, {
	    key: '_loadImageBrowser',
	    value: function _loadImageBrowser(fileName) {
	      var self = this;
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        // Return preloaded sticker if available
	        if (self._loadedStickers[fileName]) {
	          return resolve(self._loadedStickers[fileName]);
	        }
	
	        var image = new Image();
	
	        image.addEventListener('load', function () {
	          self._loadedStickers[fileName] = image;
	          resolve(image);
	        });
	        image.addEventListener('error', function () {
	          reject(new Error('Could not load sticker: ' + fileName));
	        });
	
	        image.crossOrigin = 'Anonymous';
	        image.src = self._kit.getAssetPath(fileName);
	      });
	    }
	
	    /**
	     * Loads the given image using node.js' `fs` and node-canvas `Image`
	     * @param  {String} fileName
	     * @return {Promise}
	     * @private
	     */
	  }, {
	    key: '_loadImageNode',
	    value: function _loadImageNode(fileName) {
	      var Canvas = __webpack_require__(7);
	      var fs = __webpack_require__(30);
	
	      var self = this;
	      var image = new Canvas.Image();
	      var path = self._kit.getAssetPath(fileName);
	
	      return new _vendorPromise2['default'](function (resolve, reject) {
	        fs.readFile(path, function (err, buffer) {
	          if (err) return reject(err);
	
	          image.src = buffer;
	          resolve(image);
	        });
	      });
	    }
	
	    /**
	     * The registered stickers
	     * @type {Object.<String,String>}
	     */
	  }, {
	    key: 'stickers',
	    get: function get() {
	      return this._stickers;
	    }
	  }]);
	
	  return StickersOperation;
	})(_operation2['default']);
	
	StickersOperation.prototype.identifier = 'stickers';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	StickersOperation.prototype.availableOptions = {
	  sticker: { type: 'string', required: true },
	  position: { type: 'vector2', 'default': new _libMathVector22['default'](0, 0) },
	  size: { type: 'vector2', 'default': new _libMathVector22['default'](0, 0) }
	};
	
	exports['default'] = StickersOperation;
	module.exports = exports['default'];

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	/**
	 * An operation that can frames on the canvas
	 *
	 * @class
	 * @alias ImglyKit.Operations.FramesOperation
	 * @extends ImglyKit.Operation
	 */
	
	var FramesOperation = (function (_Operation) {
	  _inherits(FramesOperation, _Operation);
	
	  function FramesOperation() {
	    _classCallCheck(this, FramesOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(FramesOperation.prototype), 'constructor', this).apply(this, args);
	
	    /**
	     * The texture index used for the frame
	     * @type {Number}
	     * @private
	     */
	    this._textureIndex = 1;
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_frameImage;\n      uniform vec4 u_color;\n      uniform vec2 u_thickness;\n\n      void main() {\n        vec4 fragColor = texture2D(u_image, v_texCoord);\n        if (v_texCoord.x < u_thickness.x || v_texCoord.x > 1.0 - u_thickness.x ||\n          v_texCoord.y < u_thickness.y || v_texCoord.y > 1.0 - u_thickness.y) {\n            fragColor = mix(fragColor, u_color, u_color.a);\n          }\n\n        gl_FragColor = fragColor;\n      }\n    ';
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   * @private
	   */
	  /* istanbul ignore next */
	
	  _createClass(FramesOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      var canvas = renderer.getCanvas();
	
	      var color = this._options.color;
	      var thickness = this._options.thickness * canvas.height;
	      var thicknessVec2 = [thickness / canvas.width, thickness / canvas.height];
	
	      var uniforms = {
	        u_color: { type: '4f', value: color.toGLColor() },
	        u_thickness: { type: '2f', value: thicknessVec2 }
	      };
	
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(null, this._fragmentShader);
	      }
	
	      renderer.runProgram(this._glslPrograms[renderer.id], { uniforms: uniforms });
	    }
	
	    /**
	     * Crops the image using Canvas2D
	     * @param  {CanvasRenderer} renderer
	     * @private
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      var canvas = renderer.getCanvas();
	      var context = renderer.getContext();
	
	      var color = this._options.color;
	      var thickness = this._options.thickness * canvas.height;
	
	      context.save();
	      context.beginPath();
	      context.lineWidth = thickness * 2;
	      context.strokeStyle = color.toRGBA();
	      context.rect(0, 0, canvas.width, canvas.height);
	      context.stroke();
	      context.restore();
	    }
	  }]);
	
	  return FramesOperation;
	})(_operation2['default']);
	
	FramesOperation.prototype.identifier = 'frames';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	FramesOperation.prototype.availableOptions = {
	  color: { type: 'color', 'default': new _libColor2['default'](0, 0, 0, 1) },
	  thickness: { type: 'number', 'default': 0.02 }
	};
	
	exports['default'] = FramesOperation;
	module.exports = exports['default'];

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _operation = __webpack_require__(22);
	
	var _operation2 = _interopRequireDefault(_operation);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	var DEFAULT_THICKNESS = 0.02;
	var DEFAULT_COLOR = new _libColor2['default'](1.0, 0.0, 0.0, 1.0);
	
	/**
	 * An operation that can draw brushes on the canvas
	 *
	 * @class
	 * @alias ImglyKit.Operations.BrushOperation
	 * @extends ImglyKit.Operation
	 */
	
	var BrushOperation = (function (_Operation) {
	  _inherits(BrushOperation, _Operation);
	
	  function BrushOperation() {
	    _classCallCheck(this, BrushOperation);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(BrushOperation.prototype), 'constructor', this).apply(this, args);
	
	    this._textureIndex = 1;
	    /**
	     * The vertex shader used for this operation
	     */
	    this._vertexShader = '\n      attribute vec2 a_position;\n      attribute vec2 a_texCoord;\n      varying vec2 v_texCoord;\n\n      void main() {\n        gl_Position = vec4(a_position, 0, 1);\n        v_texCoord = a_texCoord;\n      }\n    ';
	
	    /**
	     * The fragment shader used for this operation
	     */
	    this._fragmentShader = '\n      precision mediump float;\n      varying vec2 v_texCoord;\n      uniform sampler2D u_image;\n      uniform sampler2D u_textImage;\n      uniform vec2 u_position;\n      uniform vec2 u_size;\n\n      void main() {\n        vec4 color0 = texture2D(u_image, v_texCoord);\n        vec2 relative = (v_texCoord - u_position) / u_size;\n\n        if (relative.x >= 0.0 && relative.x <= 1.0 &&\n          relative.y >= 0.0 && relative.y <= 1.0) {\n\n            vec4 color1 = texture2D(u_textImage, relative);\n\n            // GL_SOURCE_ALPHA, GL_ONE_MINUS_SOURCE_ALPHA\n            gl_FragColor = color1 + color0 * (1.0 - color1.a);\n\n        } else {\n\n          gl_FragColor = color0;\n\n        }\n      }\n    ';
	
	    this._brushCanvas = document.createElement('canvas');
	  }
	
	  /**
	   * A unique string that identifies this operation. Can be used to select
	   * operations.
	   * @type {String}
	   */
	
	  /**
	   * Crops this image using WebGL
	   * @param  {WebGLRenderer} renderer
	   * @private
	   */
	  /* istanbul ignore next */
	
	  _createClass(BrushOperation, [{
	    key: '_renderWebGL',
	    value: function _renderWebGL(renderer) {
	      this.renderBrushCanvas(renderer.getCanvas());
	      var gl = renderer.getContext();
	      this._setupProgram(renderer);
	      this._uploadCanvasToTexture(gl, this._brushCanvas);
	
	      // use the complete area available
	      var position = new _libMathVector22['default'](0, 0);
	      var size = new _libMathVector22['default'](1, 1);
	
	      // Execute the shader
	      renderer.runShader(null, this._fragmentShader, {
	        uniforms: {
	          u_textImage: { type: 'i', value: this._textureIndex },
	          u_position: { type: '2f', value: [position.x, position.y] },
	          u_size: { type: '2f', value: [size.x, size.y] }
	        }
	      });
	    }
	
	    /**
	     * Uploads pixel-data contained in a canvas onto a texture
	     * @param  {Context} gl    gl-context (use renderer.getContext())
	     * @param  {Canvas} canvas A canvas that contains the pixel data for the texture
	     */
	  }, {
	    key: '_uploadCanvasToTexture',
	    value: function _uploadCanvasToTexture(gl, canvas) {
	      gl.activeTexture(gl.TEXTURE0 + this._textureIndex);
	      this._texture = gl.createTexture();
	      gl.bindTexture(gl.TEXTURE_2D, this._texture);
	
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	
	      // Set premultiplied alpha
	      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
	
	      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);
	      gl.activeTexture(gl.TEXTURE0);
	    }
	
	    /**
	     * This method initializes the shaders once
	     * @param  {WebGLRenderer} renderer WebGLRenderer that is used to compile the
	     * shafers
	     */
	  }, {
	    key: '_setupProgram',
	    value: function _setupProgram(renderer) {
	      if (!this._glslPrograms[renderer.id]) {
	        this._glslPrograms[renderer.id] = renderer.setupGLSLProgram(this._vertexShader, this._fragmentShader);
	      }
	    }
	
	    /**
	     * Renders the brush operation to a canvas
	     * @param  {CanvasRenderer} renderer
	     * @private
	     */
	  }, {
	    key: '_renderCanvas',
	    value: function _renderCanvas(renderer) {
	      this.renderBrushCanvas(renderer.getCanvas());
	      var context = renderer.getContext();
	      context.drawImage(this._brushCanvas, 0, 0);
	    }
	
	    /**
	     * Renders the brush canvas that will be used as a texture in WebGL
	     * and as an image in canvas
	     * @param {Canvas} canvas
	     * @private
	     */
	  }, {
	    key: 'renderBrushCanvas',
	    value: function renderBrushCanvas(outputCanvas) {
	      var canvas = arguments.length <= 1 || arguments[1] === undefined ? this._brushCanvas : arguments[1];
	
	      if (this._dirty) {
	        var context = canvas.getContext('2d');
	        context.clearRect(0, 0, canvas.width, canvas.height);
	      }
	
	      if (canvas.width !== outputCanvas.width || canvas.height !== outputCanvas.height) {
	        canvas.width = outputCanvas.width;
	        canvas.height = outputCanvas.height;
	      }
	
	      var paths = this._options.paths;
	      for (var i = 0; i < paths.length; i++) {
	        var path = paths[i];
	        path.renderToCanvas(canvas);
	      }
	    }
	
	    /**
	     * Creates and adds a new path
	     * @param {Number} thickness
	     * @param {Color} color
	     * @return {BrushOperation.Path}
	     */
	  }, {
	    key: 'createPath',
	    value: function createPath(thickness, color) {
	      var path = new BrushOperation.Path(this, thickness, color);
	      this._options.paths.push(path);
	      return path;
	    }
	
	    /**
	     * returns the longer size of the canvas
	     * @param {Canvas}
	     * @return {Number}
	     */
	  }, {
	    key: '_getLongerSideSize',
	    value: function _getLongerSideSize(canvas) {
	      return Math.max(canvas.width, canvas.height);
	    }
	
	    /**
	     * returns the last color
	     * @return {Color}
	     */
	  }, {
	    key: 'getLastColor',
	    value: function getLastColor() {
	      var lastPath = this._options.paths[this._options.paths.length - 1];
	      if (!lastPath) return DEFAULT_COLOR;
	      return lastPath.getColor();
	    }
	
	    /**
	     * returns the last thickness
	     * @return {Thickness}
	     */
	  }, {
	    key: 'getLastThickness',
	    value: function getLastThickness() {
	      var lastPath = this._options.paths[this._options.paths.length - 1];
	      if (!lastPath) return DEFAULT_THICKNESS;
	      return lastPath.getThickness();
	    }
	
	    /**
	     * Gets called when this operation has been set to dirty
	     * @private
	     */
	  }, {
	    key: '_onDirty',
	    value: function _onDirty() {
	      this._options.paths.forEach(function (path) {
	        path.setDirty();
	      });
	    }
	  }]);
	
	  return BrushOperation;
	})(_operation2['default']);
	
	BrushOperation.prototype.identifier = 'brush';
	
	/**
	 * Specifies the available options for this operation
	 * @type {Object}
	 */
	BrushOperation.prototype.availableOptions = {
	  paths: { type: 'array', 'default': [] }
	};
	
	/**
	 * Represents a path that can be drawn on a canvas
	 */
	BrushOperation.Path = (function () {
	  function Path(operation, thickness, color) {
	    _classCallCheck(this, Path);
	
	    this._thickness = thickness;
	    this._color = color;
	    this._controlPoints = [];
	  }
	
	  _createClass(Path, [{
	    key: 'renderToCanvas',
	    value: function renderToCanvas(canvas) {
	      if (this._controlPoints.length < 2) return;
	
	      var lastControlPoint = this._controlPoints[0];
	      var controlPoint = lastControlPoint;
	      for (var i = 1; i < this._controlPoints.length; i++) {
	        controlPoint = this._controlPoints[i];
	        controlPoint.renderToCanvas(canvas, lastControlPoint);
	        lastControlPoint = controlPoint;
	      }
	    }
	  }, {
	    key: 'addControlPoint',
	    value: function addControlPoint(position) {
	      var controlPoint = new BrushOperation.ControlPoint(this, position);
	      this._controlPoints.push(controlPoint);
	    }
	  }, {
	    key: 'getColor',
	    value: function getColor() {
	      return this._color;
	    }
	  }, {
	    key: 'getThickness',
	    value: function getThickness() {
	      return this._thickness;
	    }
	  }, {
	    key: 'setDirty',
	    value: function setDirty() {
	      this._controlPoints.forEach(function (point) {
	        point.setDirty();
	      });
	    }
	  }]);
	
	  return Path;
	})();
	
	/**
	 * Represents a control point of a path
	 */
	BrushOperation.ControlPoint = (function () {
	  function ControlPoint(path, position) {
	    _classCallCheck(this, ControlPoint);
	
	    this._path = path;
	    this._drawnCanvases = [];
	    this._position = position;
	  }
	
	  _createClass(ControlPoint, [{
	    key: 'renderToCanvas',
	    value: function renderToCanvas(canvas, lastControlPoint) {
	      if (this._drawnCanvases.indexOf(canvas) !== -1) {
	        // This control point has already been drawn on this canvas. Ignore.
	        return;
	      }
	
	      var context = canvas.getContext('2d');
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var longerSide = Math.max(canvasSize.x, canvasSize.y);
	
	      var position = this._position.clone().multiply(canvasSize);
	      var lastPosition = lastControlPoint.getPosition().clone().multiply(canvasSize);
	
	      context.beginPath();
	      context.lineJoin = 'round';
	      context.strokeStyle = this._path.getColor().toHex();
	      context.lineWidth = this._path.getThickness() * longerSide;
	      context.moveTo(lastPosition.x, lastPosition.y);
	      context.lineTo(position.x, position.y);
	      context.closePath();
	      context.stroke();
	      this._drawnCanvases.push(canvas);
	    }
	  }, {
	    key: 'getPosition',
	    value: function getPosition() {
	      return this._position.clone();
	    }
	  }, {
	    key: 'setDirty',
	    value: function setDirty() {
	      this._drawnCanvases = [];
	    }
	  }]);
	
	  return ControlPoint;
	})();
	
	exports['default'] = BrushOperation;
	module.exports = exports['default'];

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * A15 Filter
	 * @class
	 * @alias ImglyKit.Filters.A15Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var A15Filter = (function (_Filter) {
	  _inherits(A15Filter, _Filter);
	
	  function A15Filter() {
	    _classCallCheck(this, A15Filter);
	
	    _get(Object.getPrototypeOf(A15Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(A15Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 0.63
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Brightness({
	        brightness: 0.12
	      }));
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 38], [94, 94], [148, 142], [175, 187], [255, 255]],
	          green: [[0, 0], [77, 53], [171, 190], [255, 255]],
	          blue: [[0, 10], [48, 85], [174, 228], [255, 255]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return '15';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'a15';
	    }
	  }]);
	
	  return A15Filter;
	})(_filter2['default']);
	
	exports['default'] = A15Filter;
	module.exports = exports['default'];

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Breeze Filter
	 * @class
	 * @alias ImglyKit.Filters.BreezeFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var BreezeFilter = (function (_Filter) {
	  _inherits(BreezeFilter, _Filter);
	
	  function BreezeFilter() {
	    _classCallCheck(this, BreezeFilter);
	
	    _get(Object.getPrototypeOf(BreezeFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(BreezeFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Desaturation
	      stack.add(new _filter2['default'].Primitives.Desaturation({
	        desaturation: 0.5
	      }));
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [170, 170], [212, 219], [234, 242], [255, 255]],
	          green: [[0, 0], [170, 168], [234, 231], [255, 255]],
	          blue: [[0, 0], [170, 170], [212, 208], [255, 255]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Breeze';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'breeze';
	    }
	  }]);
	
	  return BreezeFilter;
	})(_filter2['default']);
	
	exports['default'] = BreezeFilter;
	module.exports = exports['default'];

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * BW Filter
	 * @class
	 * @alias ImglyKit.Filters.BWFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var BWFilter = (function (_Filter) {
	  _inherits(BWFilter, _Filter);
	
	  function BWFilter() {
	    _classCallCheck(this, BWFilter);
	
	    _get(Object.getPrototypeOf(BWFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(BWFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Grayscale());
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'B&W';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'bw';
	    }
	  }]);
	
	  return BWFilter;
	})(_filter2['default']);
	
	exports['default'] = BWFilter;
	module.exports = exports['default'];

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * BWHard Filter
	 * @class
	 * @alias ImglyKit.Filters.BWHardFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var BWHardFilter = (function (_Filter) {
	  _inherits(BWHardFilter, _Filter);
	
	  function BWHardFilter() {
	    _classCallCheck(this, BWHardFilter);
	
	    _get(Object.getPrototypeOf(BWHardFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(BWHardFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Grayscale());
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 1.5
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return '1920';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'bwhard';
	    }
	  }]);
	
	  return BWHardFilter;
	})(_filter2['default']);
	
	exports['default'] = BWHardFilter;
	module.exports = exports['default'];

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Celsius Filter
	 * @class
	 * @alias ImglyKit.Filters.CelsiusFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var CelsiusFilter = (function (_Filter) {
	  _inherits(CelsiusFilter, _Filter);
	
	  function CelsiusFilter() {
	    _classCallCheck(this, CelsiusFilter);
	
	    _get(Object.getPrototypeOf(CelsiusFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(CelsiusFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 69], [55, 110], [202, 230], [255, 255]],
	          green: [[0, 44], [89, 93], [185, 141], [255, 189]],
	          blue: [[0, 76], [39, 82], [218, 138], [255, 171]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Celsius';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'celsius';
	    }
	  }]);
	
	  return CelsiusFilter;
	})(_filter2['default']);
	
	exports['default'] = CelsiusFilter;
	module.exports = exports['default'];

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Chest Filter
	 * @class
	 * @alias ImglyKit.Filters.ChestFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var ChestFilter = (function (_Filter) {
	  _inherits(ChestFilter, _Filter);
	
	  function ChestFilter() {
	    _classCallCheck(this, ChestFilter);
	
	    _get(Object.getPrototypeOf(ChestFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(ChestFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [44, 44], [124, 143], [221, 204], [255, 255]],
	          green: [[0, 0], [130, 127], [213, 199], [255, 255]],
	          blue: [[0, 0], [51, 52], [219, 204], [255, 255]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Chest';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'chest';
	    }
	  }]);
	
	  return ChestFilter;
	})(_filter2['default']);
	
	exports['default'] = ChestFilter;
	module.exports = exports['default'];

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Fixie Filter
	 * @class
	 * @alias ImglyKit.Filters.FixieFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var FixieFilter = (function (_Filter) {
	  _inherits(FixieFilter, _Filter);
	
	  function FixieFilter() {
	    _classCallCheck(this, FixieFilter);
	
	    _get(Object.getPrototypeOf(FixieFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(FixieFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [44, 28], [63, 48], [128, 132], [235, 248], [255, 255]],
	          green: [[0, 0], [20, 10], [60, 45], [190, 209], [211, 231], [255, 255]],
	          blue: [[0, 31], [41, 62], [150, 142], [234, 212], [255, 224]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Fixie';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'fixie';
	    }
	  }]);
	
	  return FixieFilter;
	})(_filter2['default']);
	
	exports['default'] = FixieFilter;
	module.exports = exports['default'];

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Food Filter
	 * @class
	 * @alias ImglyKit.Filters.FoodFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var FoodFilter = (function (_Filter) {
	  _inherits(FoodFilter, _Filter);
	
	  function FoodFilter() {
	    _classCallCheck(this, FoodFilter);
	
	    _get(Object.getPrototypeOf(FoodFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(FoodFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 1.35
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 1.1
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Food';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'food';
	    }
	  }]);
	
	  return FoodFilter;
	})(_filter2['default']);
	
	exports['default'] = FoodFilter;
	module.exports = exports['default'];

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Fridge Filter
	 * @class
	 * @alias ImglyKit.Filters.FridgeFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var FridgeFilter = (function (_Filter) {
	  _inherits(FridgeFilter, _Filter);
	
	  function FridgeFilter() {
	    _classCallCheck(this, FridgeFilter);
	
	    _get(Object.getPrototypeOf(FridgeFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(FridgeFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 9], [21, 11], [45, 24], [255, 220]],
	          green: [[0, 12], [21, 21], [42, 42], [150, 150], [170, 173], [255, 210]],
	          blue: [[0, 28], [43, 72], [128, 185], [255, 220]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Fridge';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'fridge';
	    }
	  }]);
	
	  return FridgeFilter;
	})(_filter2['default']);
	
	exports['default'] = FridgeFilter;
	module.exports = exports['default'];

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Front Filter
	 * @class
	 * @alias ImglyKit.Filters.FrontFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var FrontFilter = (function (_Filter) {
	  _inherits(FrontFilter, _Filter);
	
	  function FrontFilter() {
	    _classCallCheck(this, FrontFilter);
	
	    _get(Object.getPrototypeOf(FrontFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(FrontFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 65], [28, 67], [67, 113], [125, 183], [187, 217], [255, 229]],
	          green: [[0, 52], [42, 59], [104, 134], [169, 209], [255, 240]],
	          blue: [[0, 52], [65, 68], [93, 104], [150, 153], [255, 198]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Front';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'front';
	    }
	  }]);
	
	  return FrontFilter;
	})(_filter2['default']);
	
	exports['default'] = FrontFilter;
	module.exports = exports['default'];

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Glam Filter
	 * @class
	 * @alias ImglyKit.Filters.GlamFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var GlamFilter = (function (_Filter) {
	  _inherits(GlamFilter, _Filter);
	
	  function GlamFilter() {
	    _classCallCheck(this, GlamFilter);
	
	    _get(Object.getPrototypeOf(GlamFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(GlamFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 1.1
	      }));
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [94, 74], [181, 205], [255, 255]],
	          green: [[0, 0], [127, 127], [255, 255]],
	          blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Glam';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'glam';
	    }
	  }]);
	
	  return GlamFilter;
	})(_filter2['default']);
	
	exports['default'] = GlamFilter;
	module.exports = exports['default'];

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Gobblin Filter
	 * @class
	 * @alias ImglyKit.Filters.GobblinFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var GobblinFilter = (function (_Filter) {
	  _inherits(GobblinFilter, _Filter);
	
	  function GobblinFilter() {
	    _classCallCheck(this, GobblinFilter);
	
	    _get(Object.getPrototypeOf(GobblinFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(GobblinFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.Gobblin());
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Gobblin';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'gobblin';
	    }
	  }]);
	
	  return GobblinFilter;
	})(_filter2['default']);
	
	exports['default'] = GobblinFilter;
	module.exports = exports['default'];

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * K1 Filter
	 * @class
	 * @alias ImglyKit.Filters.K1Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var K1Filter = (function (_Filter) {
	  _inherits(K1Filter, _Filter);
	
	  function K1Filter() {
	    _classCallCheck(this, K1Filter);
	
	    _get(Object.getPrototypeOf(K1Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(K1Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [53, 32], [91, 80], [176, 205], [255, 255]]
	      }));
	
	      // Saturation
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 0.9
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'K1';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'k1';
	    }
	  }]);
	
	  return K1Filter;
	})(_filter2['default']);
	
	exports['default'] = K1Filter;
	module.exports = exports['default'];

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	/**
	 * K2 Filter
	 * @class
	 * @alias ImglyKit.Filters.K2Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var K2Filter = (function (_Filter) {
	  _inherits(K2Filter, _Filter);
	
	  function K2Filter() {
	    _classCallCheck(this, K2Filter);
	
	    _get(Object.getPrototypeOf(K2Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(K2Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [54, 33], [77, 82], [94, 103], [122, 126], [177, 193], [229, 232], [255, 255]]
	      }));
	
	      // Soft color overlay
	      stack.add(new _filter2['default'].Primitives.SoftColorOverlay({
	        color: new _libColor2['default'](40 / 255, 40 / 255, 40 / 255)
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'K2';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'k2';
	    }
	  }]);
	
	  return K2Filter;
	})(_filter2['default']);
	
	exports['default'] = K2Filter;
	module.exports = exports['default'];

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * K6 Filter
	 * @class
	 * @alias ImglyKit.Filters.K6Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var K6Filter = (function (_Filter) {
	  _inherits(K6Filter, _Filter);
	
	  function K6Filter() {
	    _classCallCheck(this, K6Filter);
	
	    _get(Object.getPrototypeOf(K6Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(K6Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Saturation
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 0.5
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'K6';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'k6';
	    }
	  }]);
	
	  return K6Filter;
	})(_filter2['default']);
	
	exports['default'] = K6Filter;
	module.exports = exports['default'];

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * KDynamic Filter
	 * @class
	 * @alias ImglyKit.Filters.KDynamicFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var KDynamicFilter = (function (_Filter) {
	  _inherits(KDynamicFilter, _Filter);
	
	  function KDynamicFilter() {
	    _classCallCheck(this, KDynamicFilter);
	
	    _get(Object.getPrototypeOf(KDynamicFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(KDynamicFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [17, 27], [46, 69], [90, 112], [156, 200], [203, 243], [255, 255]]
	      }));
	
	      // Saturation
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 0.7
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'KDynamic';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'kdynamic';
	    }
	  }]);
	
	  return KDynamicFilter;
	})(_filter2['default']);
	
	exports['default'] = KDynamicFilter;
	module.exports = exports['default'];

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Lenin Filter
	 * @class
	 * @alias ImglyKit.Filters.LeninFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var LeninFilter = (function (_Filter) {
	  _inherits(LeninFilter, _Filter);
	
	  function LeninFilter() {
	    _classCallCheck(this, LeninFilter);
	
	    _get(Object.getPrototypeOf(LeninFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(LeninFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Desaturation
	      stack.add(new _filter2['default'].Primitives.Desaturation({
	        desaturation: 0.4
	      }));
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 20], [40, 20], [106, 111], [129, 153], [190, 223], [255, 255]],
	          green: [[0, 20], [40, 20], [62, 41], [106, 108], [132, 159], [203, 237], [255, 255]],
	          blue: [[0, 40], [40, 40], [73, 60], [133, 160], [191, 297], [203, 237], [237, 239], [255, 255]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Lenin';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'lenin';
	    }
	  }]);
	
	  return LeninFilter;
	})(_filter2['default']);
	
	exports['default'] = LeninFilter;
	module.exports = exports['default'];

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Lomo Filter
	 * @class
	 * @alias ImglyKit.Filters.LomoFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var LomoFilter = (function (_Filter) {
	  _inherits(LomoFilter, _Filter);
	
	  function LomoFilter() {
	    _classCallCheck(this, LomoFilter);
	
	    _get(Object.getPrototypeOf(LomoFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(LomoFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [87, 20], [131, 156], [183, 205], [255, 200]]
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Lomo';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'lomo';
	    }
	  }]);
	
	  return LomoFilter;
	})(_filter2['default']);
	
	exports['default'] = LomoFilter;
	module.exports = exports['default'];

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Mellow Filter
	 * @class
	 * @alias ImglyKit.Filters.MellowFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var MellowFilter = (function (_Filter) {
	  _inherits(MellowFilter, _Filter);
	
	  function MellowFilter() {
	    _classCallCheck(this, MellowFilter);
	
	    _get(Object.getPrototypeOf(MellowFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(MellowFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [41, 84], [87, 134], [255, 255]],
	          green: [[0, 0], [255, 216]],
	          blue: [[0, 0], [255, 131]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Mellow';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'mellow';
	    }
	  }]);
	
	  return MellowFilter;
	})(_filter2['default']);
	
	exports['default'] = MellowFilter;
	module.exports = exports['default'];

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Morning Filter
	 * @class
	 * @alias ImglyKit.Filters.MorningFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var MorningFilter = (function (_Filter) {
	  _inherits(MorningFilter, _Filter);
	
	  function MorningFilter() {
	    _classCallCheck(this, MorningFilter);
	
	    _get(Object.getPrototypeOf(MorningFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(MorningFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 40], [255, 230]],
	          green: [[0, 10], [255, 225]],
	          blue: [[0, 20], [255, 181]]
	        }
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Glow());
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Morning';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'morning';
	    }
	  }]);
	
	  return MorningFilter;
	})(_filter2['default']);
	
	exports['default'] = MorningFilter;
	module.exports = exports['default'];

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Orchid Filter
	 * @class
	 * @alias ImglyKit.Filters.OrchidFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var OrchidFilter = (function (_Filter) {
	  _inherits(OrchidFilter, _Filter);
	
	  function OrchidFilter() {
	    _classCallCheck(this, OrchidFilter);
	
	    _get(Object.getPrototypeOf(OrchidFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(OrchidFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [115, 130], [195, 215], [255, 255]],
	          green: [[0, 0], [148, 153], [172, 215], [255, 255]],
	          blue: [[0, 46], [58, 75], [178, 205], [255, 255]]
	        }
	      }));
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [117, 151], [189, 217], [255, 255]]
	      }));
	
	      // Desaturation
	      stack.add(new _filter2['default'].Primitives.Desaturation({
	        desaturation: 0.65
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Orchid';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'orchid';
	    }
	  }]);
	
	  return OrchidFilter;
	})(_filter2['default']);
	
	exports['default'] = OrchidFilter;
	module.exports = exports['default'];

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Pola Filter
	 * @class
	 * @alias ImglyKit.Filters.PolaFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var PolaFilter = (function (_Filter) {
	  _inherits(PolaFilter, _Filter);
	
	  function PolaFilter() {
	    _classCallCheck(this, PolaFilter);
	
	    _get(Object.getPrototypeOf(PolaFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(PolaFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [94, 74], [181, 205], [255, 255]],
	          green: [[0, 0], [34, 34], [99, 76], [176, 190], [255, 255]],
	          blue: [[0, 0], [102, 73], [227, 213], [255, 255]]
	        }
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 0.8
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 1.5
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Pola SX';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'pola';
	    }
	  }]);
	
	  return PolaFilter;
	})(_filter2['default']);
	
	exports['default'] = PolaFilter;
	module.exports = exports['default'];

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Pola669 Filter
	 * @class
	 * @alias ImglyKit.Filters.Pola669Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var Pola669Filter = (function (_Filter) {
	  _inherits(Pola669Filter, _Filter);
	
	  function Pola669Filter() {
	    _classCallCheck(this, Pola669Filter);
	
	    _get(Object.getPrototypeOf(Pola669Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(Pola669Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [56, 18], [196, 209], [255, 255]],
	          green: [[0, 38], [71, 84], [255, 255]],
	          blue: [[0, 0], [131, 133], [204, 211], [255, 255]]
	        }
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Saturation({
	        saturation: 0.8
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Contrast({
	        contrast: 1.5
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Pola 669';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'pola669';
	    }
	  }]);
	
	  return Pola669Filter;
	})(_filter2['default']);
	
	exports['default'] = Pola669Filter;
	module.exports = exports['default'];

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Quozi Filter
	 * @class
	 * @alias ImglyKit.Filters.QuoziFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var QuoziFilter = (function (_Filter) {
	  _inherits(QuoziFilter, _Filter);
	
	  function QuoziFilter() {
	    _classCallCheck(this, QuoziFilter);
	
	    _get(Object.getPrototypeOf(QuoziFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(QuoziFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      // Desaturation
	      stack.add(new _filter2['default'].Primitives.Desaturation({
	        desaturation: 0.65
	      }));
	
	      // Tone curve
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 50], [40, 78], [118, 170], [181, 211], [255, 255]],
	          green: [[0, 27], [28, 45], [109, 157], [157, 195], [179, 208], [206, 212], [255, 240]],
	          blue: [[0, 50], [12, 55], [46, 103], [103, 162], [194, 182], [241, 201], [255, 219]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Quozi';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'quozi';
	    }
	  }]);
	
	  return QuoziFilter;
	})(_filter2['default']);
	
	exports['default'] = QuoziFilter;
	module.exports = exports['default'];

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Semired Filter
	 * @class
	 * @alias ImglyKit.Filters.SemiredFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var SemiredFilter = (function (_Filter) {
	  _inherits(SemiredFilter, _Filter);
	
	  function SemiredFilter() {
	    _classCallCheck(this, SemiredFilter);
	
	    _get(Object.getPrototypeOf(SemiredFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(SemiredFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 129], [75, 153], [181, 227], [255, 255]],
	          green: [[0, 8], [111, 85], [212, 158], [255, 226]],
	          blue: [[0, 5], [75, 22], [193, 90], [255, 229]]
	        }
	      }));
	
	      stack.add(new _filter2['default'].Primitives.Glow());
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Semi Red';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'semired';
	    }
	  }]);
	
	  return SemiredFilter;
	})(_filter2['default']);
	
	exports['default'] = SemiredFilter;
	module.exports = exports['default'];

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Sunny Filter
	 * @class
	 * @alias ImglyKit.Filters.SunnyFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var SunnyFilter = (function (_Filter) {
	  _inherits(SunnyFilter, _Filter);
	
	  function SunnyFilter() {
	    _classCallCheck(this, SunnyFilter);
	
	    _get(Object.getPrototypeOf(SunnyFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(SunnyFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 0], [62, 82], [141, 154], [255, 255]],
	          green: [[0, 39], [56, 96], [192, 176], [255, 255]],
	          blue: [[0, 0], [174, 99], [255, 235]]
	        }
	      }));
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        controlPoints: [[0, 0], [55, 20], [158, 191], [255, 255]]
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Sunny';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'sunny';
	    }
	  }]);
	
	  return SunnyFilter;
	})(_filter2['default']);
	
	exports['default'] = SunnyFilter;
	module.exports = exports['default'];

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * Texas Filter
	 * @class
	 * @alias ImglyKit.Filters.TexasFilter
	 * @extends {ImglyKit.Filter}
	 */
	
	var TexasFilter = (function (_Filter) {
	  _inherits(TexasFilter, _Filter);
	
	  function TexasFilter() {
	    _classCallCheck(this, TexasFilter);
	
	    _get(Object.getPrototypeOf(TexasFilter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(TexasFilter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.ToneCurve({
	        rgbControlPoints: {
	          red: [[0, 72], [89, 99], [176, 212], [255, 237]],
	          green: [[0, 49], [255, 192]],
	          blue: [[0, 72], [255, 151]]
	        }
	      }));
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'Texas';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'texas';
	    }
	  }]);
	
	  return TexasFilter;
	})(_filter2['default']);
	
	exports['default'] = TexasFilter;
	module.exports = exports['default'];

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _filter = __webpack_require__(31);
	
	var _filter2 = _interopRequireDefault(_filter);
	
	/**
	 * X400 Filter
	 * @class
	 * @alias ImglyKit.Filters.X400Filter
	 * @extends {ImglyKit.Filter}
	 */
	
	var X400Filter = (function (_Filter) {
	  _inherits(X400Filter, _Filter);
	
	  function X400Filter() {
	    _classCallCheck(this, X400Filter);
	
	    _get(Object.getPrototypeOf(X400Filter.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(X400Filter, [{
	    key: 'render',
	
	    /**
	     * Renders the filter
	     * @param  {Renderer} renderer
	     * @return {Promise}
	     */
	    value: function render(renderer) {
	      var stack = new _filter2['default'].PrimitivesStack();
	
	      stack.add(new _filter2['default'].Primitives.X400());
	
	      stack.render(renderer);
	    }
	  }, {
	    key: 'name',
	
	    /**
	     * The name that is displayed in the UI
	     * @type {String}
	     */
	    get: function get() {
	      return 'X400';
	    }
	  }], [{
	    key: 'identifier',
	
	    /**
	     * A unique string that identifies this operation. Can be used to select
	     * the active filter.
	     * @type {String}
	     */
	    get: function get() {
	      return 'x400';
	    }
	  }]);
	
	  return X400Filter;
	})(_filter2['default']);
	
	exports['default'] = X400Filter;
	module.exports = exports['default'];

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	/* global FileReader, Image, __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x3, _x4, _x5) { var _again = true; _function: while (_again) { var object = _x3, property = _x4, receiver = _x5; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x3 = parent; _x4 = property; _x5 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _vendorNativePromiseOnly = __webpack_require__(9);
	
	var _vendorNativePromiseOnly2 = _interopRequireDefault(_vendorNativePromiseOnly);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _baseUi = __webpack_require__(87);
	
	var _baseUi2 = _interopRequireDefault(_baseUi);
	
	var _libCanvas = __webpack_require__(89);
	
	var _libCanvas2 = _interopRequireDefault(_libCanvas);
	
	var _libFileLoader = __webpack_require__(90);
	
	var _libFileLoader2 = _interopRequireDefault(_libFileLoader);
	
	var _libImageResizer = __webpack_require__(91);
	
	var _libImageResizer2 = _interopRequireDefault(_libImageResizer);
	
	var _libWebcamHandler = __webpack_require__(92);
	
	var _libWebcamHandler2 = _interopRequireDefault(_libWebcamHandler);
	
	var _libTopControls = __webpack_require__(93);
	
	var _libTopControls2 = _interopRequireDefault(_libTopControls);
	
	var _libScrollbar = __webpack_require__(94);
	
	var _libScrollbar2 = _interopRequireDefault(_libScrollbar);
	
	var _constants = __webpack_require__(17);
	
	var NightUI = (function (_UI) {
	  _inherits(NightUI, _UI);
	
	  function NightUI() {
	    _classCallCheck(this, NightUI);
	
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    _get(Object.getPrototypeOf(NightUI.prototype), 'constructor', this).apply(this, args);
	
	    this._operationsMap = {};
	    this._template = function(it
	/**/) {
	var out='<div class="imglykit"> <div class="imglykit-loadingOverlay"> <div class="imglykit-loadingOverlay-content"> <img src="'+( it.helpers.assetPath('ui/night/loading.gif'))+'" /> <span>'+( it.helpers.translate('generic.loading') )+'...</span> </div> </div> <div class="imglykit-flashOverlay"> <div class="imglykit-flashOverlay-close"> <img src="'+( it.helpers.assetPath('ui/night/close.png'))+'" /> </div> <div class="imglykit-flashOverlay-headline"></div> <div class="imglykit-flashOverlay-text"></div> </div> <div class="imglykit-container"> ';if(!it.options.ui.hideHeader){out+=' <div class="imglykit-header-row"> <div class="imglykit-header"> img.ly Photo Editor SDK ';if(it.options.ui.showCloseButton){out+=' <div class="imglykit-close-button"> <img src="'+(it.helpers.assetPath('ui/night/close.png'))+'" /> </div> ';}out+=' </div> </div> ';}out+=' ';if(it.renderControls){out+=' <div class="imglykit-top-controls-row"> <div class="imglykit-top-controls"> <div class="imglykit-top-controls-left"> ';if(it.options.ui.showNewButton){out+=' <div class="imglykit-new"> <img src="'+(it.helpers.assetPath('ui/night/top/new.png'))+'" /> '+( it.helpers.translate('top-controls.new') )+' </div> ';}out+=' ';if(it.options.ui.showExportButton){out+=' <div class="imglykit-export"> <img src="'+(it.helpers.assetPath('ui/night/top/export.png'))+'" /> '+( it.helpers.translate('top-controls.export') )+' </div> ';}out+=' <div class="imglykit-undo"> <img src="'+(it.helpers.assetPath('ui/night/top/undo.png'))+'" /> '+( it.helpers.translate('top-controls.undo') )+' </div> </div> <div class="imglykit-top-controls-right"> <div class="imglykit-zoom-fit"></div> <div class="imglykit-zoom-level">'+( it.helpers.translate('top-controls.zoom') )+': <span class="imglykit-zoom-level-num">100</span>%</div> <div class="imglykit-zoom-in"> <img src="'+(it.helpers.assetPath('ui/night/top/zoom-in.png'))+'" /> </div> <div class="imglykit-zoom-out"> <img src="'+(it.helpers.assetPath('ui/night/top/zoom-out.png'))+'" /> </div> </div> </div> </div> ';}out+=' <div class="imglykit-canvas-container-row"> <div class="imglykit-canvas-container"> ';if(it.renderWebcam){out+=' <div class="imglykit-canvas-inner-container"> <video class="imglykit-webcam-video" autoplay></video> </div> ';}out+=' ';if(!(it.renderSplashScreen || it.renderWebcam)){out+=' <div class="imglykit-canvas-inner-container"> <canvas class="imglykit-canvas-draggable"></canvas> <div class="imglykit-canvas-controls imglykit-canvas-controls-disabled"></div> </div> ';}out+=' ';if(it.renderSplashScreen){out+=' <div class="imglykit-splash-container"> ';if(it.options.ui.showUploadButton){out+=' <div class="imglykit-splash-row imglykit-splash-row--upload"> <div class="imglykit-splash-cell"> <input type="file" class="imglykit-upload-hidden-input" /> <img src="'+(it.helpers.assetPath('ui/night/upload.png'))+'" /> <div class="imglykit-splash-content"> <div class="imglykit-splash-button">'+( it.helpers.translate('splash.upload.headline') )+'</div> <div class="imglykit-splash-text">'+( it.helpers.translate('splash.upload.description') )+'</div> </div> </div> </div> ';}out+=' ';if(it.options.ui.showUploadButton && it.options.ui.showWebcamButton){out+=' <div class="imglykit-splash-row imglykit-splash-row--or"> <div class="imglykit-splash-or"> <div class="imglykit-splash-or-line"></div> <div class="imglykit-splash-or-word">'+( it.helpers.translate('splash.or') )+'</div> <div class="imglykit-splash-or-line"></div> </div> </div> ';}out+=' ';if(it.options.ui.showWebcamButton){out+=' <div class="imglykit-splash-row imglykit-splash-row--camera"> <div class="imglykit-splash-cell"> <img src="'+(it.helpers.assetPath('ui/night/shutter.png'))+'" /> <div class="imglykit-splash-content"> <div class="imglykit-splash-button">'+( it.helpers.translate('splash.webcam.headline') )+'</div> <div class="imglykit-splash-text">'+( it.helpers.translate('splash.webcam.description') )+'</div> </div> </div> </div> ';}out+=' </div> ';}out+=' </div> </div> ';if(it.renderWebcam){out+=' <div class="imglykit-controls-row"> <div class="imglykit-controls-container"> <div class="imglykit-controls"> <div class="imglykit-webcam-button"> <img src="'+(it.helpers.assetPath('ui/night/shutter-button.png'))+'" /> </div> </div> </div> </div> ';}out+=' ';if(it.renderControls){out+=' <div class="imglykit-controls-row"> <div class="imglykit-controls-container"> <div class="imglykit-controls"> <div> <div class="imglykit-controls-overview"> <ul class="imglykit-controls-list"> '; for (var identifier in it.controls) { out+=' '; var control = it.controls[identifier]; out+=' <li class="imglykit-controls-item--with-label" data-identifier="'+( control.identifier)+'"';if(it.controlsDisabled){out+=' data-disabled';}out+='> <img src="'+(it.helpers.assetPath('ui/night/operations/' + control.identifier + '.png') )+'" /> <div class="imglykit-controls-label">'+(it.helpers.translate('operations.' + control.identifier))+'</div> </li> '; } out+=' </ul> </div> </div> </div> </div> </div> ';}out+=' </div></div>';return out;
	};
	    this._registeredControls = {};
	    this._history = [];
	    this._imageResized = false;
	
	    // The `Night` UI has a fixed operation order
	    this._preferredOperationOrder = [
	    // First, all operations that affect the image dimensions
	    'rotation', 'crop', 'flip',
	
	    // Then color operations (first filters, then fine-tuning)
	    'filters', 'contrast', 'brightness', 'saturation',
	
	    // Then post-processing
	    'radial-blur', 'tilt-shift', 'frames', 'stickers', 'text', 'brush'];
	
	    this._paused = false;
	
	    this._options.ui = _libUtils2['default'].defaults(this._options.ui, {
	      showNewButton: !this._options.image,
	      showUploadButton: true,
	      showWebcamButton: true,
	      showHeader: true,
	      showCloseButton: false,
	      showExportButton: false,
	      language: 'en',
	      maxMegaPixels: 10,
	      'export': {}
	    });
	
	    this._options.ui['export'] = _libUtils2['default'].defaults(this._options.ui['export'], {
	      type: _constants.ImageFormat.JPEG,
	      quality: 0.8
	    });
	  }
	
	  /**
	   * A unique string that represents this UI
	   * @type {String}
	   */
	
	  _createClass(NightUI, [{
	    key: 'run',
	
	    /**
	     * Prepares the UI for use
	     */
	    value: function run() {
	      this._fixOperationsStack();
	      this._registerControls();
	      this._registerLanguages();
	
	      this._loadLanguage();
	
	      _get(Object.getPrototypeOf(NightUI.prototype), 'run', this).call(this);
	
	      var container = this._options.container;
	
	      this.hideFlashMessage = this.hideFlashMessage.bind(this);
	
	      this._controlsContainer = container.querySelector('.imglykit-controls');
	      this._canvasControlsContainer = container.querySelector('.imglykit-canvas-controls');
	      this._overviewControlsContainer = container.querySelector('.imglykit-controls-overview');
	      this._loadingOverlay = container.querySelector('.imglykit-loadingOverlay');
	      this._loadingSpan = container.querySelector('.imglykit-loadingOverlay span');
	      this._flashOverlay = container.querySelector('.imglykit-flashOverlay');
	      this._flashHeadline = this._flashOverlay.querySelector('.imglykit-flashOverlay-headline');
	      this._flashText = this._flashOverlay.querySelector('.imglykit-flashOverlay-text');
	      this._flashCloseButton = this._flashOverlay.querySelector('.imglykit-flashOverlay-close');
	      this._flashCloseButton.addEventListener('click', this.hideFlashMessage);
	
	      this._handleOverview();
	
	      if (this._options.image) {
	        this._resizeImageIfNecessary();
	      }
	
	      if (this._options.image) {
	        this._initCanvas();
	      }
	
	      if (this.context.renderSplashScreen) {
	        this._initFileLoader();
	        if (this._options.ui.showWebcamButton) {
	          this._handleWebcamButton();
	        }
	      }
	
	      if (this.context.renderWebcam) {
	        this._initWebcam();
	      }
	
	      this._initTopControls();
	      this._initControls();
	
	      if (this._options.image) {
	        this.showZoom();
	      }
	
	      if (this._options.ui.showCloseButton) {
	        this._handleCloseButton();
	      }
	
	      if (this._topControls) {
	        this._topControls.updateExportButton();
	      }
	
	      if (this._canvas) {
	        this._canvas.run();
	      }
	    }
	  }, {
	    key: '_loadLanguage',
	    value: function _loadLanguage() {
	      this._language = this._languages[this._options.ui.language];
	      if (!this._language) {
	        var availableLanguages = Object.keys(this._languages).join(', ');
	        throw new Error('Unknown language \'' + this._options.ui.language + '\'. Available languages are: ' + availableLanguages);
	      }
	    }
	
	    /**
	     * The SDK automatically adds Rotation and Flip operations for images
	     * that have the wrong rotation (in the Exif tags). Since we have a specific
	     * operation order for this UI, we need to place them correctly
	     * @private
	     */
	  }, {
	    key: '_fixOperationsStack',
	    value: function _fixOperationsStack() {
	      var operationsStack = this._kit.operationsStack;
	
	      var newStack = [];
	      for (var i = 0; i < operationsStack.length; i++) {
	        var operation = operationsStack[i];
	        if (!operation) continue;
	
	        var identifier = operation.identifier;
	
	        var indexInStack = this._preferredOperationOrder.indexOf(identifier);
	        newStack[indexInStack] = operation;
	        this._operationsMap[identifier] = operation;
	      }
	      this._kit.operationsStack = newStack;
	    }
	
	    /**
	     * Initializes the webcam
	     * @private
	     */
	  }, {
	    key: '_initWebcam',
	    value: function _initWebcam() {
	      this._webcam = new _libWebcamHandler2['default'](this._kit, this);
	      this._webcam.on('image', this._onWebcamImageTaken.bind(this));
	    }
	
	    /**
	     * Gets called when the webcam image has been taken
	     * @param {Image} image
	     * @private
	     */
	  }, {
	    key: '_onWebcamImageTaken',
	    value: function _onWebcamImageTaken(image) {
	      this._options.ui.startWithWebcam = false;
	      this._setImage(image);
	    }
	
	    /**
	     * Handles the webcam button
	     * @private
	     */
	  }, {
	    key: '_handleWebcamButton',
	    value: function _handleWebcamButton() {
	      var _this = this;
	
	      var container = this._options.container;
	
	      var webcamButton = container.querySelector('.imglykit-splash-row--camera');
	      webcamButton.addEventListener('click', function () {
	        _this._options.ui.startWithWebcam = true;
	        _this.run();
	      });
	    }
	
	    /**
	     * Initializes the file loader
	     * @private
	     */
	  }, {
	    key: '_initFileLoader',
	    value: function _initFileLoader() {
	      this._fileLoader = new _libFileLoader2['default'](this._kit, this);
	      this._fileLoader.on('file', this._onFileLoaded.bind(this));
	    }
	
	    /**
	     * Gets called when the user loaded a file using the FileLoader
	     * @param {File} file
	     * @private
	     */
	  }, {
	    key: '_onFileLoaded',
	    value: function _onFileLoaded(file) {
	      var _this2 = this;
	
	      var reader = new FileReader();
	      reader.onload = (function () {
	        return function (e) {
	          var data = e.target.result;
	          var image = new Image();
	
	          image.addEventListener('load', function () {
	            _this2._setImage(image);
	          });
	
	          image.src = data;
	        };
	      })(file);
	      reader.readAsDataURL(file);
	    }
	
	    /**
	     * Sets the image option and starts rendering
	     * @param {Image} image
	     * @private
	     */
	  }, {
	    key: '_setImage',
	    value: function _setImage(image) {
	      this._kit.setImage(image);
	      this.run();
	    }
	
	    /**
	     * Initializes the top controls
	     * @private
	     */
	  }, {
	    key: '_initTopControls',
	    value: function _initTopControls() {
	      var _this3 = this;
	
	      if (!this.context.renderControls) return;
	
	      this._topControls = new _libTopControls2['default'](this._kit, this);
	      this._topControls.run();
	
	      this._topControls.on('new', function () {
	        _this3._operationsMap = {};
	        _this3._kit.operationsStack = [];
	        _this3._history = [];
	        _this3._options.image = null;
	        _this3.run();
	      });
	
	      this._topControls.on('undo', function () {
	        _this3.undo();
	      });
	
	      this._topControls.on('export', function () {
	        _this3['export']();
	      });
	
	      // Pass zoom in event
	      this._topControls.on('zoom-in', function () {
	        _this3._canvas.zoomIn().then(function () {
	          if (_this3._currentControl) {
	            _this3._currentControl.onZoom();
	          }
	        });
	      });
	
	      // Pass zoom out event
	      this._topControls.on('zoom-out', function () {
	        _this3._canvas.zoomOut().then(function () {
	          if (_this3._currentControl) {
	            _this3._currentControl.onZoom();
	          }
	        });
	      });
	    }
	
	    /**
	     * Resizes the image to fit the maximum texture size
	     * @private
	     */
	  }, {
	    key: '_resizeImageIfNecessary',
	    value: function _resizeImageIfNecessary() {
	      var image = this._options.image;
	
	      var imageDimensions = new _libMathVector22['default'](image.width, image.height);
	      var megaPixels = imageDimensions.x * imageDimensions.y / 1000000;
	
	      if (megaPixels > this._options.ui.maxMegaPixels) {
	        // Dimensions exceed `maxMegaPixels`. Calculate new size
	        var pixelsCount = this._options.ui.maxMegaPixels * 1000000;
	        var ratioHV = imageDimensions.x / imageDimensions.y;
	        var ratioVH = imageDimensions.y / imageDimensions.x;
	        var newDimensions = new _libMathVector22['default'](Math.sqrt(pixelsCount * ratioHV), Math.sqrt(pixelsCount * ratioVH)).floor();
	
	        this.emit('resized', {
	          reason: 'MAX_MEGA_PIXELS',
	          dimensions: newDimensions.clone()
	        });
	
	        this.displayFlashMessage(this.translate('generic.warning_headline'), this.translate('warnings.image_resized', this._options.ui.maxMegaPixels, newDimensions.x, newDimensions.y), 'warning');
	        this._imageResized = true;
	        this._options.image = _libImageResizer2['default'].resize(this._options.image, newDimensions);
	
	        // Flag as jpeg image so that the resulting image will
	        // also include exif data
	        this._options.image.src = 'data:image/jpeg;base64,';
	
	        // Copy already parsed exif data, since the one we just
	        // created does not have any
	        this._kit.setImage(this._options.image, this._kit.exif);
	      }
	    }
	
	    /**
	     * Inititializes the canvas
	     * @private
	     */
	  }, {
	    key: '_initCanvas',
	    value: function _initCanvas() {
	      var _this4 = this;
	
	      this._canvas = new _libCanvas2['default'](this._kit, this, this._options);
	      this._canvas.on('zoom', function () {
	        _this4._topControls.updateZoomLevel();
	      });
	      this._canvas.on('error', function (e) {
	        _this4.emit('error', e);
	        _this4.displayErrorMessage(e.code || e.message);
	      });
	      this._canvas.on('resized', function (payload) {
	        _this4.emit('resized', payload);
	      });
	    }
	
	    /**
	     * Displays the given error key
	     * @param {String} key
	     */
	  }, {
	    key: 'displayErrorMessage',
	    value: function displayErrorMessage(key) {
	      var err = this.translate('errors.' + key);
	      this.displayFlashMessage('An error has occurred!', err + ' (' + key + ')', 'error');
	    }
	
	    /**
	     * Displays a flash message with the given title and type
	     * @param {String} message
	     * @param {String} message
	     * @param {String} type = 'notice'
	     */
	  }, {
	    key: 'displayFlashMessage',
	    value: function displayFlashMessage(headline, message) {
	      var type = arguments.length <= 2 || arguments[2] === undefined ? 'notice' : arguments[2];
	
	      this._flashText.textContent = message;
	      this._flashHeadline.textContent = headline;
	      this._flashOverlay.style.display = 'block';
	
	      this._flashOverlay.className = 'imglykit-flashOverlay imglykit-flashOverlay--' + type;
	    }
	
	    /**
	     * Hides the flash message
	     */
	  }, {
	    key: 'hideFlashMessage',
	    value: function hideFlashMessage() {
	      this._flashOverlay.style.display = 'none';
	    }
	
	    /**
	     * Selects the enabled operations
	     * @param {ImglyKit.Selector}
	     */
	  }, {
	    key: 'selectOperations',
	    value: function selectOperations(selector) {
	      _get(Object.getPrototypeOf(NightUI.prototype), 'selectOperations', this).call(this, selector);
	    }
	
	    /**
	     * Returns or creates an instance of the operation with the given identifier
	     * @param {String} identifier
	     */
	  }, {
	    key: 'getOrCreateOperation',
	    value: function getOrCreateOperation(identifier) {
	      var _kit = this._kit;
	      var operationsStack = _kit.operationsStack;
	      var registeredOperations = _kit.registeredOperations;
	
	      var Operation = registeredOperations[identifier];
	
	      if (typeof this._operationsMap[identifier] === 'undefined') {
	        // Create operation
	        var operationInstance = new Operation(this._kit);
	        this._operationsMap[identifier] = operationInstance;
	
	        // Find index in preferred operation order
	        var index = this._preferredOperationOrder.indexOf(identifier);
	        if (index === -1) {
	          index = this._preferredOperationOrder.length;
	        }
	        operationsStack[index] = operationInstance;
	
	        return operationInstance;
	      } else {
	        return this._operationsMap[identifier];
	      }
	    }
	
	    /**
	     * Removes the operation with the given identifier from the stack
	     * @param {String} identifier
	     */
	  }, {
	    key: 'removeOperation',
	    value: function removeOperation(identifier) {
	      if (!this._operationsMap[identifier]) return;
	
	      var operation = this._operationsMap[identifier];
	      delete this._operationsMap[identifier];
	
	      var index = this._kit.operationsStack.indexOf(operation);
	      this._kit.operationsStack[index] = null;
	    }
	
	    /**
	     * Registers all default operation controls
	     * @private
	     */
	  }, {
	    key: '_registerControls',
	    value: function _registerControls() {
	      this.registerControl('filters', 'filters', __webpack_require__(95));
	      this.registerControl('rotation', 'rotation', __webpack_require__(97));
	      this.registerControl('flip', 'flip', __webpack_require__(98));
	      this.registerControl('brightness', 'brightness', __webpack_require__(99));
	      this.registerControl('contrast', 'contrast', __webpack_require__(101));
	      this.registerControl('saturation', 'saturation', __webpack_require__(102));
	      this.registerControl('crop', 'crop', __webpack_require__(103));
	      this.registerControl('radial-blur', 'radial-blur', __webpack_require__(104));
	      this.registerControl('tilt-shift', 'tilt-shift', __webpack_require__(106));
	      this.registerControl('frames', 'frames', __webpack_require__(107));
	      this.registerControl('stickers', 'stickers', __webpack_require__(109));
	      this.registerControl('text', 'text', __webpack_require__(110));
	      this.registerControl('brush', 'brush', __webpack_require__(111));
	    }
	
	    /**
	     * Register all default languages
	     * @private
	     */
	  }, {
	    key: '_registerLanguages',
	    value: function _registerLanguages() {
	      this.registerLanguage('en', __webpack_require__(112));
	      this.registerLanguage('de', __webpack_require__(113));
	    }
	
	    /**
	     * Handles the overview button click events
	     * @private
	     */
	  }, {
	    key: '_handleOverview',
	    value: function _handleOverview() {
	      var _this5 = this;
	
	      if (!this.context.renderControls) return;
	
	      var itemsList = this._overviewControlsContainer.querySelector('ul');
	      if (!itemsList.parentNode === this._overviewControlsContainer) {
	        return;
	      }
	      var listItems = [].filter.call(itemsList.querySelectorAll('li'), function (el) {
	        return el.parentNode === itemsList;
	      });
	
	      // Add click events to all items
	
	      var _loop = function (i) {
	        var listItem = listItems[i];
	        var identifier = listItem.getAttribute('data-identifier');
	        listItem.addEventListener('click', function () {
	          _this5.switchToControl(identifier);
	        });
	      };
	
	      for (var i = 0; i < listItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Enables the overview controls
	     * @private
	     */
	  }, {
	    key: '_enableControls',
	    value: function _enableControls() {
	      var itemsList = this._overviewControlsContainer.querySelector('ul');
	      if (!itemsList.parentNode === this._overviewControlsContainer) {
	        return;
	      }
	      var listItems = [].filter.call(itemsList.querySelectorAll('li'), function (el) {
	        return el.parentNode === itemsList;
	      });
	
	      // Add click events to all items
	      for (var i = 0; i < listItems.length; i++) {
	        var listItem = listItems[i];
	        listItem.removeAttribute('data-disabled');
	      }
	    }
	
	    /**
	     * Gets called when an overview button has been clicked
	     * @private
	     */
	  }, {
	    key: 'switchToControl',
	    value: function switchToControl(identifier) {
	      if (this.context.controlsDisabled) return;
	      this._overviewControlsContainer.style.display = 'none';
	
	      this._scrollbar.remove();
	
	      if (this._currentControl) {
	        this._currentControl.leave();
	      }
	
	      this._currentControl = this._registeredControls[identifier];
	      this._currentControl.enter();
	      this._currentControl.once('back', this._switchToOverview.bind(this));
	    }
	
	    /**
	     * Switches back to the overview controls
	     * @private
	     */
	  }, {
	    key: '_switchToOverview',
	    value: function _switchToOverview() {
	      if (this._currentControl) {
	        this._currentControl.leave();
	      }
	
	      this._currentControl = null;
	      this._overviewControlsContainer.style.display = '';
	
	      this._initScrollbar();
	    }
	
	    /**
	     * Registers the controls for an operation
	     * @param {String} identifier
	     * @param {String} operationIdentifier
	     * @param {Control} ControlClass
	     */
	  }, {
	    key: 'registerControl',
	    value: function registerControl(identifier, operationIdentifier, ControlClass) {
	      if (!this.isOperationSelected(operationIdentifier)) return;
	
	      var instance = new ControlClass(this._kit, this);
	      this._registeredControls[identifier] = instance;
	    }
	
	    /**
	     * Initializes the registered controls
	     * @private
	     */
	  }, {
	    key: '_initControls',
	    value: function _initControls() {
	      for (var identifier in this._registeredControls) {
	        var control = this._registeredControls[identifier];
	        control.setContainers(this._controlsContainer, this._canvasControlsContainer);
	        control.init();
	      }
	
	      this._initScrollbar();
	    }
	
	    /**
	     * Initializes the custom scrollbar
	     * @private
	     */
	  }, {
	    key: '_initScrollbar',
	    value: function _initScrollbar() {
	      if (!this.context.renderControls) return;
	
	      var container = this._controlsContainer.querySelector('.imglykit-controls-list').parentNode;
	      this._scrollbar = new _libScrollbar2['default'](container);
	    }
	
	    /**
	     * Handles the click event on the close button, emits a `close` event
	     * when clicking
	     * @private
	     */
	  }, {
	    key: '_handleCloseButton',
	    value: function _handleCloseButton() {
	      var _this6 = this;
	
	      var closeButton = this._options.container.querySelector('.imglykit-close-button');
	      closeButton.addEventListener('click', function (e) {
	        e.preventDefault();
	        _this6.emit('close');
	      });
	    }
	
	    /**
	     * Re-renders the canvas
	     */
	  }, {
	    key: 'render',
	    value: function render() {
	      if (this._canvas) {
	        this._canvas.render()['catch'](function (e) {
	          console.log(e);
	        });
	      }
	    }
	
	    /**
	     * An object containing all active operations
	     * @type {Object.<String,Operation>}
	     */
	  }, {
	    key: 'pause',
	
	    /**
	     * Pauses the UI. Operation updates will not cause a re-rendering
	     * of the canvas.
	     */
	    value: function pause() {
	      this._paused = true;
	    }
	
	    /**
	     * Resumes the UI and re-renders the canvas
	     * @param {Boolean} rerender = true
	     */
	  }, {
	    key: 'resume',
	    value: function resume() {
	      var rerender = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	      this._paused = false;
	      if (rerender) {
	        this.render();
	      }
	    }
	
	    /**
	     * Adds the given operation and options to the history stack
	     * @param {Operation} operation
	     * @param {Object.<String, *>} options
	     * @param {Boolean} existent
	     * @returns {Object} The history item
	     */
	  }, {
	    key: 'addHistory',
	    value: function addHistory(operation, options, existent) {
	      var historyItem = { operation: operation, options: options, existent: existent };
	      this._history.push(historyItem);
	      this._topControls.updateUndoButton();
	
	      this.emit('history-add', historyItem);
	
	      return historyItem;
	    }
	
	    /**
	     * Hides the zoom control
	     */
	  }, {
	    key: 'hideZoom',
	    value: function hideZoom() {
	      this._topControls.hideZoom();
	    }
	
	    /**
	     * Hides the zoom control
	     */
	  }, {
	    key: 'showZoom',
	    value: function showZoom() {
	      this._topControls.showZoom();
	    }
	
	    /**
	     * Takes the last history item and applies its options
	     */
	  }, {
	    key: 'undo',
	    value: function undo() {
	      var _this7 = this;
	
	      var lastItem = this._history.pop();
	      var promise = _vendorNativePromiseOnly2['default'].resolve();
	      if (lastItem) {
	        this.emit('history-undo', lastItem);
	
	        var operation = lastItem.operation;
	        var existent = lastItem.existent;
	        var options = lastItem.options;
	
	        if (!existent) {
	          this.removeOperation(operation.identifier);
	        } else {
	          operation = this.getOrCreateOperation(operation.identifier);
	          operation.set(options);
	        }
	        promise = this.canvas.zoomToFit(true);
	      }
	      this._topControls.updateUndoButton();
	
	      // Make sure the current control represents the new value
	      promise.then(function () {
	        if (_this7._currentControl) {
	          _this7._currentControl.update();
	        }
	      });
	    }
	
	    /**
	     * Exports the current image with the default settings
	     */
	  }, {
	    key: 'export',
	    value: function _export() {
	      var _this8 = this;
	
	      this.displayLoadingMessage(this.translate('generic.exporting') + '...');
	
	      var renderType = _constants.RenderType.DATAURL;
	
	      // Check if msToBlob is available
	      var canvas = document.createElement('canvas');
	      if (typeof canvas.msToBlob !== 'undefined') {
	        renderType = _constants.RenderType.MSBLOB;
	      }
	
	      setTimeout(function () {
	        _this8._kit.render(renderType, _this8._options.ui['export'].type, _this8._options.ui['export'].dimensions, _this8._options.ui['export'].quality).then(function (data) {
	          switch (renderType) {
	            case _constants.RenderType.DATAURL:
	              var url = _libUtils2['default'].createBlobURIFromDataURI(data);
	              var link = document.createElement('a');
	              var extension = _this8._options.ui['export'].type.split('/').pop();
	              link.download = 'imglykit-export.' + extension;
	              link.href = url;
	              document.body.appendChild(link);
	              link.click();
	              // Cleanup the DOM
	              document.body.removeChild(link);
	              break;
	            case _constants.RenderType.MSBLOB:
	              navigator.msSaveBlob(data, 'imglykit-export.png');
	              break;
	          }
	
	          _this8.hideLoadingMessage();
	        });
	      }, 1000);
	    }
	
	    /**
	     * Displays the given message inside the loading overlay
	     * @param {String} message
	     */
	  }, {
	    key: 'displayLoadingMessage',
	    value: function displayLoadingMessage(message) {
	      this._loadingSpan.textContent = message;
	      this._loadingOverlay.style.display = 'block';
	    }
	
	    /**
	     * Hides the loading message
	     */
	  }, {
	    key: 'hideLoadingMessage',
	    value: function hideLoadingMessage() {
	      this._loadingOverlay.style.display = 'none';
	    }
	
	    /**
	     * The undo history
	     * @type {Array.<Object>}
	     */
	  }, {
	    key: 'identifier',
	    get: function get() {
	      return 'night';
	    }
	  }, {
	    key: 'operations',
	    get: function get() {
	      return this._operationsMap;
	    }
	
	    /**
	     * An object containing all registered controls
	     * @type {Object.<String,Control>}
	     */
	  }, {
	    key: 'controls',
	    get: function get() {
	      return this._registeredControls;
	    }
	
	    /**
	     * The data that is passed to the template renderer
	     * @type {Object}
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      var context = _get(Object.getPrototypeOf(NightUI.prototype), 'context', this);
	      context.controls = this._registeredControls;
	      context.renderSplashScreen = !this._options.image && !this._options.ui.startWithWebcam;
	      context.renderControls = !!this._options.image;
	      context.renderWebcam = this._options.ui.startWithWebcam;
	      return context;
	    }
	  }, {
	    key: 'history',
	    get: function get() {
	      return this._history;
	    }
	
	    /**
	     * The file loader
	     * @type {FileLoader}
	     */
	  }, {
	    key: 'fileLoader',
	    get: function get() {
	      return this._fileLoader;
	    }
	
	    /**
	     * Has the image been resized initially?
	     * @type {Boolean}
	     */
	  }, {
	    key: 'imageResized',
	    get: function get() {
	      return this._imageResized;
	    }
	  }]);
	
	  return NightUI;
	})(_baseUi2['default']);
	
	NightUI.Control = __webpack_require__(96);
	
	exports['default'] = NightUI;
	module.exports = exports['default'];

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _helpers = __webpack_require__(88);
	
	var _helpers2 = _interopRequireDefault(_helpers);
	
	var BaseUI = (function (_EventEmitter) {
	  _inherits(BaseUI, _EventEmitter);
	
	  function BaseUI(kit, options) {
	    _classCallCheck(this, BaseUI);
	
	    _get(Object.getPrototypeOf(BaseUI.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this._options = options;
	    this._options.ui = this._options.ui || {};
	    this._operations = [];
	    this._helpers = new _helpers2['default'](this.kit, this, options);
	    this._languages = {};
	    this.selectOperations(null);
	  }
	
	  /**
	   * Prepares the UI for use
	   */
	
	  _createClass(BaseUI, [{
	    key: 'run',
	    value: function run() {
	      this._attach();
	    }
	
	    /**
	     * Registers a language
	     * @param  {String} identifier
	     * @param  {Object} object
	     */
	  }, {
	    key: 'registerLanguage',
	    value: function registerLanguage(identifier, object) {
	      this._languages[identifier] = object;
	    }
	
	    /**
	     * Returns the translation for `key`
	     * @param  {String} key
	     * @param  {Array.<String>} args
	     * @return {String}
	     */
	  }, {
	    key: 'translate',
	    value: function translate(key) {
            debugger;
	      var str = _libUtils2['default'].fetch(this._language, key,'translation-missing (' +key +')');
	
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      for (var i = 0; i < args.length; i++) {
	        var arg = args[i];
	        str = str.replace('$' + (i + 1), arg);
	      }
	      return str;
	    }
	
	    /**
	     * A unique string that represents this UI
	     * @type {String}
	     */
	  }, {
	    key: '_attach',
	
	    /**
	     * Renders and attaches the UI HTML
	     * @private
	     */
	    value: function _attach() {
	      if (this._options.container === null) {
	        throw new Error('BaseUI#attach: No container set.');
	      }
	
	      var html = this._render();
	      this._options.container.innerHTML = html;
	
	      // Container has to be position: relative
	      this._options.container.style.position = 'relative';
	    }
	
	    /**
	     * Renders the template
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render() {
	      if (typeof this._template === 'undefined') {
	        throw new Error('BaseUI#_render: No template set.');
	      }
	
	      return this._template(this.context);
	    }
	
	    /**
	     * Selects the enabled operations
	     * @param {ImglyKit.Selector}
	     */
	  }, {
	    key: 'selectOperations',
	    value: function selectOperations(selector) {
	      var registeredOperations = this._kit.registeredOperations;
	
	      var operationIdentifiers = Object.keys(registeredOperations);
	
	      var selectedOperations = _libUtils2['default'].select(operationIdentifiers, selector);
	      this._operations = selectedOperations.map(function (identifier) {
	        return registeredOperations[identifier];
	      });
	    }
	
	    /**
	     * Adds the given operation to the available operations
	     * @param {Operation} operation
	     */
	  }, {
	    key: 'addOperation',
	    value: function addOperation(operation) {
	      this._operations.push(operation);
	    }
	
	    /**
	     * Checks whether the operation with the given identifier is selected
	     * @param {String} identifier
	     * @returns {Boolean}
	     */
	  }, {
	    key: 'isOperationSelected',
	    value: function isOperationSelected(identifier) {
	      var operationIdentifiers = this._operations.map(function (operation) {
	        return operation.prototype.identifier;
	      });
	      return operationIdentifiers.indexOf(identifier) !== -1;
	    }
	
	    /**
	     * The data that is passed to the template renderer
	     * @type {Object}
	     */
	  }, {
	    key: 'identifier',
	    get: function get() {
	      return null;
	    }
	  }, {
	    key: 'context',
	    get: function get() {
	      return {
	        operations: this._operations,
	        helpers: this._helpers,
	        options: this._options
	      };
	    }
	
	    /**
	     * The DOM container
	     * @type {DOMElement}
	     */
	  }, {
	    key: 'container',
	    get: function get() {
	      return this._options.container;
	    }
	
	    /**
	     * The selected / active operations
	     * @type {Array.<ImglyKit.Operation>}
	     */
	  }, {
	    key: 'operations',
	    get: function get() {
	      return this._operations;
	    }
	
	    /**
	     * The options
	     * @type {Object}
	     */
	  }, {
	    key: 'options',
	    get: function get() {
	      return this._options;
	    }
	
	    /**
	     * The canvas object
	     * @type {Canvas}
	     */
	  }, {
	    key: 'canvas',
	    get: function get() {
	      return this._canvas;
	    }
	
	    /**
	     * The helpers
	     * @type {Helpers}
	     */
	  }, {
	    key: 'helpers',
	    get: function get() {
	      return this._helpers;
	    }
	
	    /**
	     * The image
	     * @type {Image}
	     */
	  }, {
	    key: 'image',
	    get: function get() {
	      return this._options.image;
	    }
	  }]);
	
	  return BaseUI;
	})(_libEventEmitter2['default']);
	
	exports['default'] = BaseUI;
	module.exports = exports['default'];

/***/ },
/* 88 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var Helpers = (function () {
	  function Helpers(kit, ui, options) {
	    _classCallCheck(this, Helpers);
	
	    this._kit = kit;
	    this._ui = ui;
	    this._options = options;
	  }
	
	  _createClass(Helpers, [{
	    key: 'assetPath',
	    value: function assetPath(asset) {
	      var path = this._options.assetsUrl + '/' + asset;
	
	      var assetPathResolver = this._ui.options.ui.assetPathResolver;
	      if (typeof assetPathResolver !== 'undefined') {
	        path = assetPathResolver(path);
	      }
	
	      return path;
	    }
	  }, {
	    key: 'translate',
	    value: function translate(key) {
	      return this._ui.translate(key);
	    }
	  }]);
	
	  return Helpers;
	})();
	
	exports['default'] = Helpers;
	module.exports = exports['default'];

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x4, _x5, _x6) { var _again = true; _function: while (_again) { var object = _x4, property = _x5, receiver = _x6; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x4 = parent; _x5 = property; _x6 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _renderersWebglRenderer = __webpack_require__(12);
	
	var _renderersWebglRenderer2 = _interopRequireDefault(_renderersWebglRenderer);
	
	var _renderersCanvasRenderer = __webpack_require__(5);
	
	var _renderersCanvasRenderer2 = _interopRequireDefault(_renderersCanvasRenderer);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _vendorPromise = __webpack_require__(8);
	
	var _vendorPromise2 = _interopRequireDefault(_vendorPromise);
	
	var Canvas = (function (_EventEmitter) {
	  _inherits(Canvas, _EventEmitter);
	
	  function Canvas(kit, ui, options) {
	    _classCallCheck(this, Canvas);
	
	    _get(Object.getPrototypeOf(Canvas.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this._ui = ui;
	    this._options = options;
	
	    var container = this._ui.container;
	
	    this._canvasContainer = container.querySelector('.imglykit-canvas-container');
	    this._canvasInnerContainer = container.querySelector('.imglykit-canvas-inner-container');
	    this._canvas = this._canvasContainer.querySelector('canvas');
	    this._image = this._options.image;
	    this._roundZoomBy = 0.1;
	    this._isFirstRender = true;
	
	    // Mouse event callbacks bound to the class context
	    this._dragOnMousedown = this._dragOnMousedown.bind(this);
	    this._dragOnMousemove = this._dragOnMousemove.bind(this);
	    this._dragOnMouseup = this._dragOnMouseup.bind(this);
	  }
	
	  /**
	   * Initializes the renderer, sets the zoom level and initially
	   * renders the operations stack
	   */
	
	  _createClass(Canvas, [{
	    key: 'run',
	    value: function run() {
	      this._initRenderer();
	
	      // Calculate the initial zoom level
	      this._zoomLevel = this._getInitialZoomLevel();
	      this._size = null;
	
	      this.render();
	      this._centerCanvas();
	      this._handleDrag();
	    }
	  }, {
	    key: 'getProcessedDimensions',
	    value: function getProcessedDimensions() {
	      var _this = this;
	
	      var stack = this.sanitizedStack;
	
	      var size = new _libMathVector22['default'](this._image.width, this._image.height);
	      stack.forEach(function (operation) {
	        size = operation.getNewDimensions(_this._renderer, size);
	      });
	
	      return size;
	    }
	
	    /**
	     * Renders the current operations stack
	     */
	  }, {
	    key: 'render',
	    value: function render() {
	      var _this2 = this;
	
	      // Calculate the initial size
	      var initialSize = this._renderer.getInitialDimensionsForStack(this.sanitizedStack).multiply(this._zoomLevel);
	      this._setCanvasSize(initialSize);
	
	      this._renderer.setSize(initialSize);
	
	      // Reset framebuffers
	      this._renderer.reset();
	
	      // Run the operations stack
	      var stack = this.sanitizedStack;
	      this._updateStackDirtyStates(stack);
	
	      var validationPromises = [];
	      for (var i = 0; i < stack.length; i++) {
	        var operation = stack[i];
	        validationPromises.push(operation.validateSettings());
	      }
	
	      return _vendorPromise2['default'].all(validationPromises).then(function () {
	        // When using WebGL, resize the image to max texture size if necessary
	        if (_this2._isFirstRender && _this2._renderer.identifier === 'webgl') {
	
	          if (_this2._image.width > _this2._renderer.maxTextureSize || _this2._image.height > _this2._renderer.maxTextureSize) {
	            _this2._ui.displayLoadingMessage('Resizing...');
	            return new _vendorPromise2['default'](function (resolve, reject) {
	              setTimeout(function () {
	                _this2._renderer.prepareImage(_this2._image).then(function (image) {
	
	                  _this2.emit('resized', {
	                    reason: 'MAX_TEXTURE_SIZE',
	                    dimensions: new _libMathVector22['default'](image.width, image.height)
	                  });
	
	                  _this2._ui.hideLoadingMessage();
	                  _this2._options.image = image;
	                  _this2._image = _this2._options.image;
	                  resolve();
	                })['catch'](function (e) {
	                  reject(e);
	                });
	              }, 100);
	            });
	          }
	        }
	      }).then(function () {
	        // On first render, draw the image to the input texture
	        if (_this2._isFirstRender || _this2._renderer.constructor.identifier === 'canvas') {
	          _this2._isFirstRender = false;
	          return _this2._renderer.drawImage(_this2._image);
	        }
	      })
	      // Render the operations stack
	      .then(function () {
	        var promise = _vendorPromise2['default'].resolve();
	
	        var _loop = function (i) {
	          var operation = stack[i];
	          promise = promise.then(function () {
	            operation.render(_this2._renderer);
	          });
	        };
	
	        for (var i = 0; i < stack.length; i++) {
	          _loop(i);
	        }
	        return promise;
	      })
	      // Render the final image
	      .then(function () {
	        return _this2._renderer.renderFinal();
	      })
	      // Update the margins and boundaries
	      .then(function () {
	        _this2._storeCanvasSize();
	        _this2._updateContainerSize();
	        _this2._updateCanvasMargins();
	        _this2._applyBoundaries();
	      })['catch'](function (e) {
	        _this2.emit('error', e);
	      });
	    }
	
	    /**
	     * Sets the image to the given one
	     * @param {Image} image
	     */
	  }, {
	    key: 'setImage',
	    value: function setImage(image) {
	      this._image = image;
	      this.reset();
	      this.render();
	      this._centerCanvas();
	    }
	
	    /**
	     * Increase zoom level
	     */
	  }, {
	    key: 'zoomIn',
	    value: function zoomIn() {
	      this._isInitialZoom = false;
	
	      var zoomLevel = Math.round(this._zoomLevel * 100);
	      var roundZoomBy = Math.round(this._roundZoomBy * 100);
	      var initialZoomLevel = Math.round(this._getInitialZoomLevel() * 100);
	
	      // Round up if needed
	      if (zoomLevel % roundZoomBy !== 0) {
	        zoomLevel = Math.ceil(zoomLevel / roundZoomBy) * roundZoomBy;
	      } else {
	        zoomLevel += roundZoomBy;
	      }
	
	      zoomLevel = Math.min(initialZoomLevel * 2, zoomLevel);
	      return this.setZoomLevel(zoomLevel / 100);
	    }
	
	    /**
	     * Decrease zoom level
	     */
	  }, {
	    key: 'zoomOut',
	    value: function zoomOut() {
	      this._isInitialZoom = false;
	
	      var zoomLevel = Math.round(this._zoomLevel * 100);
	      var roundZoomBy = Math.round(this._roundZoomBy * 100);
	      var initialZoomLevel = Math.round(this._getInitialZoomLevel() * 100);
	
	      // Round up if needed
	      if (zoomLevel % roundZoomBy !== 0) {
	        zoomLevel = Math.floor(zoomLevel / roundZoomBy) * roundZoomBy;
	      } else {
	        zoomLevel -= roundZoomBy;
	      }
	
	      zoomLevel = Math.max(initialZoomLevel, zoomLevel);
	      return this.setZoomLevel(zoomLevel / 100);
	    }
	
	    /**
	     * Resizes and positions the canvas
	     * @param {Vector2} [size]
	     * @private
	     */
	  }, {
	    key: '_setCanvasSize',
	    value: function _setCanvasSize(size) {
	      size = size || new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	      size = size.clone().floor();
	
	      if (this._canvas.width === size.x && this._canvas.height === size.y) {
	        return;
	      }
	
	      this._canvas.width = size.x;
	      this._canvas.height = size.y;
	
	      this._storeCanvasSize();
	      this._updateContainerSize();
	    }
	
	    /**
	     * Updates the canvas container size
	     * @private
	     */
	  }, {
	    key: '_updateContainerSize',
	    value: function _updateContainerSize() {
	      var size = this._size;
	      this._canvasInnerContainer.style.width = size.x + 'px';
	      this._canvasInnerContainer.style.height = size.y + 'px';
	    }
	
	    /**
	     * Remembers the canvas size
	     * @comment This was introduced because the canvas size was not always
	     *          correct due to some race conditions. Now that promises work
	     *          properly, do we still need this?
	     * @private
	     */
	  }, {
	    key: '_storeCanvasSize',
	    value: function _storeCanvasSize() {
	      this._size = new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	    }
	
	    /**
	     * Centers the canvas inside the container
	     * @private
	     */
	  }, {
	    key: '_centerCanvas',
	    value: function _centerCanvas() {
	      var position = this._maxSize.divide(2);
	
	      this._canvasInnerContainer.style.left = position.x + 'px';
	      this._canvasInnerContainer.style.top = position.y + 'px';
	
	      this._updateCanvasMargins();
	    }
	
	    /**
	     * Updates the canvas margins so that they are the negative half width
	     * and height of the canvas
	     * @private
	     */
	  }, {
	    key: '_updateCanvasMargins',
	    value: function _updateCanvasMargins() {
	      var canvasSize = new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	      var margin = canvasSize.divide(2).multiply(-1);
	      this._canvasInnerContainer.style.marginLeft = margin.x + 'px';
	      this._canvasInnerContainer.style.marginTop = margin.y + 'px';
	    }
	
	    /**
	     * Sets the zoom level, re-renders the canvas and
	     * repositions it
	     * @param {Number} zoomLevel
	     * @param {Boolean} render = true
	     * @param {Boolean} isInitialZoom = false
	     * @private
	     */
	  }, {
	    key: 'setZoomLevel',
	    value: function setZoomLevel(zoomLevel) {
	      var _this3 = this;
	
	      var render = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	      var isInitialZoom = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];
	
	      this._zoomLevel = zoomLevel;
	      this._isInitialZoom = isInitialZoom;
	
	      if (render) {
	        this.setAllOperationsToDirty();
	        return this.render().then(function () {
	          _this3._updateCanvasMargins();
	          _this3._applyBoundaries();
	          _this3.emit('zoom'); // will be redirected to top controls
	        });
	      } else {
	          this._updateCanvasMargins();
	          this._applyBoundaries();
	          this.emit('zoom'); // will be redirected to top controls
	        }
	    }
	
	    /**
	     * Sets all operations to dirty
	     */
	  }, {
	    key: 'setAllOperationsToDirty',
	    value: function setAllOperationsToDirty() {
	      var operationsStack = this._kit.operationsStack;
	
	      for (var i = 0; i < operationsStack.length; i++) {
	        var operation = operationsStack[i];
	        if (!operation) continue;
	        operation.dirty = true;
	      }
	    }
	
	    /**
	     * Resets all operations
	     */
	  }, {
	    key: 'resetAllOperations',
	    value: function resetAllOperations() {
	      var operationsStack = this._kit.operationsStack;
	
	      for (var i = 0; i < operationsStack.length; i++) {
	        var operation = operationsStack[i];
	        if (!operation) continue;
	        operation.reset();
	      }
	    }
	
	    /**
	     * Gets the initial zoom level so that the image fits the maximum
	     * canvas size
	     * @private
	     */
	  }, {
	    key: '_getInitialZoomLevel',
	    value: function _getInitialZoomLevel() {
	      var nativeDimensions = this._renderer.getOutputDimensionsForStack(this.sanitizedStack);
	      var fitDimensions = _libUtils2['default'].resizeVectorToFit(nativeDimensions, this._maxSize);
	
	      return fitDimensions.divide(nativeDimensions).x;
	    }
	
	    /**
	     * Initializes the renderer
	     * @private
	     */
	  }, {
	    key: '_initRenderer',
	    value: function _initRenderer() {
	      var _this4 = this;
	
	      if (_renderersWebglRenderer2['default'].isSupported() && this._options.renderer !== 'canvas') {
	        this._renderer = new _renderersWebglRenderer2['default'](null, this._canvas, this._image);
	        this._webglEnabled = true;
	      } else if (_renderersCanvasRenderer2['default'].isSupported()) {
	        this._renderer = new _renderersCanvasRenderer2['default'](null, this._canvas, this._image);
	        this._webglEnabled = false;
	      }
	
	      if (this._renderer === null) {
	        throw new Error('Neither Canvas nor WebGL renderer are supported.');
	      }
	
	      this._renderer.on('new-canvas', function (canvas) {
	        _this4._setCanvas(canvas);
	      });
	      this._renderer.on('error', function (e) {
	        _this4.emit('error', e);
	      });
	      this._renderer.on('reset', function () {
	        _this4.resetAllOperations();
	        _this4._isFirstRender = true;
	        _this4.render();
	      });
	    }
	
	    /**
	     * Replaces the canvas with the given canvas, updates margins etc
	     * @param {DOMElement} canvas
	     * @private
	     */
	  }, {
	    key: '_setCanvas',
	    value: function _setCanvas(canvas) {
	      var canvasParent = this._canvas.parentNode;
	      canvasParent.removeChild(this._canvas);
	      this._canvas = canvas;
	      canvasParent.appendChild(this._canvas);
	
	      this._updateCanvasMargins();
	      this._applyBoundaries();
	      this._updateContainerSize();
	    }
	
	    /**
	     * Handles the dragging
	     * @private
	     */
	  }, {
	    key: '_handleDrag',
	    value: function _handleDrag() {
	      this._canvas.addEventListener('mousedown', this._dragOnMousedown);
	      this._canvas.addEventListener('touchstart', this._dragOnMousedown);
	    }
	
	    /**
	     * Gets called when the user started touching / clicking the canvas
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_dragOnMousedown',
	    value: function _dragOnMousedown(e) {
	      if (e.type === 'mousedown' && e.button !== 0) return;
	      e.preventDefault();
	
	      var canvasX = parseInt(this._canvasInnerContainer.style.left, 10);
	      var canvasY = parseInt(this._canvasInnerContainer.style.top, 10);
	
	      document.addEventListener('mousemove', this._dragOnMousemove);
	      document.addEventListener('touchmove', this._dragOnMousemove);
	
	      document.addEventListener('mouseup', this._dragOnMouseup);
	      document.addEventListener('touchend', this._dragOnMouseup);
	
	      // Remember initial position
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialCanvasPosition = new _libMathVector22['default'](canvasX, canvasY);
	    }
	
	    /**
	     * Gets called when the user drags the canvas
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_dragOnMousemove',
	    value: function _dragOnMousemove(e) {
	      e.preventDefault();
	
	      var newMousePosition = _libUtils2['default'].getEventPosition(e);
	      var mouseDiff = newMousePosition.clone().subtract(this._initialMousePosition);
	      var newPosition = this._initialCanvasPosition.clone().add(mouseDiff);
	
	      this._canvasInnerContainer.style.left = newPosition.x + 'px';
	      this._canvasInnerContainer.style.top = newPosition.y + 'px';
	
	      this._applyBoundaries();
	    }
	
	    /**
	     * Makes sure the canvas positions are within the boundaries
	     * @private
	     */
	  }, {
	    key: '_applyBoundaries',
	    value: function _applyBoundaries() {
	      var x = parseInt(this._canvasInnerContainer.style.left, 10);
	      var y = parseInt(this._canvasInnerContainer.style.top, 10);
	      var canvasPosition = new _libMathVector22['default'](x, y);
	
	      // Boundaries
	      var boundaries = this._boundaries;
	      canvasPosition.x = Math.min(boundaries.max.x, Math.max(boundaries.min.x, canvasPosition.x));
	      canvasPosition.y = Math.min(boundaries.max.y, Math.max(boundaries.min.y, canvasPosition.y));
	
	      this._canvasInnerContainer.style.left = canvasPosition.x + 'px';
	      this._canvasInnerContainer.style.top = canvasPosition.y + 'px';
	    }
	
	    /**
	     * Gets called when the user stopped dragging the canvsa
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_dragOnMouseup',
	    value: function _dragOnMouseup(e) {
	      e.preventDefault();
	
	      document.removeEventListener('mousemove', this._dragOnMousemove);
	      document.removeEventListener('touchmove', this._dragOnMousemove);
	
	      document.removeEventListener('mouseup', this._dragOnMouseup);
	      document.removeEventListener('touchend', this._dragOnMouseup);
	    }
	
	    /**
	     * The position boundaries for the canvas inside the container
	     * @type {Object.<Vector2>}
	     * @private
	     */
	  }, {
	    key: '_updateStackDirtyStates',
	
	    /**
	     * Find the first dirty operation of the stack and sets all following
	     * operations to dirty
	     * @param {Array.<Operation>} stack
	     * @private
	     */
	    value: function _updateStackDirtyStates(stack) {
	      var dirtyFound = false;
	      for (var i = 0; i < stack.length; i++) {
	        var operation = stack[i];
	        if (!operation) continue;
	        if (operation.dirty) {
	          dirtyFound = true;
	        }
	
	        if (dirtyFound) {
	          operation.dirty = true;
	        }
	      }
	    }
	
	    /**
	     * Zooms the canvas so that it fits the container
	     * @param {Boolean} render
	     */
	  }, {
	    key: 'zoomToFit',
	    value: function zoomToFit() {
	      var render = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];
	
	      var initialZoomLevel = this._getInitialZoomLevel();
	      return this.setZoomLevel(initialZoomLevel, render, true);
	    }
	
	    /**
	     * Resets the renderer
	     */
	  }, {
	    key: 'reset',
	    value: function reset() {
	      this._renderer.reset(true);
	      this._kit.operationsStack = [];
	      this._isFirstRender = true;
	    }
	
	    /**
	     * Returns the operations stack without falsy values
	     * @type {Array.<Operation>}
	     */
	  }, {
	    key: '_boundaries',
	    get: function get() {
	      var canvasSize = new _libMathVector22['default'](this._canvas.width, this._canvas.height);
	      var maxSize = this._maxSize;
	
	      var diff = canvasSize.clone().subtract(maxSize).multiply(-1);
	
	      var boundaries = {
	        min: new _libMathVector22['default'](diff.x, diff.y),
	        max: new _libMathVector22['default'](0, 0)
	      };
	
	      if (canvasSize.x < maxSize.x) {
	        boundaries.min.x = diff.x / 2;
	        boundaries.max.x = diff.x / 2;
	      }
	
	      if (canvasSize.y < maxSize.y) {
	        boundaries.min.y = diff.y / 2;
	        boundaries.max.y = diff.y / 2;
	      }
	
	      var halfCanvasSize = canvasSize.clone().divide(2);
	      boundaries.min.add(halfCanvasSize);
	      boundaries.max.add(halfCanvasSize);
	      return boundaries;
	    }
	
	    /**
	     * The maximum canvas size
	     * @private
	     */
	  }, {
	    key: '_maxSize',
	    get: function get() {
	      return new _libMathVector22['default'](this._canvasContainer.offsetWidth, this._canvasContainer.offsetHeight);
	    }
	  }, {
	    key: 'sanitizedStack',
	    get: function get() {
	      var sanitizedStack = [];
	      for (var i = 0; i < this._kit.operationsStack.length; i++) {
	        var operation = this._kit.operationsStack[i];
	        if (!operation) continue;
	        sanitizedStack.push(operation);
	      }
	      return sanitizedStack;
	    }
	
	    /**
	     * The current zoom level
	     * @type {Number}
	     */
	  }, {
	    key: 'zoomLevel',
	    get: function get() {
	      return this._zoomLevel;
	    }
	
	    /**
	     * The canvas size in pixels
	     * @type {Vector2}
	     */
	  }, {
	    key: 'size',
	    get: function get() {
	      return this._size;
	    }
	
	    /**
	     * Returns the renderer
	     * @return {Renderer}
	     */
	  }, {
	    key: 'renderer',
	    get: function get() {
	      return this._renderer;
	    }
	  }]);
	
	  return Canvas;
	})(_libEventEmitter2['default']);
	
	exports['default'] = Canvas;
	module.exports = exports['default'];

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var FileLoader = (function (_EventEmitter) {
	  _inherits(FileLoader, _EventEmitter);
	
	  function FileLoader(kit, ui) {
	    _classCallCheck(this, FileLoader);
	
	    _get(Object.getPrototypeOf(FileLoader.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this._ui = ui;
	
	    // http://stackoverflow.com/questions/7110353/html5-dragleave-fired-when-hovering-a-child-element
	    this._dragCounter = 0;
	
	    this._container = this._ui.container.querySelector('.imglykit-splash-container');
	
	    this._onDropAreaDragEnter = this._onDropAreaDragEnter.bind(this);
	    this._onDropAreaDragOver = this._onDropAreaDragOver.bind(this);
	    this._onDropAreaDragLeave = this._onDropAreaDragLeave.bind(this);
	    this._onDropAreaDrop = this._onDropAreaDrop.bind(this);
	    this._onDropAreaClick = this._onDropAreaClick.bind(this);
	    this._onFileInputChange = this._onFileInputChange.bind(this);
	
	    this._hiddenInputField = this._ui.container.querySelector('.imglykit-upload-hidden-input');
	    this._hiddenInputField.addEventListener('change', this._onFileInputChange);
	
	    this._handleDropArea();
	    if (this._ui.options.image) {
	      this.removeDOM();
	    }
	  }
	
	  /**
	   * Opens the file dialog
	   */
	
	  _createClass(FileLoader, [{
	    key: 'openFileDialog',
	    value: function openFileDialog() {
	      this._hiddenInputField.click();
	    }
	
	    /**
	     * Finds the drop area, adds event listeners
	     * @private
	     */
	  }, {
	    key: '_handleDropArea',
	    value: function _handleDropArea() {
	      this._dropArea = this._container.querySelector('.imglykit-splash-row--upload');
	      this._dropArea.addEventListener('dragenter', this._onDropAreaDragEnter);
	      this._dropArea.addEventListener('dragover', this._onDropAreaDragOver);
	      this._dropArea.addEventListener('dragleave', this._onDropAreaDragLeave);
	      this._dropArea.addEventListener('drop', this._onDropAreaDrop);
	      this._dropArea.addEventListener('dragdrop', this._onDropAreaDrop);
	      this._dropArea.addEventListener('click', this._onDropAreaClick);
	    }
	
	    /**
	     * Gets called when the user clicks on the drop area. Opens the file
	     * dialog by triggering a click on the hidden input field
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onDropAreaClick',
	    value: function _onDropAreaClick(e) {
	      e.stopPropagation();
	      this.openFileDialog();
	    }
	
	    /**
	     * Gets called when the user drags a file over the drop area
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onDropAreaDragEnter',
	    value: function _onDropAreaDragEnter(e) {
	      e.preventDefault();
	
	      this._dragCounter++;
	      _libUtils2['default'].classList(this._dropArea).add('imglykit-splash-active');
	    }
	
	    /**
	     * We need to cancel this event to get a drop event
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onDropAreaDragOver',
	    value: function _onDropAreaDragOver(e) {
	      e.preventDefault();
	    }
	
	    /**
	     * Gets called when the user does no longer drag a file over the drop area
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onDropAreaDragLeave',
	    value: function _onDropAreaDragLeave(e) {
	      e.preventDefault();
	
	      this._dragCounter--;
	
	      if (this._dragCounter === 0) {
	        _libUtils2['default'].classList(this._dropArea).remove('imglykit-splash-active');
	      }
	    }
	
	    /**
	     * Gets called when the user drops a file on the drop area
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onDropAreaDrop',
	    value: function _onDropAreaDrop(e) {
	      e.stopPropagation();
	      e.preventDefault();
	      e.returnValue = false;
	
	      _libUtils2['default'].classList(this._dropArea).remove('imglykit-splash-active');
	
	      if (!e.dataTransfer) return;
	
	      this._ui.displayLoadingMessage(this._ui.translate('generic.importing') + '...');
	
	      this._handleFile(e.dataTransfer.files[0]);
	    }
	
	    /**
	     * Gets called when the user selected a file
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onFileInputChange',
	    value: function _onFileInputChange() {
	      this._handleFile(this._hiddenInputField.files[0]);
	    }
	
	    /**
	     * Gets called when the user selected a file. Emits a `file` event.
	     * @param {File} file
	     * @private
	     */
	  }, {
	    key: '_handleFile',
	    value: function _handleFile(file) {
	      this.emit('file', file);
	    }
	
	    /**
	     * Removes event listeners and removes the container form the dom
	     */
	  }, {
	    key: 'removeDOM',
	    value: function removeDOM() {
	      this._dropArea.removeEventListener('dragenter', this._onDropAreaDragEnter);
	      this._dropArea.removeEventListener('dragover', this._onDropAreaDragOver);
	      this._dropArea.removeEventListener('dragleave', this._onDropAreaDragLeave);
	      this._dropArea.removeEventListener('drop', this._onDropAreaDrop);
	      this._dropArea.removeEventListener('dragdrop', this._onDropAreaDrop);
	      this._dropArea.removeEventListener('click', this._onDropAreaClick);
	
	      if (this._container) {
	        this._container.style.display = 'none';
	      }
	    }
	  }]);
	
	  return FileLoader;
	})(_libEventEmitter2['default']);
	
	exports['default'] = FileLoader;
	module.exports = exports['default'];

/***/ },
/* 91 */
/***/ function(module, exports) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	exports['default'] = {
	  resize: function resize(image, dimensions) {
	    var newCanvas = document.createElement('canvas');
	    newCanvas.width = dimensions.x;
	    newCanvas.height = dimensions.y;
	
	    var context = newCanvas.getContext('2d');
	    context.drawImage(image, 0, 0, image.width, image.height, 0, 0, dimensions.x, dimensions.y);
	
	    return newCanvas;
	  }
	};
	module.exports = exports['default'];

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/* global Image */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var WebcamHandler = (function (_EventEmitter) {
	  _inherits(WebcamHandler, _EventEmitter);
	
	  function WebcamHandler(kit, ui) {
	    _classCallCheck(this, WebcamHandler);
	
	    _get(Object.getPrototypeOf(WebcamHandler.prototype), 'constructor', this).call(this);
	    this._kit = kit;
	    this._ui = ui;
	
	    var container = this._ui.container;
	
	    this._canvasContainer = container.querySelector('.imglykit-canvas-container');
	
	    this._video = container.querySelector('.imglykit-webcam-video');
	    this._webcamButton = container.querySelector('.imglykit-webcam-button');
	    this._webcamButton.addEventListener('click', this._onWebcamButtonClick.bind(this));
	    this._initVideoStream();
	  }
	
	  /**
	   * Gets called when the user clicked the shutter button. Draws the current
	   * video frame to a canvas, creates an image from it and emits the `image`
	   * event
	   * @param  {Event} e
	   * @private
	   */
	
	  _createClass(WebcamHandler, [{
	    key: '_onWebcamButtonClick',
	    value: function _onWebcamButtonClick(e) {
	      var _this = this;
	
	      e.preventDefault();
	      var canvas = document.createElement('canvas');
	      canvas.width = this._video.videoWidth;
	      canvas.height = this._video.videoHeight;
	      var context = canvas.getContext('2d');
	      context.drawImage(this._video, 0, 0);
	
	      // Deprecated MediaStream API
	      if (this._stream.stop) {
	        this._stream.stop();
	      }
	
	      // New MediaStreamTrack API, stopping all tracks
	      if (this._tracks) {
	        this._tracks.forEach(function (track) {
	          track.stop();
	        });
	      }
	
	      this._video.pause();
	
	      delete this._stream;
	      delete this._video;
	
	      var image = new Image();
	      image.addEventListener('load', function () {
	        _this.emit('image', image);
	      });
	      image.src = canvas.toDataURL('image/png');
	    }
	
	    /**
	     * Initializes the video stream
	     * @private
	     */
	  }, {
	    key: '_initVideoStream',
	    value: function _initVideoStream() {
	      var _this2 = this;
	
	      var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;
	      if (!getUserMedia) {
	        throw new Error('Webcam feature not supported! :(');
	      }
	
	      getUserMedia.call(navigator, { video: true }, function (stream) {
	        _this2._stream = stream;
	        if (stream.getTracks) {
	          _this2._tracks = stream.getTracks();
	        }
	        _this2._video.onloadedmetadata = _this2._onVideoReady.bind(_this2);
	        _this2._video.src = window.URL.createObjectURL(stream);
	      }, function (err) {
	        throw err;
	      });
	    }
	  }, {
	    key: '_onVideoReady',
	    value: function _onVideoReady() {
	      this._resizeVideo();
	    }
	  }, {
	    key: '_resizeVideo',
	    value: function _resizeVideo() {
	      var _video = this._video;
	      var videoWidth = _video.videoWidth;
	      var videoHeight = _video.videoHeight;
	
	      var size = new _libMathVector22['default'](videoWidth, videoHeight);
	      var maxSize = new _libMathVector22['default'](this._canvasContainer.offsetWidth, this._canvasContainer.offsetHeight);
	
	      var finalSize = _libUtils2['default'].resizeVectorToFit(size, maxSize);
	      this._video.style.width = finalSize.x + 'px';
	      this._video.style.height = finalSize.y + 'px';
	
	      var diff = maxSize.clone().subtract(finalSize).divide(2);
	
	      this._video.style.marginLeft = diff.x + 'px';
	      this._video.style.marginTop = diff.y + 'px';
	    }
	  }, {
	    key: 'getUserMedia',
	    get: function get() {
	      return;
	    }
	  }]);
	
	  return WebcamHandler;
	})(_libEventEmitter2['default']);
	
	exports['default'] = WebcamHandler;
	module.exports = exports['default'];

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var TopControls = (function (_EventEmitter) {
	  _inherits(TopControls, _EventEmitter);
	
	  function TopControls(kit, ui) {
	    _classCallCheck(this, TopControls);
	
	    _get(Object.getPrototypeOf(TopControls.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this._ui = ui;
	    this.init();
	  }
	
	  /**
	   * Initializes the controls
	   */
	
	  _createClass(TopControls, [{
	    key: 'init',
	    value: function init() {
	      this._canvas = this._ui.canvas;
	    }
	
	    /**
	     * Initializes the controls
	     */
	  }, {
	    key: 'run',
	    value: function run() {
	      var container = this._ui.container;
	
	      this._rightControls = container.querySelector('.imglykit-top-controls-right');
	      this._leftControls = container.querySelector('.imglykit-top-controls-left');
	
	      this._undoButton = container.querySelector('.imglykit-undo');
	      this._zoomIn = container.querySelector('.imglykit-zoom-in');
	      this._zoomOut = container.querySelector('.imglykit-zoom-out');
	      this._zoomLevel = container.querySelector('.imglykit-zoom-level-num');
	      this._newButton = container.querySelector('.imglykit-new');
	      this._exportButton = container.querySelector('.imglykit-export');
	      this._handleZoom();
	      this._handleUndo();
	      this._handleNew();
	      this._handleExport();
	    }
	
	    /**
	     * Handles the zoom controls
	     * @private
	     */
	  }, {
	    key: '_handleZoom',
	    value: function _handleZoom() {
	      this._zoomIn.addEventListener('click', this._onZoomInClick.bind(this));
	      this._zoomOut.addEventListener('click', this._onZoomOutClick.bind(this));
	    }
	
	    /**
	     * Handles the undo control
	     * @private
	     */
	  }, {
	    key: '_handleUndo',
	    value: function _handleUndo() {
	      this._undoButton.addEventListener('click', this._undo.bind(this));
	      this._undo();
	    }
	
	    /**
	     * Handles the new button
	     * @private
	     */
	  }, {
	    key: '_handleNew',
	    value: function _handleNew() {
	      if (!this._newButton) return;
	
	      this._newButton.addEventListener('click', this._onNewClick.bind(this));
	    }
	
	    /**
	     * Handles the export button
	     * @private
	     */
	  }, {
	    key: '_handleExport',
	    value: function _handleExport() {
	      if (!this._exportButton) return;
	
	      this._exportButton.addEventListener('click', this._onExportClick.bind(this));
	    }
	
	    /**
	     * Gets called when the user clicks the new button
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onNewClick',
	    value: function _onNewClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	      this.emit('new');
	    }
	
	    /**
	     * Gets called when the user clicks the export button
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onExportClick',
	    value: function _onExportClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      this.emit('export');
	    }
	
	    /**
	     * Gets called when the user clicks the undo button
	     * @private
	     */
	  }, {
	    key: '_undo',
	    value: function _undo() {
	      this.emit('undo');
	    }
	
	    /**
	     * Updates the undo button visible state
	     */
	  }, {
	    key: 'updateUndoButton',
	    value: function updateUndoButton() {
	      var history = this._ui.history;
	
	      if (history.length === 0) {
	        this._undoButton.style.display = 'none';
	      } else {
	        this._undoButton.style.display = 'inline-block';
	      }
	    }
	
	    /**
	     * Updates the export button visible state
	     */
	  }, {
	    key: 'updateExportButton',
	    value: function updateExportButton() {
	      if (!this._exportButton) return;
	
	      var image = this._ui.image;
	
	      if (image) {
	        this._exportButton.style.display = 'inline-block';
	      } else {
	        this._exportButton.style.display = 'none';
	      }
	    }
	
	    /**
	     * Gets called when the user clicked the zoom in button
	     * @param {Event}
	     * @private
	     */
	  }, {
	    key: '_onZoomInClick',
	    value: function _onZoomInClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      this.emit('zoom-in');
	      this.updateZoomLevel();
	    }
	
	    /**
	     * Gets called when the user clicked the zoom out button
	     * @param {Event}
	     * @private
	     */
	  }, {
	    key: '_onZoomOutClick',
	    value: function _onZoomOutClick(e) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      this.emit('zoom-out');
	      this.updateZoomLevel();
	    }
	
	    /**
	     * Shows the zoom control
	     */
	  }, {
	    key: 'showZoom',
	    value: function showZoom() {
	      this._rightControls.style.display = 'inline-block';
	    }
	
	    /**
	     * Hides the zoom control
	     */
	  }, {
	    key: 'hideZoom',
	    value: function hideZoom() {
	      this._rightControls.style.display = 'none';
	    }
	
	    /**
	     * Updates the zoom level display
	     */
	  }, {
	    key: 'updateZoomLevel',
	    value: function updateZoomLevel() {
	      var zoomLevel = this._canvas.zoomLevel;
	
	      this._zoomLevel.innerHTML = Math.round(zoomLevel * 100);
	    }
	  }]);
	
	  return TopControls;
	})(_libEventEmitter2['default']);
	
	exports['default'] = TopControls;
	module.exports = exports['default'];

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var maxScrollbarWidth = 18;
	
	/**
	 * Our custom scroll bar
	 */
	
	var Scrollbar = (function () {
	  /**
	   * @param {DOMElement} container
	   */
	
	  function Scrollbar(container) {
	    _classCallCheck(this, Scrollbar);
	
	    this._container = container;
	    this._isDragging = false;
	    this._isHovering = false;
	
	    if (!this._browserSupported()) {
	      return;
	    }
	
	    this._appendDOM();
	    this._resizeButton();
	    this._updateValues();
	
	    this._onButtonDown = this._onButtonDown.bind(this);
	    this._onButtonMove = this._onButtonMove.bind(this);
	    this._onButtonUp = this._onButtonUp.bind(this);
	
	    this._onContainerEnter = this._onContainerEnter.bind(this);
	    this._onContainerLeave = this._onContainerLeave.bind(this);
	
	    this._onBackgroundClick = this._onBackgroundClick.bind(this);
	
	    this._container.addEventListener('mouseenter', this._onContainerEnter);
	    this._container.addEventListener('mouseleave', this._onContainerLeave);
	    this._container.addEventListener('mousemove', this._onContainerEnter);
	    this._dom.button.addEventListener('mousedown', this._onButtonDown);
	    this._dom.button.addEventListener('touchstart', this._onButtonDown);
	    this._dom.background.addEventListener('click', this._onBackgroundClick);
	    this._list.addEventListener('scroll', this._onListScroll.bind(this));
	
	    this._onListScroll();
	  }
	
	  /**
	   * Checks whether this feature is supported in the current browser
	   * @return {Boolean}
	   * @private
	   */
	
	  _createClass(Scrollbar, [{
	    key: '_browserSupported',
	    value: function _browserSupported() {
	      var IEMatch = navigator.appVersion.match(/MSIE ([\d.]+)/);
	      if (IEMatch && parseFloat(IEMatch[1]) <= 9) {
	        return false;
	      }
	      return true;
	    }
	
	    /**
	     * Gets called when the user clicks the scrollbar background
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onBackgroundClick',
	    value: function _onBackgroundClick(e) {
	      e.preventDefault();
	      if (e.target !== this._dom.background) return;
	
	      var position = _libUtils2['default'].getEventPosition(e);
	      var backgroundOffset = this._dom.background.getBoundingClientRect();
	      backgroundOffset = new _libMathVector22['default'](backgroundOffset.left, backgroundOffset.top);
	
	      var relativePosition = position.clone().subtract(backgroundOffset);
	
	      relativePosition.x -= this._values.button.width * 0.5;
	
	      this._setButtonPosition(relativePosition.x);
	    }
	
	    /**
	     * Gets called when the user enters the list with the mouse
	     * @private
	     */
	  }, {
	    key: '_onContainerEnter',
	    value: function _onContainerEnter() {
	      this._isHovering = true;
	      this.show();
	    }
	
	    /**
	     * Gets called when the user leaves the list with the mouse
	     * @private
	     */
	  }, {
	    key: '_onContainerLeave',
	    value: function _onContainerLeave() {
	      this._isHovering = false;
	      this.hide();
	    }
	
	    /**
	     * Shows the scrollbar
	     */
	  }, {
	    key: 'show',
	    value: function show() {
	      if (!this._browserSupported()) return;
	      if (!this._isScrollingNecessary) return;
	      _libUtils2['default'].classList(this._dom.background).add('visible');
	    }
	
	    /**
	     * Hides the scrollbar
	     */
	  }, {
	    key: 'hide',
	    value: function hide() {
	      if (!this._browserSupported()) return;
	      if (this._isDragging) return;
	      _libUtils2['default'].classList(this._dom.background).remove('visible');
	    }
	
	    /**
	     * Updates the size values
	     * @private
	     */
	  }, {
	    key: '_updateValues',
	    value: function _updateValues() {
	      this._values = {
	        list: {
	          totalWidth: this._list.scrollWidth,
	          visibleWidth: this._list.offsetWidth,
	          scrollableWidth: this._list.scrollWidth - this._list.offsetWidth
	        },
	        button: {
	          width: this._dom.button.offsetWidth,
	          scrollableWidth: this._dom.background.offsetWidth - this._dom.button.offsetWidth
	        }
	      };
	    }
	
	    /**
	     * Gets called when the user starts dragging the button
	     * @param {Event} event
	     * @private
	     */
	  }, {
	    key: '_onButtonDown',
	    value: function _onButtonDown(event) {
	      event.preventDefault();
	
	      this._isDragging = true;
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(event);
	      this._initialButtonPosition = this._buttonPosition || 0;
	
	      document.addEventListener('mousemove', this._onButtonMove);
	      document.addEventListener('touchmove', this._onButtonMove);
	      document.addEventListener('mouseup', this._onButtonUp);
	      document.addEventListener('touchend', this._onButtonUp);
	    }
	
	    /**
	     * Gets called when the user drags the button
	     * @param {Event} event
	     * @private
	     */
	  }, {
	    key: '_onButtonMove',
	    value: function _onButtonMove(event) {
	      event.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(event);
	      var diff = mousePosition.clone().subtract(this._initialMousePosition);
	      var newButtonPosition = this._initialButtonPosition + diff.x;
	
	      this._setButtonPosition(newButtonPosition);
	    }
	
	    /**
	     * Sets the button position to the given value
	     * @param {Number} newButtonPosition
	     * @private
	     */
	  }, {
	    key: '_setButtonPosition',
	    value: function _setButtonPosition(newButtonPosition) {
	      // Clamp button position
	      newButtonPosition = Math.max(0, newButtonPosition);
	      newButtonPosition = Math.min(newButtonPosition, this._values.button.scrollableWidth);
	
	      // Set button position
	      this._buttonPosition = newButtonPosition;
	      this._dom.button.style.left = this._buttonPosition + 'px';
	
	      // Update list scroll position
	      var progress = newButtonPosition / this._values.button.scrollableWidth;
	      var scrollPosition = this._values.list.scrollableWidth * progress;
	      this._list.scrollLeft = scrollPosition;
	    }
	
	    /**
	     * Gets called when the user releases the button
	     * @private
	     */
	  }, {
	    key: '_onButtonUp',
	    value: function _onButtonUp() {
	      this._isDragging = false;
	
	      document.removeEventListener('mousemove', this._onButtonMove);
	      document.removeEventListener('touchmove', this._onButtonMove);
	      document.removeEventListener('mouseup', this._onButtonUp);
	      document.removeEventListener('touchend', this._onButtonUp);
	    }
	
	    /**
	     * Gets called when the user scrolls the list
	     * @private
	     */
	  }, {
	    key: '_onListScroll',
	    value: function _onListScroll() {
	      if (this._isDragging) return;
	
	      var listScrollWidth = this._list.scrollWidth - this._list.offsetWidth;
	      var listScrollPosition = this._list.scrollLeft;
	
	      var backgroundScrollWidth = this._dom.background.offsetWidth - this._dom.button.offsetWidth;
	      var progress = listScrollPosition / listScrollWidth;
	
	      this._buttonPosition = backgroundScrollWidth * progress;
	      this._dom.button.style.left = this._buttonPosition + 'px';
	    }
	
	    /**
	     * Resizes the button to represent the visible size of the container
	     * @private
	     */
	  }, {
	    key: '_resizeButton',
	    value: function _resizeButton() {
	      var listScrollWidth = this._list.scrollWidth;
	      var listWidth = this._list.offsetWidth;
	
	      this._buttonWidth = listWidth / listScrollWidth * listWidth;
	      this._dom.button.style.width = this._buttonWidth + 'px';
	    }
	
	    /**
	     * Appends the DOM elements to the container
	     * @private
	     */
	  }, {
	    key: '_appendDOM',
	    value: function _appendDOM() {
	      var background = document.createElement('div');
	      _libUtils2['default'].classList(background).add('imglykit-scrollbar-background');
	      background.style.bottom = maxScrollbarWidth + 'px';
	
	      var button = document.createElement('div');
	      _libUtils2['default'].classList(button).add('imglykit-scrollbar-button');
	
	      background.appendChild(button);
	      this._container.appendChild(background);
	
	      // Container should have position: relative
	      this._container.style.position = 'relative';
	
	      // Find the list
	      this._list = this._container.querySelector('.imglykit-controls-list');
	      this._dom = { background: background, button: button };
	
	      // Resize the list and the container
	      this._list.style.height = '';
	      var listHeight = this._list.offsetHeight;
	      listHeight += maxScrollbarWidth;
	      this._container.style.height = listHeight + 'px';
	      this._list.style.height = listHeight + 'px';
	    }
	
	    /**
	     * Removes the DOM elements and event listeners
	     */
	  }, {
	    key: 'remove',
	    value: function remove() {
	      if (!this._browserSupported()) return;
	
	      this._dom.button.removeEventListener('mousedown', this._onButtonDown);
	      this._dom.button.removeEventListener('touchstart', this._onButtonDown);
	
	      this._dom.background.parentNode.removeChild(this._dom.background);
	    }
	
	    /**
	     * Checks whether scrolling is necessary
	     * @returns {Boolean}
	     * @private
	     */
	  }, {
	    key: '_isScrollingNecessary',
	    get: function get() {
	      return this._list.scrollWidth > this._list.offsetWidth;
	    }
	  }]);
	
	  return Scrollbar;
	})();
	
	exports['default'] = Scrollbar;
	module.exports = exports['default'];

/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var FiltersControl = (function (_Control) {
	  _inherits(FiltersControl, _Control);
	
	  function FiltersControl() {
	    _classCallCheck(this, FiltersControl);
	
	    _get(Object.getPrototypeOf(FiltersControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(FiltersControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-controls-list-container"> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> '; for(var identifier in it.filters) { out+=' '; var filter = it.filters[identifier]; out+=' '; var name = filter.prototype.name; out+=' '; var enabled = it.activeFilter.identifier === identifier; out+=' <li data-identifier="'+( identifier)+'" class="imglykit-controls-item-with-label';if(enabled){out+=' imglykit-controls-item-active';}out+='"> <img src="'+(it.helpers.assetPath('ui/night/filters/' + identifier + '.png'))+'" /> <div class="imglykit-controls-item-label">'+( name )+'</div> </li> '; } out+=' </ul></div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      this._availableFilters = {};
	      this._filters = {};
	
	      this._addDefaultFilters();
	
	      // Select all filters per default
	      this.selectFilters(null);
	    }
	
	    /**
	     * Renders the controls
	     * @private
	     * @internal We need to access information from the operation when
	     *           rendering, which is why we have to override this function
	     */
	  }, {
	    key: '_renderAllControls',
	    value: function _renderAllControls() {
	      this._operationExistedBefore = !!this._ui.operations.filters;
	      this._operation = this._ui.getOrCreateOperation('filters');
	
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      _get(Object.getPrototypeOf(FiltersControl.prototype), '_renderAllControls', this).apply(this, args);
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._historyItem = null;
	      this._initialFilter = this._operation.getFilter();
	      this._defaultFilter = this._operation.availableOptions.filter['default'];
	
	      var listItems = this._controls.querySelectorAll('li');
	      this._listItems = Array.prototype.slice.call(listItems);
	
	      // Listen to click events
	
	      var _loop = function (i) {
	        var listItem = _this._listItems[i];
	        listItem.addEventListener('click', function () {
	          _this._onListItemClick(listItem);
	        });
	      };
	
	      for (var i = 0; i < this._listItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Gets called when the user hits the back button
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentFilter = this._operation.getFilter();
	      if (currentFilter === this._defaultFilter) {
	        this._ui.removeOperation('filters');
	      }
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the user clicked a list item
	     * @private
	     */
	  }, {
	    key: '_onListItemClick',
	    value: function _onListItemClick(item) {
	      this._deactivateAllItems();
	
	      var identifier = item.getAttribute('data-identifier');
	      this._operation.setFilter(this._filters[identifier]);
	      this._ui.canvas.render();
	
	      _libUtils2['default'].classList(item).add('imglykit-controls-item-active');
	
	      var currentFilter = this._operation.getFilter();
	      if (currentFilter !== this._initialFilter && !this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          filter: this._initialFilter
	        }, this._operationExistedBefore);
	      }
	    }
	
	    /**
	     * Deactivates all list items
	     * @private
	     */
	  }, {
	    key: '_deactivateAllItems',
	    value: function _deactivateAllItems() {
	      for (var i = 0; i < this._listItems.length; i++) {
	        var listItem = this._listItems[i];
	        _libUtils2['default'].classList(listItem).remove('imglykit-controls-item-active');
	      }
	    }
	
	    /**
	     * Registers all the known filters
	     * @private
	     */
	  }, {
	    key: '_addDefaultFilters',
	    value: function _addDefaultFilters() {
	      this.addFilter(__webpack_require__(46));
	      this.addFilter(__webpack_require__(70));
	      this.addFilter(__webpack_require__(71));
	      this.addFilter(__webpack_require__(72));
	      this.addFilter(__webpack_require__(73));
	      this.addFilter(__webpack_require__(66));
	      this.addFilter(__webpack_require__(59));
	      this.addFilter(__webpack_require__(78));
	      this.addFilter(__webpack_require__(63));
	      this.addFilter(__webpack_require__(67));
	      this.addFilter(__webpack_require__(64));
	      this.addFilter(__webpack_require__(85));
	      this.addFilter(__webpack_require__(60));
	      this.addFilter(__webpack_require__(61));
	      this.addFilter(__webpack_require__(74));
	      this.addFilter(__webpack_require__(81));
	      this.addFilter(__webpack_require__(80));
	      this.addFilter(__webpack_require__(79));
	      this.addFilter(__webpack_require__(65));
	      this.addFilter(__webpack_require__(68));
	      this.addFilter(__webpack_require__(62));
	      this.addFilter(__webpack_require__(84));
	      this.addFilter(__webpack_require__(77));
	      this.addFilter(__webpack_require__(75));
	      this.addFilter(__webpack_require__(69));
	      this.addFilter(__webpack_require__(76));
	      this.addFilter(__webpack_require__(83));
	      this.addFilter(__webpack_require__(58));
	      this.addFilter(__webpack_require__(82));
	    }
	
	    /**
	     * Registers the given filter
	     * @param  {class} filter
	     * @private
	     */
	  }, {
	    key: 'addFilter',
	    value: function addFilter(filter) {
	      this._availableFilters[filter.identifier] = filter;
	    }
	
	    /**
	     * Selects the filters
	     * @param {Selector} selector
	     */
	  }, {
	    key: 'selectFilters',
	    value: function selectFilters(selector) {
	      this._filters = {};
	
	      var filterIdentifiers = Object.keys(this._availableFilters);
	
	      var selectedFilters = _libUtils2['default'].select(filterIdentifiers, selector);
	      for (var i = 0; i < selectedFilters.length; i++) {
	        var identifier = selectedFilters[i];
	        this._filters[identifier] = this._availableFilters[identifier];
	      }
	
	      if (this._active) {
	        this._renderControls();
	      }
	    }
	
	    /**
	     * The data that is available to the template
	     * @type {Object}
	     * @override
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      return {
	        filters: this._filters,
	        activeFilter: this._operation.getFilter()
	      };
	    }
	  }]);
	
	  return FiltersControl;
	})(_control2['default']);
	
	FiltersControl.prototype.identifier = 'filters';
	
	exports['default'] = FiltersControl;
	module.exports = exports['default'];

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _baseHelpers = __webpack_require__(88);
	
	var _baseHelpers2 = _interopRequireDefault(_baseHelpers);
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libScrollbar = __webpack_require__(94);
	
	var _libScrollbar2 = _interopRequireDefault(_libScrollbar);
	
	/**
	 * To create an {@link ImglyKit.NightUI.Control} class of your own, call
	 * this method and provide instance properties and functions.
	 * @function
	 */
	
	var _libExtend = __webpack_require__(24);
	
	var _libExtend2 = _interopRequireDefault(_libExtend);
	
	var Control = (function (_EventEmitter) {
	  _inherits(Control, _EventEmitter);
	
	  function Control(kit, ui, operation) {
	    _classCallCheck(this, Control);
	
	    _get(Object.getPrototypeOf(Control.prototype), 'constructor', this).call(this);
	
	    this._kit = kit;
	    this._ui = ui;
	    this._operation = operation;
	    this._helpers = new _baseHelpers2['default'](this._kit, this._ui, this._ui.options);
	    this._partialTemplates = {
	      doneButton: function(it
	/**/) {
	var out='<div class="imglykit-controls-button imglykit-controls-done"> <img src="'+(it.helpers.assetPath('ui/night/buttons/done.png') )+'" /> <div class="imglykit-controls-done-highlighted"> <img src="'+(it.helpers.assetPath('ui/night/buttons/done-highlighted.png') )+'" /> </div></div>';return out;
	}
	    };
	
	    this._template = function(it
	/**/) {
	var out='<div class="imglykit-controls-'+(it.identifier)+'"> <div class="imglykit-controls-button imglykit-controls-back"> <img src="'+(it.helpers.assetPath('ui/night/buttons/back.png') )+'" /> </div> '+(it.partials.control)+'</div>';return out;
	};
	    this._active = false;
	    this._historyItem = null;
	
	    this.init();
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  /**
	   * Sets the containers that the control will be rendered to
	   * @param {DOMElement} controlsContainer
	   * @param {DOMElement} canvasControlsContainer
	   */
	
	  _createClass(Control, [{
	    key: 'setContainers',
	    value: function setContainers(controlsContainer, canvasControlsContainer) {
	      this._controlsContainer = controlsContainer;
	      this._canvasControlsContainer = canvasControlsContainer;
	    }
	
	    /**
	     * The entry point for this control
	     */
	  }, {
	    key: 'init',
	    value: function init() {}
	
	    /**
	     * Resets the control to display the current values
	     */
	  }, {
	    key: 'update',
	    value: function update() {
	      this._renderAllControls();
	      this._onEnter();
	    }
	
	    /**
	     * Updates the control to represent the initial values
	     * @private
	     */
	  }, {
	    key: '_setInitialValues',
	    value: function _setInitialValues() {}
	
	    /**
	     * Renders the controls
	     * @private
	     */
	  }, {
	    key: '_renderAllControls',
	    value: function _renderAllControls() {
	      this._renderControls();
	      this._renderCanvasControls();
	      this._initScrollbar();
	
	      this._handleBackAndDoneButtons();
	      this._enableCanvasControls();
	    }
	
	    /**
	     * Renders the controls
	     * @private
	     */
	  }, {
	    key: '_renderControls',
	    value: function _renderControls() {
	      if (typeof this._controlsTemplate === 'undefined') {
	        throw new Error('Control#_renderOverviewControls: Control needs to define this._controlsTemplate.');
	      }
	
	      // Render the template
	      var html = this._template(this._context);
	
	      if (typeof this._controls !== 'undefined' && this._controls.parentNode !== null) {
	        this._controls.parentNode.removeChild(this._controls);
	      }
	
	      // Create a wrapper
	      this._controls = document.createElement('div');
	      this._controls.innerHTML = html;
	
	      // Append to DOM
	      this._controlsContainer.appendChild(this._controls);
	    }
	
	    /**
	     * Renders the canvas controls
	     * @private
	     */
	  }, {
	    key: '_renderCanvasControls',
	    value: function _renderCanvasControls() {
	      if (typeof this._canvasControlsTemplate === 'undefined') {
	        return; // Canvas controls are optional
	      }
	
	      // Render the template
	      var html = this._canvasControlsTemplate(this._context);
	
	      if (typeof this._canvasControls !== 'undefined' && this._canvasControls.parentNode !== null) {
	        this._canvasControls.parentNode.removeChild(this._canvasControls);
	      }
	
	      // Create a wrapper
	      this._canvasControls = document.createElement('div');
	      this._canvasControls.innerHTML = html;
	
	      // Append to DOM
	      this._canvasControlsContainer.appendChild(this._canvasControls);
	    }
	
	    /**
	     * Initializes the custom scrollbar
	     * @private
	     */
	  }, {
	    key: '_initScrollbar',
	    value: function _initScrollbar() {
	      var list = this._controls.querySelector('.imglykit-controls-list');
	      if (list) {
	        this._scrollbar = new _libScrollbar2['default'](list.parentNode);
	      }
	    }
	
	    /**
	     * Removes the controls from the DOM
	     * @private
	     */
	  }, {
	    key: '_removeControls',
	    value: function _removeControls() {
	      this._controls.parentNode.removeChild(this._controls);
	      if (this._canvasControls) {
	        this._canvasControls.parentNode.removeChild(this._canvasControls);
	      }
	
	      if (this._scrollbar) this._scrollbar.remove();
	    }
	
	    /**
	     * Handles the back and done buttons
	     * @private
	     */
	  }, {
	    key: '_handleBackAndDoneButtons',
	    value: function _handleBackAndDoneButtons() {
	      // Back button
	      this._backButton = this._controls.querySelector('.imglykit-controls-back');
	      if (this._backButton) {
	        this._backButton.addEventListener('click', this._onBackButtonClick.bind(this));
	      }
	
	      // Done button
	      this._doneButton = this._controls.querySelector('.imglykit-controls-done');
	      if (this._doneButton) {
	        this._doneButton.addEventListener('click', this._onDoneButtonClick.bind(this));
	      }
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @private
	     */
	  }, {
	    key: '_onBackButtonClick',
	    value: function _onBackButtonClick() {
	      this._onBack();
	      this.emit('back');
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @private
	     */
	  }, {
	    key: '_onDoneButtonClick',
	    value: function _onDoneButtonClick() {
	      this._onDone();
	      this.emit('back');
	    }
	
	    /**
	     * Highlights the done button
	     * @private
	     */
	  }, {
	    key: '_highlightDoneButton',
	    value: function _highlightDoneButton() {
	      if (!this._doneButton) return;
	      _libUtils2['default'].classList(this._doneButton).add('highlighted');
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @internal Used by the SDK, don't override.
	     */
	  }, {
	    key: 'enter',
	    value: function enter() {
	      this._active = true;
	
	      if (typeof this._canvasControlsTemplate !== 'undefined') {
	        this._ui.hideZoom();
	      }
	
	      this._renderAllControls();
	      this._onEnter();
	      this._setInitialValues();
	    }
	
	    /**
	     * Gets called when this control is deactivated
	     * @internal Used by the SDK, don't override.
	     */
	  }, {
	    key: 'leave',
	    value: function leave() {
	      this._active = false;
	
	      this._ui.showZoom();
	
	      this._removeControls();
	      this._disableCanvasControls();
	      this._onLeave();
	    }
	  }, {
	    key: '_enableCanvasControls',
	    value: function _enableCanvasControls() {
	      if (typeof this._canvasControlsTemplate === 'undefined') {
	        return;
	      }
	      _libUtils2['default'].classList(this._canvasControlsContainer).remove('imglykit-canvas-controls-disabled');
	    }
	  }, {
	    key: '_disableCanvasControls',
	    value: function _disableCanvasControls() {
	      if (typeof this._canvasControlsTemplate === 'undefined') {
	        return;
	      }
	      _libUtils2['default'].classList(this._canvasControlsContainer).add('imglykit-canvas-controls-disabled');
	    }
	
	    // Protected methods
	
	    /**
	     * Gets called when this control is activated.
	     * @protected
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {}
	
	    /**
	     * Gets called when this control is deactivated
	     * @protected
	     */
	  }, {
	    key: '_onLeave',
	    value: function _onLeave() {}
	
	    /**
	     * Gets called when the back button has been clicked
	     * @protected
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {}
	
	    /**
	     * Gets called when the done button has been clicked
	     * @protected
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {}
	
	    /**
	     * Gets called when the zoom level has been changed while
	     * this control is active
	     */
	  }, {
	    key: 'onZoom',
	    value: function onZoom() {}
	
	    /**
	     * The data that is available to the template
	     * @type {Object}
	     */
	  }, {
	    key: '_context',
	    get: function get() {
	      var context = this.context;
	
	      context = _libUtils2['default'].extend(context, {
	        helpers: this._helpers,
	        identifier: this.identifier
	      });
	
	      // Render partials before rendering control
	      context.partials = {};
	      for (var _name in this._partialTemplates) {
	        var template = this._partialTemplates[_name];
	        var partialContext = _libUtils2['default'].extend({}, context, template.additionalContext || {});
	        context.partials[_name] = template(partialContext);
	      }
	      context.partials.control = this._controlsTemplate(context);
	
	      return context;
	    }
	
	    /**
	     * The data that is available to the template
	     * @abstract
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      return {};
	    }
	  }]);
	
	  return Control;
	})(_libEventEmitter2['default']);
	
	Control.prototype.identifier = null;
	Control.extend = _libExtend2['default'];
	
	exports['default'] = Control;
	module.exports = exports['default'];

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var RotationControl = (function (_Control) {
	  _inherits(RotationControl, _Control);
	
	  function RotationControl() {
	    _classCallCheck(this, RotationControl);
	
	    _get(Object.getPrototypeOf(RotationControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(RotationControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> <li data-degrees="-90"> <img src="'+(it.helpers.assetPath('ui/night/rotation/left.png'))+'" /> </li> <li data-degrees="90"> <img src="'+(it.helpers.assetPath('ui/night/rotation/right.png'))+'" /> </li> </ul></div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	    }
	
	    /**
	     * Gets called when this control is activated
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._historyItem = null;
	
	      this._operationExistedBefore = !!this._ui.operations.rotation;
	      this._operation = this._ui.getOrCreateOperation('rotation');
	      this._operation.dirty = true;
	      this._cropOperation = this._ui.operations.crop;
	
	      this._initialDegrees = this._operation.getDegrees();
	
	      var listItems = this._controls.querySelectorAll('li');
	      if (this._cropOperation) {
	        if (!this._initialStart && !this._initialEnd) {
	          // Store initial settings for 'back' and 'done' buttons
	          this._initialStart = this._cropOperation.getStart().clone();
	          this._initialEnd = this._cropOperation.getEnd().clone();
	        }
	      }
	      this._listItems = Array.prototype.slice.call(listItems);
	
	      // Listen to click events
	
	      var _loop = function (i) {
	        var listItem = _this._listItems[i];
	        listItem.addEventListener('click', function () {
	          _this._onListItemClick(listItem);
	        });
	      };
	
	      for (var i = 0; i < this._listItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Gets called when the given item has been clicked
	     * @param {DOMObject} item
	     * @private
	     */
	  }, {
	    key: '_onListItemClick',
	    value: function _onListItemClick(item) {
	      var degrees = item.getAttribute('data-degrees');
	      degrees = parseInt(degrees, 10);
	
	      var currentDegrees = this._operation.getDegrees();
	
	      if (!this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          degrees: this._initialDegrees
	        }, this._operationExistedBefore);
	      }
	
	      this._rotateCrop(degrees);
	      this._operation.setDegrees(currentDegrees + degrees);
	      this._ui.canvas.zoomToFit();
	    }
	
	    /**
	     * Rotates the current crop options by the given degrees
	     * @param {Number} degrees
	     * @private
	     */
	  }, {
	    key: '_rotateCrop',
	    value: function _rotateCrop(degrees) {
	      if (!this._cropOperation) return;
	
	      var start = this._cropOperation.getStart().clone();
	      var end = this._cropOperation.getEnd().clone();
	
	      var _start = start.clone();
	      switch (degrees) {
	        case 90:
	          start = new _libMathVector22['default'](1.0 - end.y, _start.x);
	          end = new _libMathVector22['default'](1.0 - _start.y, end.x);
	          break;
	        case -90:
	          start = new _libMathVector22['default'](_start.y, 1.0 - end.x);
	          end = new _libMathVector22['default'](end.y, 1.0 - _start.x);
	          break;
	      }
	
	      this._cropOperation.set({ start: start, end: end });
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentDegrees = this._operation.getDegrees();
	      if (currentDegrees === 0) {
	        this._ui.removeOperation('rotation');
	      }
	    }
	  }]);
	
	  return RotationControl;
	})(_control2['default']);
	
	RotationControl.prototype.identifier = 'rotation';
	
	exports['default'] = RotationControl;
	module.exports = exports['default'];

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var FlipControl = (function (_Control) {
	  _inherits(FlipControl, _Control);
	
	  function FlipControl() {
	    _classCallCheck(this, FlipControl);
	
	    _get(Object.getPrototypeOf(FlipControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(FlipControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> <li data-direction="horizontal"> <img src="'+(it.helpers.assetPath('ui/night/flip/horizontal.png'))+'" /> </li> <li data-direction="vertical"> <img src="'+(it.helpers.assetPath('ui/night/flip/vertical.png'))+'" /> </li> </ul></div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	    }
	
	    /**
	     * Gets called when this control is activated
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._historyItem = null;
	      this._operationExistedBefore = !!this._ui.operations.flip;
	      this._operation = this._ui.getOrCreateOperation('flip');
	
	      this._initialHorizontal = this._operation.getHorizontal();
	      this._initialVertical = this._operation.getVertical();
	
	      var listItems = this._controls.querySelectorAll('li');
	      this._listItems = Array.prototype.slice.call(listItems);
	
	      // Listen to click events
	
	      var _loop = function (i) {
	        var listItem = _this._listItems[i];
	        listItem.addEventListener('click', function () {
	          _this._onListItemClick(listItem);
	        });
	
	        var direction = listItem.getAttribute('data-direction');
	        if (direction === 'horizontal' && _this._operation.getHorizontal()) {
	          _this._toggleItem(listItem, true);
	        } else if (direction === 'vertical' && _this._operation.getVertical()) {
	          _this._toggleItem(listItem, true);
	        }
	      };
	
	      for (var i = 0; i < this._listItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Gets called when the user clicked a list item
	     * @private
	     */
	  }, {
	    key: '_onListItemClick',
	    value: function _onListItemClick(item) {
	      var direction = item.getAttribute('data-direction');
	      var active = false;
	
	      var currentHorizontal = this._operation.getHorizontal();
	      var currentVertical = this._operation.getVertical();
	
	      if (direction === 'horizontal') {
	        this._operation.setHorizontal(!currentHorizontal);
	        currentHorizontal = !currentHorizontal;
	        this._ui.canvas.render();
	        active = !currentHorizontal;
	      } else if (direction === 'vertical') {
	        this._operation.setVertical(!currentVertical);
	        currentVertical = !currentVertical;
	        this._ui.canvas.render();
	        active = !currentVertical;
	      }
	
	      if ((this._initialVertical !== currentVertical || this._initialHorizontal !== currentHorizontal) && !this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          vertical: this._initialVertical,
	          horizontal: this._initialHorizontal
	        }, this._operationExistedBefore);
	      }
	
	      this._toggleItem(item, active);
	    }
	
	    /**
	     * Toggles the active state of the given item
	     * @param {DOMElement} item
	     * @param {Boolean} active
	     * @private
	     */
	  }, {
	    key: '_toggleItem',
	    value: function _toggleItem(item, active) {
	      var activeClass = 'imglykit-controls-item-active';
	      if (active) {
	        _libUtils2['default'].classList(item).add(activeClass);
	      } else {
	        _libUtils2['default'].classList(item).remove(activeClass);
	      }
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentVertical = this._operation.getVertical();
	      var currentHorizontal = this._operation.getHorizontal();
	
	      if (!currentVertical && !currentHorizontal) {
	        this._ui.removeOperation('flip');
	      }
	
	      this._ui.canvas.render();
	    }
	  }]);
	
	  return FlipControl;
	})(_control2['default']);
	
	FlipControl.prototype.identifier = 'flip';
	
	exports['default'] = FlipControl;
	module.exports = exports['default'];

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libSlider = __webpack_require__(100);
	
	var _libSlider2 = _interopRequireDefault(_libSlider);
	
	var BrightnessControl = (function (_Control) {
	  _inherits(BrightnessControl, _Control);
	
	  function BrightnessControl() {
	    _classCallCheck(this, BrightnessControl);
	
	    _get(Object.getPrototypeOf(BrightnessControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(BrightnessControl, [{
	    key: 'init',
	
	    /**
	     * The entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> '+(it.partials.slider)+'</div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	      this._partialTemplates.slider = _libSlider2['default'].template;
	
	      this._onUpdate = this._onUpdate.bind(this);
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      this._historyItem = null;
	      this._operationExistedBefore = !!this._ui.operations.brightness;
	      this._operation = this._ui.getOrCreateOperation('brightness');
	
	      // Initially set value
	      var brightness = this._operation.getBrightness();
	      this._initialBrightness = brightness;
	
	      var sliderElement = this._controls.querySelector('.imglykit-slider');
	      this._slider = new _libSlider2['default'](sliderElement, {
	        minValue: -1,
	        maxValue: 1,
	        defaultValue: brightness
	      });
	      this._slider.on('update', this._onUpdate);
	      this._slider.setValue(brightness);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentBrightness = this._operation.getBrightness();
	
	      if (currentBrightness === 1.0) {
	        this._ui.removeOperation('brightness');
	      }
	
	      this._ui.canvas.render();
	      this._slider = null;
	    }
	
	    /**
	     * Gets called when the value has been updated
	     * @override
	     */
	  }, {
	    key: '_onUpdate',
	    value: function _onUpdate(value) {
	      this._operation.setBrightness(value);
	      this._ui.canvas.render();
	
	      if (!this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          brightness: this._initialBrightness
	        }, this._operationExistedBefore);
	      }
	    }
	  }]);
	
	  return BrightnessControl;
	})(_control2['default']);
	
	BrightnessControl.prototype.identifier = 'brightness';
	
	exports['default'] = BrightnessControl;
	module.exports = exports['default'];

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var Slider = (function (_EventEmitter) {
	  _inherits(Slider, _EventEmitter);
	
	  function Slider(element, options) {
	    _classCallCheck(this, Slider);
	
	    _get(Object.getPrototypeOf(Slider.prototype), 'constructor', this).call(this);
	
	    this._element = element;
	    this._options = _libUtils2['default'].defaults(options, {
	      minValue: 0,
	      maxValue: 1,
	      defaultValue: 0
	    });
	
	    this._value = this._options.defaultValue;
	
	    this._sliderElement = this._element.querySelector('.imglykit-slider-slider');
	    this._dotElement = this._element.querySelector('.imglykit-slider-dot');
	    this._centerDotElement = this._element.querySelector('.imglykit-slider-center-dot');
	    this._fillElement = this._element.querySelector('.imglykit-slider-fill');
	    this._backgroundElement = this._element.querySelector('.imglykit-slider-background');
	
	    // Mouse event callbacks bound to class context
	    this._onMouseDown = this._onMouseDown.bind(this);
	    this._onMouseMove = this._onMouseMove.bind(this);
	    this._onMouseUp = this._onMouseUp.bind(this);
	    this._onCenterDotClick = this._onCenterDotClick.bind(this);
	    this._onBackgroundClick = this._onBackgroundClick.bind(this);
	
	    this._backgroundElement.addEventListener('click', this._onBackgroundClick);
	    this._fillElement.addEventListener('click', this._onBackgroundClick);
	
	    this._handleDot();
	  }
	
	  /**
	   * The partial template string
	   * @type {String}
	   */
	
	  _createClass(Slider, [{
	    key: 'setValue',
	
	    /**
	     * Sets the given value
	     * @param {Number} value
	     */
	    value: function setValue(value) {
	      this._value = value;
	
	      var _options = this._options;
	      var maxValue = _options.maxValue;
	      var minValue = _options.minValue;
	
	      // Calculate the X position
	      var valueRange = maxValue - minValue;
	      var percentage = (value - minValue) / valueRange;
	      var sliderWidth = this._sliderElement.offsetWidth;
	      this._setX(sliderWidth * percentage);
	    }
	
	    /**
	     * Sets the slider position to the given X value and resizes
	     * the fill div
	     * @private
	     */
	  }, {
	    key: '_setX',
	    value: function _setX(x) {
	      this._xPosition = x;
	      this._dotElement.style.left = x + 'px';
	
	      // X position relative to center to simplify calculations
	      var halfSliderWidth = this._sliderElement.offsetWidth / 2;
	      var relativeX = x - halfSliderWidth;
	
	      // Update style
	      this._fillElement.style.width = Math.abs(relativeX) + 'px';
	      if (relativeX < 0) {
	        this._fillElement.style.left = halfSliderWidth - Math.abs(relativeX) + 'px';
	      } else {
	        this._fillElement.style.left = halfSliderWidth + 'px';
	      }
	    }
	
	    /**
	     * Handles the dot dragging
	     * @private
	     */
	  }, {
	    key: '_handleDot',
	    value: function _handleDot() {
	      this._dotElement.addEventListener('mousedown', this._onMouseDown);
	      this._dotElement.addEventListener('touchstart', this._onMouseDown);
	
	      if (this._centerDotElement) {
	        this._centerDotElement.addEventListener('click', this._onCenterDotClick);
	      }
	    }
	
	    /**
	     * Gets called when the user clicks the center button. Resets to default
	     * settings.
	     * @private
	     */
	  }, {
	    key: '_onCenterDotClick',
	    value: function _onCenterDotClick() {
	      this.setValue(this._options.defaultValue);
	      this.emit('update', this._value);
	    }
	
	    /**
	     * Gets called when the user clicks on the slider background
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onBackgroundClick',
	    value: function _onBackgroundClick(e) {
	      var position = _libUtils2['default'].getEventPosition(e);
	      var sliderOffset = this._sliderElement.getBoundingClientRect();
	      sliderOffset = new _libMathVector22['default'](sliderOffset.left, sliderOffset.y);
	
	      var relativePosition = position.clone().subtract(sliderOffset);
	
	      this._setX(relativePosition.x);
	      this._updateValue();
	    }
	
	    /**
	     * Gets called when the user presses a mouse button on the slider dot
	     * @private
	     */
	  }, {
	    key: '_onMouseDown',
	    value: function _onMouseDown(e) {
	      if (e.type === 'mousedown' && e.button !== 0) return;
	      e.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	
	      document.addEventListener('mousemove', this._onMouseMove);
	      document.addEventListener('touchmove', this._onMouseMove);
	
	      document.addEventListener('mouseup', this._onMouseUp);
	      document.addEventListener('touchend', this._onMouseUp);
	
	      // Remember initial position
	      var dotPosition = this._dotElement.getBoundingClientRect();
	      var sliderPosition = this._sliderElement.getBoundingClientRect();
	
	      this._initialSliderX = dotPosition.left - sliderPosition.left;
	      this._initialMousePosition = mousePosition;
	    }
	
	    /**
	     * Gets called when the user drags the mouse
	     * @private
	     */
	  }, {
	    key: '_onMouseMove',
	    value: function _onMouseMove(e) {
	      e.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var mouseDiff = mousePosition.subtract(this._initialMousePosition);
	
	      // Add half width of the dot for negative margin compensation
	      var halfDotWidth = this._dotElement.offsetWidth * 0.5;
	      var newSliderX = this._initialSliderX + mouseDiff.x + halfDotWidth;
	
	      // X boundaries
	      var sliderWidth = this._sliderElement.offsetWidth;
	      newSliderX = Math.max(0, Math.min(newSliderX, sliderWidth));
	
	      this._setX(newSliderX);
	      this._updateValue();
	    }
	
	    /**
	     * Updates the value using the slider position
	     * @private
	     */
	  }, {
	    key: '_updateValue',
	    value: function _updateValue() {
	      var sliderWidth = this._sliderElement.offsetWidth;
	
	      // Calculate the new value
	      var _options2 = this._options;
	      var minValue = _options2.minValue;
	      var maxValue = _options2.maxValue;
	
	      var percentage = this._xPosition / sliderWidth;
	      var value = minValue + (maxValue - minValue) * percentage;
	      this.emit('update', value);
	    }
	
	    /**
	     * Gets called when the user does not press the mouse button anymore
	     * @private
	     */
	  }, {
	    key: '_onMouseUp',
	    value: function _onMouseUp() {
	      document.removeEventListener('mousemove', this._onMouseMove);
	      document.removeEventListener('touchmove', this._onMouseMove);
	
	      document.removeEventListener('mouseup', this._onMouseUp);
	      document.removeEventListener('touchend', this._onMouseUp);
	    }
	  }], [{
	    key: 'template',
	    get: function get() {
	      return function(it
	/**/) {
	var out='<div class="imglykit-slider" id="'+((typeof it.id === "undefined"?'':it.id))+'"> <div class="imglykit-slider-minus"> <img src="'+(it.helpers.assetPath('ui/night/slider/minus.png') )+'" /> </div> <div class="imglykit-slider-slider"> <div class="imglykit-slider-content"> <div class="imglykit-slider-background"></div> <div class="imglykit-slider-fill"></div> <div class="imglykit-slider-center-dot"></div> <div class="imglykit-slider-dot"></div> </div> </div> <div class="imglykit-slider-plus"> <img src="'+(it.helpers.assetPath('ui/night/slider/plus.png') )+'" /> </div></div>';return out;
	};
	    }
	  }]);
	
	  return Slider;
	})(_libEventEmitter2['default']);
	
	exports['default'] = Slider;
	module.exports = exports['default'];

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libSlider = __webpack_require__(100);
	
	var _libSlider2 = _interopRequireDefault(_libSlider);
	
	var ContrastControl = (function (_Control) {
	  _inherits(ContrastControl, _Control);
	
	  function ContrastControl() {
	    _classCallCheck(this, ContrastControl);
	
	    _get(Object.getPrototypeOf(ContrastControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(ContrastControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> '+(it.partials.slider)+'</div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	      this._partialTemplates.slider = _libSlider2['default'].template;
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      this._historyItem = null;
	      this._operationExistedBefore = !!this._ui.operations.contrast;
	      this._operation = this._ui.getOrCreateOperation('contrast');
	
	      // Initially set value
	      var contrast = this._operation.getContrast();
	      this._initialContrast = contrast;
	
	      var sliderElement = this._controls.querySelector('.imglykit-slider');
	      this._slider = new _libSlider2['default'](sliderElement, {
	        minValue: 0,
	        maxValue: 2,
	        defaultValue: contrast
	      });
	      this._slider.on('update', this._onUpdate.bind(this));
	      this._slider.setValue(this._initialContrast);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentContrast = this._operation.getContrast();
	
	      if (currentContrast === 1.0) {
	        this._ui.removeOperation('contrast');
	      }
	
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the value has been updated
	     * @override
	     */
	  }, {
	    key: '_onUpdate',
	    value: function _onUpdate(value) {
	      this._operation.setContrast(value);
	      this._ui.canvas.render();
	
	      var currentContrast = this._operation.getContrast();
	      if (this._initialContrast !== currentContrast && !this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          contrast: this._initialContrast
	        }, this._operationExistedBefore);
	      }
	    }
	  }]);
	
	  return ContrastControl;
	})(_control2['default']);
	
	ContrastControl.prototype.identifier = 'contrast';
	
	exports['default'] = ContrastControl;
	module.exports = exports['default'];

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libSlider = __webpack_require__(100);
	
	var _libSlider2 = _interopRequireDefault(_libSlider);
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var SaturationControl = (function (_Control) {
	  _inherits(SaturationControl, _Control);
	
	  function SaturationControl() {
	    _classCallCheck(this, SaturationControl);
	
	    _get(Object.getPrototypeOf(SaturationControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(SaturationControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> '+(it.partials.slider)+'</div>';return out;
	};
	      this._controlsTemplate = controlsTemplate;
	      this._partialTemplates.slider = _libSlider2['default'].template;
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      this._historyItem = null;
	      this._operationExistedBefore = !!this._ui.operations.saturation;
	      this._operation = this._ui.getOrCreateOperation('saturation');
	
	      // Initially set value
	      var saturation = this._operation.getSaturation();
	      this._initialSaturation = saturation;
	
	      var sliderElement = this._controls.querySelector('.imglykit-slider');
	      this._slider = new _libSlider2['default'](sliderElement, {
	        minValue: 0,
	        maxValue: 2,
	        defaultValue: saturation
	      });
	      this._slider.on('update', this._onUpdate.bind(this));
	      this._slider.setValue(this._initialSaturation);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      var currentSaturation = this._operation.getSaturation();
	
	      if (currentSaturation === 1) {
	        this._ui.removeOperation('saturation');
	      }
	
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the value has been updated
	     * @override
	     */
	  }, {
	    key: '_onUpdate',
	    value: function _onUpdate(value) {
	      this._operation.setSaturation(value);
	      this._ui.canvas.render();
	
	      var currentSaturation = this._operation.getSaturation();
	      if (this._initialSaturation !== currentSaturation && !this._historyItem) {
	        this._historyItem = this._ui.addHistory(this._operation, {
	          saturation: this._initialSaturation
	        }, this._operationExistedBefore);
	      }
	    }
	  }]);
	
	  return SaturationControl;
	})(_control2['default']);
	
	SaturationControl.prototype.identifier = 'saturation';
	
	exports['default'] = SaturationControl;
	module.exports = exports['default'];

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var CropControl = (function (_Control) {
	  _inherits(CropControl, _Control);
	
	  function CropControl() {
	    _classCallCheck(this, CropControl);
	
	    _get(Object.getPrototypeOf(CropControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(CropControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      this._availableRatios = {};
	      this._ratios = {};
	
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> '; for(var identifier in it.ratios) { out+=' '; var ratio = it.ratios[identifier]; out+=' '; var enabled = ratio.selected; out+=' <li data-identifier="'+( identifier)+'" data-ratio="'+( ratio.ratio)+'"';if(enabled){out+=' data-selected';}out+='> <img src="'+(it.helpers.assetPath('ui/night/crop/' + identifier + '.png'))+'" /> </li> '; } out+=' </ul></div>'+(it.partials.doneButton);return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-crop-container"> <div class="imglykit-canvas-crop-top"> <div class="imglykit-canvas-crop-top-left"></div> <div class="imglykit-canvas-crop-top-center"></div> <div class="imglykit-canvas-crop-top-right"></div> </div> <div class="imglykit-canvas-crop-center"> <div class="imglykit-canvas-crop-center-left"></div> <div class="imglykit-canvas-crop-center-center"> <div class="imglykit-canvas-crop-knobs"> <div data-corner="top-left"></div> <div data-corner="top-right"></div> <div data-corner="bottom-left"></div> <div data-corner="bottom-right"></div> </div> </div> <div class="imglykit-canvas-crop-center-right"></div> </div> <div class="imglykit-canvas-crop-bottom"> <div class="imglykit-canvas-crop-bottom-left"></div> <div class="imglykit-canvas-crop-bottom-center"></div> <div class="imglykit-canvas-crop-bottom-right"></div> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      // Mouse event callbacks bound to the class context
	      this._onKnobDown = this._onKnobDown.bind(this);
	      this._onKnobDrag = this._onKnobDrag.bind(this);
	      this._onKnobUp = this._onKnobUp.bind(this);
	      this._onCenterDown = this._onCenterDown.bind(this);
	      this._onCenterDrag = this._onCenterDrag.bind(this);
	      this._onCenterUp = this._onCenterUp.bind(this);
	
	      this._addDefaultRatios();
	
	      // Select all ratios per default
	      this.selectRatios(null);
	    }
	
	    /**
	     * Selects the ratios
	     * @param {Selector} selector
	     */
	  }, {
	    key: 'selectRatios',
	    value: function selectRatios(selector) {
	      this._ratios = {};
	
	      var ratioIdentifiers = Object.keys(this._availableRatios);
	
	      var selectedRatios = _libUtils2['default'].select(ratioIdentifiers, selector);
	      for (var i = 0; i < selectedRatios.length; i++) {
	        var identifier = selectedRatios[i];
	        this._ratios[identifier] = this._availableRatios[identifier];
	      }
	
	      if (this._active) {
	        this._renderControls();
	      }
	    }
	
	    /**
	     * Adds the default ratios
	     * @private
	     */
	  }, {
	    key: '_addDefaultRatios',
	    value: function _addDefaultRatios() {
	      this.addRatio('custom', '*', true);
	      this.addRatio('square', '1');
	      this.addRatio('4-3', '1.33');
	      this.addRatio('16-9', '1.77');
	    }
	
	    /**
	     * Adds a ratio with the given identifier
	     * @param {String} identifier
	     * @param {Number} ratio
	     * @param {Boolean} selected
	     */
	  }, {
	    key: 'addRatio',
	    value: function addRatio(identifier, ratio, selected) {
	      this._availableRatios[identifier] = { ratio: ratio, selected: selected };
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      _get(Object.getPrototypeOf(CropControl.prototype), '_onEnter', this).call(this);
	
	      this._operationExistedBefore = !!this._ui.operations.crop;
	      this._operation = this._ui.getOrCreateOperation('crop');
	
	      this._defaultStart = new _libMathVector22['default'](0.1, 0.1);
	      this._defaultEnd = new _libMathVector22['default'](0.9, 0.9);
	
	      // Store initial settings for 'back' button
	      this._initialStart = this._operation.getStart().clone();
	      this._initialEnd = this._operation.getEnd().clone();
	
	      this._start = this._initialStart || this._defaultStart;
	      this._end = this._initialEnd || this._defaultEnd;
	
	      // Minimum size in pixels
	      this._minimumSize = new _libMathVector22['default'](50, 50);
	
	      this._initialZoomLevel = this._ui.canvas.zoomLevel;
	      this._ui.canvas.zoomToFit(false);
	
	      var prefix = '.imglykit-canvas-crop';
	      var container = this._canvasControls;
	      var knobsContainer = container.querySelector(prefix + '-knobs');
	
	      // Make sure we see the whole input image
	      this._operation.set({
	        start: new _libMathVector22['default'](0, 0),
	        end: new _libMathVector22['default'](1, 1)
	      });
	
	      // Find all 4 knobs
	      this._knobs = {
	        topLeft: knobsContainer.querySelector('[data-corner=top-left]'),
	        topRight: knobsContainer.querySelector('[data-corner=top-right]'),
	        bottomLeft: knobsContainer.querySelector('[data-corner=bottom-left]'),
	        bottomRight: knobsContainer.querySelector('[data-corner=bottom-right]')
	      };
	
	      // Find the div areas that affect the displayed crop size
	      this._areas = {
	        topLeft: this._canvasControls.querySelector(prefix + '-top-left'),
	        topCenter: this._canvasControls.querySelector(prefix + '-top-center'),
	        centerLeft: this._canvasControls.querySelector(prefix + '-center-left'),
	        centerCenter: this._canvasControls.querySelector(prefix + '-center-center')
	      };
	
	      this._knobsContainer = this._canvasControls.querySelector('.imglykit-canvas-crop-knobs');
	
	      this._handleControls();
	      this._handleKnobs();
	      this._handleKnobsContainer();
	
	      // Resume the rendering
	      this._ui.canvas.zoomToFit().then(function () {
	        _this._updateDOM();
	      });
	    }
	
	    /**
	     * Handles the ratio controls
	     * @private
	     */
	  }, {
	    key: '_handleControls',
	    value: function _handleControls() {
	      var _this2 = this;
	
	      var listItems = this._controls.querySelectorAll('ul > li');
	      this._ratioItems = Array.prototype.slice.call(listItems);
	
	      var _loop = function (i) {
	        var item = _this2._ratioItems[i];
	        var selected = item.getAttribute('data-selected');
	        var ratio = item.getAttribute('data-ratio');
	        var identifier = item.getAttribute('data-identifier');
	        if (typeof selected !== 'undefined' && selected !== null && !_this2._operationExistedBefore) {
	          _this2._setRatio(identifier, ratio, false);
	          _this2._selectRatio(item);
	        }
	
	        item.addEventListener('click', function (e) {
	          e.preventDefault();
	          _this2._onRatioClick(item);
	        });
	      };
	
	      for (var i = 0; i < this._ratioItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Gets called when the given ratio has been selected
	     * @param {DOMElement} item
	     * @private
	     */
	  }, {
	    key: '_onRatioClick',
	    value: function _onRatioClick(item) {
	      this._unselectAllRatios();
	      this._selectRatio(item);
	    }
	
	    /**
	     * Unselects all ratio control items
	     * @private
	     */
	  }, {
	    key: '_unselectAllRatios',
	    value: function _unselectAllRatios() {
	      for (var i = 0; i < this._ratioItems.length; i++) {
	        var item = this._ratioItems[i];
	        _libUtils2['default'].classList(item).remove('imglykit-controls-item-active');
	      }
	    }
	
	    /**
	     * Activates the given ratio control item
	     * @param {DOMElement} item
	     * @private
	     */
	  }, {
	    key: '_selectRatio',
	    value: function _selectRatio(item) {
	      _libUtils2['default'].classList(item).add('imglykit-controls-item-active');
	      var ratio = item.getAttribute('data-ratio');
	      var identifier = item.getAttribute('data-identifier');
	      this._setRatio(identifier, ratio);
	    }
	
	    /**
	     * Sets the given ratio
	     * @param {String} identifier
	     * @param {String} ratio
	     * @param {Boolean} resize
	     * @private
	     */
	  }, {
	    key: '_setRatio',
	    value: function _setRatio(identifier, ratio) {
	      var resize = arguments.length <= 2 || arguments[2] === undefined ? true : arguments[2];
	
	      var canvasSize = this._ui.canvas.size;
	      this._selectedRatio = identifier;
	
	      if (ratio === '*') {
	        this._ratio = null;
	        this._start = new _libMathVector22['default'](0.1, 0.1);
	        this._end = new _libMathVector22['default'](0.9, 0.9);
	      } else {
	        if (ratio === 'original') {
	          this._ratio = canvasSize.x / canvasSize.y;
	        } else {
	          ratio = parseFloat(ratio);
	          this._ratio = ratio;
	        }
	
	        if (resize) {
	          if (canvasSize.x / canvasSize.y <= this._ratio) {
	            this._start.x = 0.1;
	            this._end.x = 0.9;
	            var height = 1 / canvasSize.y * (canvasSize.x / this._ratio * 0.8);
	            this._start.y = (1 - height) / 2;
	            this._end.y = 1 - this._start.y;
	          } else {
	            this._start.y = 0.1;
	            this._end.y = 0.9;
	            var width = 1 / canvasSize.x * (this._ratio * canvasSize.y * 0.8);
	            this._start.x = (1 - width) / 2;
	            this._end.x = 1 - this._start.x;
	          }
	        }
	      }
	
	      this._updateDOM();
	    }
	
	    /**
	     * Updates the cropping divs for the current operation settings
	     * @private
	     */
	  }, {
	    key: '_updateDOM',
	    value: function _updateDOM() {
	      var canvasSize = this._ui.canvas.size;
	      var startAbsolute = this._start.clone().multiply(canvasSize);
	      var endAbsolute = this._end.clone().multiply(canvasSize);
	      var size = endAbsolute.clone().subtract(startAbsolute);
	
	      var top = Math.max(1, startAbsolute.y);
	      var left = Math.max(1, startAbsolute.x);
	      var width = Math.max(1, size.x);
	      var height = Math.max(1, size.y);
	
	      // widths are defined by top left and top center areas
	      this._areas.topLeft.style.width = left + 'px';
	      this._areas.topCenter.style.width = width + 'px';
	
	      // heights are defined by top left and center left areas
	      this._areas.topLeft.style.height = top + 'px';
	      this._areas.centerLeft.style.height = height + 'px';
	
	      // define height on center div to make sure the knobs are positioned
	      // correctly (bug in IE10)
	      this._knobsContainer.style.height = height + 'px';
	    }
	
	    /**
	     * Handles the knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleKnobs',
	    value: function _handleKnobs() {
	      var _this3 = this;
	
	      var _loop2 = function (identifier) {
	        var knob = _this3._knobs[identifier];
	        knob.addEventListener('mousedown', function (e) {
	          _this3._onKnobDown(e, knob);
	        });
	        knob.addEventListener('touchstart', function (e) {
	          _this3._onKnobDown(e, knob);
	        });
	      };
	
	      for (var identifier in this._knobs) {
	        _loop2(identifier);
	      }
	    }
	
	    /**
	     * Gets called when the user presses a knob
	     * @param {Event} e
	     * @param {DOMElement} knob
	     * @private
	     */
	  }, {
	    key: '_onKnobDown',
	    value: function _onKnobDown(e, knob) {
	      e.preventDefault();
	      e.stopPropagation();
	
	      this._currentKnob = knob;
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	
	      // Remember the current values
	      this._startBeforeDrag = this._start.clone();
	      this._endBeforeDrag = this._end.clone();
	
	      document.addEventListener('mousemove', this._onKnobDrag);
	      document.addEventListener('touchmove', this._onKnobDrag);
	      document.addEventListener('mouseup', this._onKnobUp);
	      document.addEventListener('touchend', this._onKnobUp);
	    }
	
	    /**
	     * Gets called whe the user drags a knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onKnobDrag',
	    value: function _onKnobDrag(e) {
	      e.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var mouseDiff = mousePosition.subtract(this._initialMousePosition);
	      var corner = this._currentKnob.getAttribute('data-corner');
	      var canvasSize = this._ui.canvas.size;
	
	      var absoluteStart = this._startBeforeDrag.clone().multiply(canvasSize);
	      var absoluteEnd = this._endBeforeDrag.clone().multiply(canvasSize);
	
	      var width = undefined,
	          height = undefined,
	          maximum = undefined,
	          minimum = undefined;
	
	      switch (corner) {
	        case 'top-left':
	          absoluteStart.add(mouseDiff);
	          maximum = absoluteEnd.clone().subtract(this._minimumSize);
	          absoluteStart.clamp(null, maximum);
	          break;
	        case 'top-right':
	          absoluteEnd.x += mouseDiff.x;
	          absoluteStart.y += mouseDiff.y;
	          absoluteEnd.x = Math.max(absoluteStart.x + this._minimumSize.x, absoluteEnd.x);
	          absoluteStart.y = Math.min(absoluteEnd.y - this._minimumSize.y, absoluteStart.y);
	          break;
	        case 'bottom-right':
	          absoluteEnd.add(mouseDiff);
	          minimum = absoluteStart.clone().add(this._minimumSize);
	          absoluteEnd.clamp(minimum);
	          break;
	        case 'bottom-left':
	          absoluteStart.x += mouseDiff.x;
	          absoluteEnd.y += mouseDiff.y;
	          absoluteStart.x = Math.min(absoluteEnd.x - this._minimumSize.x, absoluteStart.x);
	          absoluteEnd.y = Math.max(absoluteStart.y + this._minimumSize.y, absoluteEnd.y);
	          break;
	      }
	
	      this._start.copy(absoluteStart).divide(canvasSize);
	      this._end.copy(absoluteEnd).divide(canvasSize);
	
	      this._start.clamp(0, 1);
	      this._end.clamp(0, 1);
	
	      /**
	       * Calculate boundaries
	       */
	      if (this._ratio !== null) {
	        switch (corner) {
	          case 'top-left':
	            width = (this._end.x - this._start.x) * canvasSize.x;
	            height = width / this._ratio;
	            this._start.y = this._end.y - height / canvasSize.y;
	
	            if (this._start.y <= 0) {
	              this._start.y = 0;
	              height = (this._end.y - this._start.y) * canvasSize.y;
	              width = height * this._ratio;
	              this._start.x = this._end.x - width / canvasSize.x;
	            }
	            break;
	          case 'top-right':
	            width = (this._end.x - this._start.x) * canvasSize.x;
	            height = width / this._ratio;
	            this._start.y = this._end.y - height / canvasSize.y;
	
	            if (this._start.y <= 0) {
	              this._start.y = 0;
	              height = (this._end.y - this._start.y) * canvasSize.y;
	              width = height * this._ratio;
	              this._end.x = this._start.x + width / canvasSize.x;
	            }
	            break;
	          case 'bottom-right':
	            width = (this._end.x - this._start.x) * canvasSize.x;
	            height = width / this._ratio;
	            this._end.y = this._start.y + height / canvasSize.y;
	
	            // If boundaries are exceeded, calculate width by maximum height
	            if (this._end.y >= 1) {
	              this._end.y = 1;
	              height = (this._end.y - this._start.y) * canvasSize.y;
	              width = height * this._ratio;
	              this._end.x = this._start.x + width / canvasSize.x;
	            }
	            break;
	          case 'bottom-left':
	            width = (this._end.x - this._start.x) * canvasSize.x;
	            height = width / this._ratio;
	            this._end.y = this._start.y + height / canvasSize.y;
	
	            if (this._end.y >= 1) {
	              this._end.y = 1;
	              height = (this._end.y - this._start.y) * canvasSize.y;
	              width = height * this._ratio;
	              this._start.x = this._end.x - width / canvasSize.x;
	            }
	            break;
	        }
	      }
	
	      this._updateDOM();
	    }
	
	    /**
	     * Gets called whe the user releases a knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onKnobUp',
	    value: function _onKnobUp() {
	      this._currentKnob = null;
	      document.removeEventListener('mousemove', this._onKnobDrag);
	      document.removeEventListener('touchmove', this._onKnobDrag);
	      document.removeEventListener('mouseup', this._onKnobUp);
	      document.removeEventListener('touchend', this._onKnobUp);
	    }
	
	    /**
	     * Handles the center dragging
	     * @private
	     */
	  }, {
	    key: '_handleKnobsContainer',
	    value: function _handleKnobsContainer() {
	      this._knobsContainer.addEventListener('mousedown', this._onCenterDown);
	      this._knobsContainer.addEventListener('touchstart', this._onCenterDown);
	    }
	
	    /**
	     * Gets called when the user presses the center area
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onCenterDown',
	    value: function _onCenterDown(e) {
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	
	      // Remember the current values
	      this._startBeforeDrag = this._start.clone();
	      this._endBeforeDrag = this._end.clone();
	
	      document.addEventListener('mousemove', this._onCenterDrag);
	      document.addEventListener('touchmove', this._onCenterDrag);
	      document.addEventListener('mouseup', this._onCenterUp);
	      document.addEventListener('touchend', this._onCenterUp);
	    }
	
	    /**
	     * Gets called when the user presses the center area and moves his mouse
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onCenterDrag',
	    value: function _onCenterDrag(e) {
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var mouseDiff = mousePosition.subtract(this._initialMousePosition);
	      var canvasSize = this._ui.canvas.size;
	
	      // Get the crop size
	      var cropSize = this._endBeforeDrag.clone().subtract(this._startBeforeDrag);
	      var absoluteCropSize = cropSize.clone().multiply(canvasSize);
	
	      // Get the absolute initial values
	      var absoluteStart = this._startBeforeDrag.clone().multiply(canvasSize);
	      var absoluteEnd = this._endBeforeDrag.clone().multiply(canvasSize);
	
	      // Add the mouse position difference
	      absoluteStart.add(mouseDiff);
	
	      // Clamp the value
	      var maxStart = canvasSize.clone().subtract(absoluteCropSize);
	      absoluteStart.clamp(new _libMathVector22['default'](0, 0), maxStart);
	
	      // End position does not change (relative to start)
	      absoluteEnd.copy(absoluteStart).add(absoluteCropSize);
	
	      // Set the final values
	      this._start.copy(absoluteStart).divide(canvasSize);
	      this._end.copy(absoluteEnd).divide(canvasSize);
	
	      this._updateDOM();
	    }
	
	    /**
	     * Gets called when the user releases the center area
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onCenterUp',
	    value: function _onCenterUp() {
	      document.removeEventListener('mousemove', this._onCenterDrag);
	      document.removeEventListener('touchmove', this._onCenterDrag);
	      document.removeEventListener('mouseup', this._onCenterUp);
	      document.removeEventListener('touchend', this._onCenterUp);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel, false);
	
	      if (this._operationExistedBefore) {
	        this._operation.set({
	          start: this._initialStart,
	          end: this._initialEnd
	        });
	      } else {
	        this._ui.removeOperation('crop');
	      }
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @protected
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      this._operation.set({
	        start: this._start,
	        end: this._end
	      });
	      this._ui.canvas.zoomToFit(true);
	
	      this._ui.addHistory(this._operation, {
	        start: this._initialStart.clone(),
	        end: this._initialEnd.clone()
	      }, this._operationExistedBefore);
	    }
	
	    /**
	     * The data that is available to the template
	     * @type {Object}
	     * @override
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      var context = _get(Object.getPrototypeOf(CropControl.prototype), 'context', this);
	      context.ratios = this._ratios;
	      return context;
	    }
	
	    /**
	     * The selected ratio identifier
	     * @type {String}
	     */
	  }, {
	    key: 'selectedRatio',
	    get: function get() {
	      return this._selectedRatio;
	    }
	  }]);
	
	  return CropControl;
	})(_control2['default']);
	
	CropControl.prototype.identifier = 'crop';
	
	exports['default'] = CropControl;
	module.exports = exports['default'];

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libSimpleSlider = __webpack_require__(105);
	
	var _libSimpleSlider2 = _interopRequireDefault(_libSimpleSlider);
	
	var RadialBlurControl = (function (_Control) {
	  _inherits(RadialBlurControl, _Control);
	
	  function RadialBlurControl() {
	    _classCallCheck(this, RadialBlurControl);
	
	    _get(Object.getPrototypeOf(RadialBlurControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(RadialBlurControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-controls-icon"> <img src="'+(it.helpers.assetPath('ui/night/blur/blur.png'))+'" /></div><div> '+( it.partials.slider)+'</div>'+( it.partials.doneButton);return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-radial-blur-container"> <div class="imglykit-canvas-radial-blur-dot" id="imglykit-radial-blur-position"></div> <div class="imglykit-canvas-radial-blur-dot" id="imglykit-radial-blur-gradient"></div> <div class="imglykit-canvas-radial-blur-circle-container"> <div class="imglykit-canvas-radial-blur-circle"></div> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      this._partialTemplates.slider = _libSimpleSlider2['default'].template;
	      this._partialTemplates.slider.additionalContext = {
	        id: 'imglykit-blur-radius-slider'
	      };
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._operationExistedBefore = !!this._ui.operations['radial-blur'];
	      this._operation = this._ui.getOrCreateOperation('radial-blur');
	
	      // Remember initial identity state
	      this._initialSettings = {
	        position: this._operation.getPosition().clone(),
	        gradientRadius: this._operation.getGradientRadius(),
	        blurRadius: this._operation.getBlurRadius()
	      };
	
	      // Mouse event callbacks bound to the class context
	      this._onPositionKnobDown = this._onPositionKnobDown.bind(this);
	      this._onPositionKnobDrag = this._onPositionKnobDrag.bind(this);
	      this._onPositionKnobUp = this._onPositionKnobUp.bind(this);
	      this._onGradientKnobDown = this._onGradientKnobDown.bind(this);
	      this._onGradientKnobDrag = this._onGradientKnobDrag.bind(this);
	      this._onGradientKnobUp = this._onGradientKnobUp.bind(this);
	
	      this._positionKnob = this._canvasControls.querySelector('#imglykit-radial-blur-position');
	      this._gradientKnob = this._canvasControls.querySelector('#imglykit-radial-blur-gradient');
	      this._circle = this._canvasControls.querySelector('.imglykit-canvas-radial-blur-circle');
	      this._handleKnobs();
	      this._initSliders();
	
	      this._ui.canvas.render().then(function () {
	        _this._updateDOM();
	      });
	    }
	
	    /**
	     * Initializes the slider controls
	     * @private
	     */
	  }, {
	    key: '_initSliders',
	    value: function _initSliders() {
	      var blurRadiusSlider = this._controls.querySelector('#imglykit-blur-radius-slider');
	      this._blurRadiusSlider = new _libSimpleSlider2['default'](blurRadiusSlider, {
	        minValue: 0,
	        maxValue: 40
	      });
	      this._blurRadiusSlider.on('update', this._onBlurRadiusUpdate.bind(this));
	      this._blurRadiusSlider.setValue(this._initialSettings.blurRadius);
	    }
	
	    /**
	     * Gets called when the value of the blur radius slider has been updated
	     * @param {Number} value
	     * @private
	     */
	  }, {
	    key: '_onBlurRadiusUpdate',
	    value: function _onBlurRadiusUpdate(value) {
	      this._operation.setBlurRadius(value);
	      this._ui.canvas.render();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Handles the knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleKnobs',
	    value: function _handleKnobs() {
	      // Initially set gradient knob position
	      var canvasSize = this._ui.canvas.size;
	      var position = this._operation.getPosition().clone().multiply(canvasSize);
	      this._gradientKnobPosition = position.clone().add(this._initialSettings.gradientRadius, 0);
	
	      this._positionKnob.addEventListener('mousedown', this._onPositionKnobDown);
	      this._positionKnob.addEventListener('touchstart', this._onPositionKnobDown);
	      this._gradientKnob.addEventListener('mousedown', this._onGradientKnobDown);
	      this._gradientKnob.addEventListener('touchstart', this._onGradientKnobDown);
	    }
	
	    /**
	     * Gets called when the user starts dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobDown',
	    value: function _onPositionKnobDown(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialPosition = this._operation.getPosition().clone();
	      this._gradientKnobDistance = this._gradientKnobPosition.clone().subtract(this._initialPosition.clone().multiply(canvasSize));
	
	      document.addEventListener('mousemove', this._onPositionKnobDrag);
	      document.addEventListener('touchmove', this._onPositionKnobDrag);
	
	      document.addEventListener('mouseup', this._onPositionKnobUp);
	      document.addEventListener('touchend', this._onPositionKnobUp);
	    }
	
	    /**
	     * Gets called while the user starts drags the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobDrag',
	    value: function _onPositionKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.subtract(this._initialMousePosition);
	
	      var newPosition = this._initialPosition.clone().multiply(canvasSize).add(diff);
	
	      var maxPosition = canvasSize.clone().subtract(this._gradientKnobDistance);
	      newPosition.clamp(new _libMathVector22['default'](0, 0), maxPosition);
	
	      this._gradientKnobPosition.copy(newPosition).add(this._gradientKnobDistance);
	
	      // Translate to 0...1
	      newPosition.divide(canvasSize);
	
	      this._operation.setPosition(newPosition);
	      this._updateDOM();
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the user stops dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobUp',
	    value: function _onPositionKnobUp(e) {
	      e.preventDefault();
	
	      document.removeEventListener('mousemove', this._onPositionKnobDrag);
	      document.removeEventListener('touchmove', this._onPositionKnobDrag);
	
	      document.removeEventListener('mouseup', this._onPositionKnobUp);
	      document.removeEventListener('touchend', this._onPositionKnobUp);
	    }
	
	    /**
	     * Gets called when the user starts dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobDown',
	    value: function _onGradientKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialGradientKnobPosition = this._gradientKnobPosition.clone();
	
	      document.addEventListener('mousemove', this._onGradientKnobDrag);
	      document.addEventListener('touchmove', this._onGradientKnobDrag);
	
	      document.addEventListener('mouseup', this._onGradientKnobUp);
	      document.addEventListener('touchend', this._onGradientKnobUp);
	    }
	
	    /**
	     * Gets called while the user starts drags the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobDrag',
	    value: function _onGradientKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.subtract(this._initialMousePosition);
	
	      // Calculate new gradient knob position
	      this._gradientKnobPosition = this._initialGradientKnobPosition.clone().add(diff);
	      this._gradientKnobPosition.clamp(new _libMathVector22['default'](0, 0), canvasSize);
	
	      // Calculate distance to position
	      var position = this._operation.getPosition().clone().multiply(canvasSize);
	      var distance = this._gradientKnobPosition.clone().subtract(position);
	      var gradientRadius = Math.sqrt(Math.pow(distance.x, 2) + Math.pow(distance.y, 2));
	
	      // Update operation
	      this._operation.setGradientRadius(gradientRadius);
	      this._updateDOM();
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the user stops dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobUp',
	    value: function _onGradientKnobUp(e) {
	      e.preventDefault();
	
	      document.removeEventListener('mousemove', this._onGradientKnobDrag);
	      document.removeEventListener('touchmove', this._onGradientKnobDrag);
	
	      document.removeEventListener('mouseup', this._onGradientKnobUp);
	      document.removeEventListener('touchend', this._onGradientKnobUp);
	    }
	
	    /**
	     * Updates the knob
	     * @private
	     */
	  }, {
	    key: '_updateDOM',
	    value: function _updateDOM() {
	      var canvasSize = this._ui.canvas.size;
	      var position = this._operation.getPosition().clone().multiply(canvasSize);
	
	      this._positionKnob.style.left = position.x + 'px';
	      this._positionKnob.style.top = position.y + 'px';
	
	      this._gradientKnob.style.left = this._gradientKnobPosition.x + 'px';
	      this._gradientKnob.style.top = this._gradientKnobPosition.y + 'px';
	
	      var circleSize = this._operation.getGradientRadius() * 2;
	      this._circle.style.left = position.x + 'px';
	      this._circle.style.top = position.y + 'px';
	      this._circle.style.width = circleSize + 'px';
	      this._circle.style.height = circleSize + 'px';
	      this._circle.style.marginLeft = '-' + circleSize / 2 + 'px';
	      this._circle.style.marginTop = '-' + circleSize / 2 + 'px';
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (this._operationExistedBefore) {
	        this._operation.set(this._initialSettings);
	      } else {
	        this._ui.removeOperation('radial-blur');
	      }
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      this._ui.addHistory(this._operation, {
	        position: this._initialSettings.position.clone(),
	        gradientRadius: this._initialSettings.gradientRadius,
	        blurRadius: this._initialSettings.blurRadius
	      }, this._operationExistedBefore);
	    }
	  }]);
	
	  return RadialBlurControl;
	})(_control2['default']);
	
	RadialBlurControl.prototype.identifier = 'radial-blur';
	
	exports['default'] = RadialBlurControl;
	module.exports = exports['default'];

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _slider = __webpack_require__(100);
	
	var _slider2 = _interopRequireDefault(_slider);
	
	var SimpleSlider = (function (_Slider) {
	  _inherits(SimpleSlider, _Slider);
	
	  function SimpleSlider() {
	    _classCallCheck(this, SimpleSlider);
	
	    _get(Object.getPrototypeOf(SimpleSlider.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  _createClass(SimpleSlider, [{
	    key: '_setX',
	
	    /**
	     * Sets the slider position to the given X value and resizes
	     * the fill div
	     * @private
	     */
	    value: function _setX(x) {
	      this._xPosition = x;
	
	      this._dotElement.style.left = x + 'px';
	      this._fillElement.style.width = x + 'px';
	    }
	  }], [{
	    key: 'template',
	
	    /**
	     * The partial template string
	     * @type {String}
	     */
	    get: function get() {
	      return function(it
	/**/) {
	var out='<div class="imglykit-slider" id="'+((typeof it.id === "undefined"?'':it.id))+'"> <div class="imglykit-slider-minus"> <img src="'+(it.helpers.assetPath('ui/night/slider/minus.png') )+'" /> </div> <div class="imglykit-slider-slider"> <div class="imglykit-slider-content"> <div class="imglykit-slider-background"></div> <div class="imglykit-slider-fill"></div> <div class="imglykit-slider-dot"></div> </div> </div> <div class="imglykit-slider-plus"> <img src="'+(it.helpers.assetPath('ui/night/slider/plus.png') )+'" /> </div></div>';return out;
	};
	    }
	  }]);
	
	  return SimpleSlider;
	})(_slider2['default']);
	
	exports['default'] = SimpleSlider;
	module.exports = exports['default'];

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libSimpleSlider = __webpack_require__(105);
	
	var _libSimpleSlider2 = _interopRequireDefault(_libSimpleSlider);
	
	var TiltShiftControl = (function (_Control) {
	  _inherits(TiltShiftControl, _Control);
	
	  function TiltShiftControl() {
	    _classCallCheck(this, TiltShiftControl);
	
	    _get(Object.getPrototypeOf(TiltShiftControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(TiltShiftControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-controls-icon"> <img src="'+(it.helpers.assetPath('ui/night/blur/blur.png'))+'" /></div><div> ';var sliderId = "imglykit-blur-radius-slider";out+=' '+( it.partials.slider)+'</div>'+( it.partials.doneButton);return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-tilt-shift-container"> <div class="imglykit-canvas-tilt-shift-dot" data-option="position"></div> <div class="imglykit-canvas-tilt-shift-dot" data-option="gradient"></div> <div class="imglykit-canvas-tilt-shift-rect-container"> <div class="imglykit-canvas-tilt-shift-rect"></div> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      this._partialTemplates.slider = _libSimpleSlider2['default'].template;
	      this._partialTemplates.slider.additionalContext = { id: 'imglykit-blur-radius-slider' };
	      this._currentKnob = null;
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._operationExistedBefore = !!this._ui.operations['tilt-shift'];
	      this._operation = this._ui.getOrCreateOperation('tilt-shift');
	
	      this._initialSettings = {
	        start: this._operation.getStart().clone(),
	        end: this._operation.getEnd().clone(),
	        gradientRadius: this._operation.getGradientRadius(),
	        blurRadius: this._operation.getBlurRadius()
	      };
	
	      // Mouse event callbacks bound to the class context
	      this._onPositionKnobDown = this._onPositionKnobDown.bind(this);
	      this._onPositionKnobDrag = this._onPositionKnobDrag.bind(this);
	      this._onPositionKnobUp = this._onPositionKnobUp.bind(this);
	      this._onGradientKnobDown = this._onGradientKnobDown.bind(this);
	      this._onGradientKnobDrag = this._onGradientKnobDrag.bind(this);
	      this._onGradientKnobUp = this._onGradientKnobUp.bind(this);
	
	      // Find DOM elements
	      var selector = '.imglykit-canvas-tilt-shift-dot';
	      this._positionKnob = this._canvasControls.querySelector(selector + '[data-option=\'position\']');
	      this._gradientKnob = this._canvasControls.querySelector(selector + '[data-option=\'gradient\']');
	      this._rect = this._canvasControls.querySelector('.imglykit-canvas-tilt-shift-rect');
	
	      // Initialization
	      this._initSliders();
	
	      this._ui.canvas.render().then(function () {
	        _this._handleKnobs();
	        _this._updateDOM();
	      });
	    }
	
	    /**
	     * Initializes the slider controls
	     * @private
	     */
	  }, {
	    key: '_initSliders',
	    value: function _initSliders() {
	      var blurRadiusSlider = this._controls.querySelector('#imglykit-blur-radius-slider');
	      this._blurRadiusSlider = new _libSimpleSlider2['default'](blurRadiusSlider, {
	        minValue: 0,
	        maxValue: 40
	      });
	      this._blurRadiusSlider.on('update', this._onBlurRadiusUpdate.bind(this));
	      this._blurRadiusSlider.setValue(this._initialSettings.blurRadius);
	    }
	
	    /**
	     * Gets called when the value of the blur radius slider has been updated
	     * @param {Number} value
	     * @private
	     */
	  }, {
	    key: '_onBlurRadiusUpdate',
	    value: function _onBlurRadiusUpdate(value) {
	      this._operation.setBlurRadius(value);
	      this._ui.canvas.render();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Handles the knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleKnobs',
	    value: function _handleKnobs() {
	      // Add event listeners
	      this._positionKnob.addEventListener('mousedown', this._onPositionKnobDown);
	      this._positionKnob.addEventListener('touchstart', this._onPositionKnobDown);
	      this._gradientKnob.addEventListener('mousedown', this._onGradientKnobDown);
	      this._gradientKnob.addEventListener('touchstart', this._onGradientKnobDown);
	
	      var canvasSize = this._ui.canvas.size;
	      var _initialSettings = this._initialSettings;
	      var start = _initialSettings.start;
	      var end = _initialSettings.end;
	
	      start = start.clone().multiply(canvasSize);
	      end = end.clone().multiply(canvasSize);
	
	      var dist = end.clone().subtract(start);
	      var middle = start.clone().add(dist.clone().divide(2));
	
	      var totalDist = Math.sqrt(Math.pow(dist.x, 2) + Math.pow(dist.y, 2));
	      var factor = dist.clone().divide(totalDist).divide(2);
	
	      // Calculate initial knob position (middle of start and end)
	      this._knobPosition = middle.clone();
	
	      // Calculate initial gradient knob position
	      var gradientRadius = this._initialSettings.gradientRadius;
	      this._gradientKnobPosition = middle.clone().add(-gradientRadius * factor.y, gradientRadius * factor.x);
	
	      this._updateStartAndEnd();
	      this._updateDOM();
	
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Calculate start and end positions using the knob positions
	     * @private
	     */
	  }, {
	    key: '_updateStartAndEnd',
	    value: function _updateStartAndEnd() {
	      var canvasSize = this._ui.canvas.size;
	
	      // Calculate distance between gradient and position knob
	      var diff = this._gradientKnobPosition.clone().subtract(this._knobPosition);
	
	      var start = this._knobPosition.clone().add(-diff.y, diff.x).divide(canvasSize);
	      var end = this._knobPosition.clone().add(diff.y, -diff.x).divide(canvasSize);
	
	      this._operation.set({ start: start, end: end });
	    }
	
	    /**
	     * Gets called when the user starts dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobDown',
	    value: function _onPositionKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialPosition = this._knobPosition.clone();
	      this._initialDistanceToGradientKnob = this._gradientKnobPosition.clone().subtract(this._initialPosition);
	
	      document.addEventListener('mousemove', this._onPositionKnobDrag);
	      document.addEventListener('touchmove', this._onPositionKnobDrag);
	
	      document.addEventListener('mouseup', this._onPositionKnobUp);
	      document.addEventListener('touchend', this._onPositionKnobUp);
	    }
	
	    /**
	     * Gets called when the user drags the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobDrag',
	    value: function _onPositionKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.subtract(this._initialMousePosition);
	
	      var newPosition = this._initialPosition.clone().add(diff);
	      this._knobPosition.copy(newPosition);
	
	      var minPosition = new _libMathVector22['default']().subtract(this._initialDistanceToGradientKnob);
	      minPosition.clamp(new _libMathVector22['default'](0, 0));
	
	      var maxPosition = canvasSize.clone().subtract(this._initialDistanceToGradientKnob);
	      maxPosition.clamp(null, canvasSize);
	
	      this._knobPosition.clamp(minPosition, maxPosition);
	
	      this._gradientKnobPosition.copy(this._knobPosition).add(this._initialDistanceToGradientKnob);
	
	      this._updateStartAndEnd();
	      this._updateDOM();
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the user stops dragging the position knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onPositionKnobUp',
	    value: function _onPositionKnobUp(e) {
	      e.preventDefault();
	
	      document.removeEventListener('mousemove', this._onPositionKnobDrag);
	      document.removeEventListener('touchmove', this._onPositionKnobDrag);
	
	      document.removeEventListener('mouseup', this._onPositionKnobUp);
	      document.removeEventListener('touchend', this._onPositionKnobUp);
	    }
	
	    /**
	     * Gets called when the user starts dragging the gradient knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobDown',
	    value: function _onGradientKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialGradientKnobPosition = this._gradientKnobPosition.clone();
	
	      document.addEventListener('mousemove', this._onGradientKnobDrag);
	      document.addEventListener('touchmove', this._onGradientKnobDrag);
	
	      document.addEventListener('mouseup', this._onGradientKnobUp);
	      document.addEventListener('touchend', this._onGradientKnobUp);
	    }
	
	    /**
	     * Gets called when the user drags the gradient knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobDrag',
	    value: function _onGradientKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.subtract(this._initialMousePosition);
	
	      this._gradientKnobPosition.copy(this._initialGradientKnobPosition).add(diff);
	      this._gradientKnobPosition.clamp(new _libMathVector22['default'](0, 0), canvasSize);
	
	      var distance = this._gradientKnobPosition.clone().subtract(this._knobPosition);
	      var newGradientRadius = 2 * Math.sqrt(Math.pow(distance.x, 2) + Math.pow(distance.y, 2));
	
	      this._operation.setGradientRadius(newGradientRadius);
	      this._updateStartAndEnd();
	      this._updateDOM();
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the user stops dragging the gradient knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onGradientKnobUp',
	    value: function _onGradientKnobUp(e) {
	      e.preventDefault();
	
	      document.removeEventListener('mousemove', this._onGradientKnobDrag);
	      document.removeEventListener('touchmove', this._onGradientKnobDrag);
	
	      document.removeEventListener('mouseup', this._onGradientKnobUp);
	      document.removeEventListener('touchend', this._onGradientKnobUp);
	    }
	
	    /**
	     * Updates the knob
	     * @private
	     */
	  }, {
	    key: '_updateDOM',
	    value: function _updateDOM() {
	      var position = this._knobPosition;
	      this._positionKnob.style.left = position.x + 'px';
	      this._positionKnob.style.top = position.y + 'px';
	
	      var gradientPosition = this._gradientKnobPosition;
	      this._gradientKnob.style.left = gradientPosition.x + 'px';
	      this._gradientKnob.style.top = gradientPosition.y + 'px';
	
	      // Resize rectangle to worst case size
	      var canvasSize = this._ui.canvas.size;
	      var gradientRadius = this._operation.getGradientRadius();
	      var rectSize = new _libMathVector22['default'](Math.sqrt(Math.pow(canvasSize.x, 2) + Math.pow(canvasSize.y, 2)) * 2, gradientRadius);
	
	      this._rect.style.width = rectSize.x + 'px';
	      this._rect.style.height = rectSize.y + 'px';
	      this._rect.style.marginLeft = '-' + rectSize.x / 2 + 'px';
	      this._rect.style.marginTop = '-' + rectSize.y / 2 + 'px';
	      this._rect.style.left = position.x + 'px';
	      this._rect.style.top = position.y + 'px';
	
	      // Rotate rectangle
	      var dist = gradientPosition.clone().subtract(position);
	      var degrees = Math.atan2(dist.x, dist.y) * (180 / Math.PI);
	      var transform = 'rotate(' + (-degrees).toFixed(2) + 'deg)';
	      this._rect.style.transform = transform;
	      this._rect.style['-moz-transform'] = transform;
	      this._rect.style['-ms-transform'] = transform;
	      this._rect.style['-webkit-transform'] = transform;
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (this._operationExistedBefore) {
	        this._operation.set(this._initialSettings);
	      } else {
	        this._ui.removeOperation('tilt-shift');
	      }
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      this._ui.addHistory(this._operation, {
	        start: this._initialSettings.start.clone(),
	        end: this._initialSettings.end.clone(),
	        blurRadius: this._initialSettings.blurRadius,
	        gradientRadius: this._initialSettings.gradientRadius
	      }, this._operationExistedBefore);
	    }
	  }]);
	
	  return TiltShiftControl;
	})(_control2['default']);
	
	TiltShiftControl.prototype.identifier = 'tilt-shift';
	
	exports['default'] = TiltShiftControl;
	module.exports = exports['default'];

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libSimpleSlider = __webpack_require__(105);
	
	var _libSimpleSlider2 = _interopRequireDefault(_libSimpleSlider);
	
	var _libColorPicker = __webpack_require__(108);
	
	var _libColorPicker2 = _interopRequireDefault(_libColorPicker);
	
	var FramesControl = (function (_Control) {
	  _inherits(FramesControl, _Control);
	
	  function FramesControl() {
	    _classCallCheck(this, FramesControl);
	
	    _get(Object.getPrototypeOf(FramesControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(FramesControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> '+( it.partials.slider)+'</div><div class="imglykit-controls-button"> '+( it.partials.colorPicker)+'</div>'+( it.partials.doneButton);return out;
	};
	      this._controlsTemplate = controlsTemplate;
	      this._partialTemplates.slider = _libSimpleSlider2['default'].template;
	      this._partialTemplates.colorPicker = _libColorPicker2['default'].template;
	    }
	  }, {
	    key: '_renderControls',
	    value: function _renderControls() {
	      this._partialTemplates.colorPicker.additionalContext = { label: this._ui.translate('controls.frames.color') };
	
	      _get(Object.getPrototypeOf(FramesControl.prototype), '_renderControls', this).call(this);
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      this._operationExistedBefore = !!this._ui.operations.frames;
	      this._operation = this._ui.getOrCreateOperation('frames');
	
	      this._initialOptions = {
	        thickness: this._operation.getThickness(),
	        color: this._operation.getColor()
	      };
	
	      this._ui.canvas.render();
	
	      // Init slider
	      var sliderElement = this._controls.querySelector('.imglykit-slider');
	      this._slider = new _libSimpleSlider2['default'](sliderElement, {
	        minValue: 0.0,
	        maxValue: 0.5
	      });
	      this._slider.on('update', this._onThicknessUpdate.bind(this));
	      this._slider.setValue(this._initialOptions.thickness);
	
	      // Init colorpicker
	      var colorPickerElement = this._controls.querySelector('.imglykit-color-picker');
	      this._colorPicker = new _libColorPicker2['default'](this._ui, colorPickerElement);
	      this._colorPicker.on('update', this._onColorUpdate.bind(this));
	      this._colorPicker.setValue(this._initialOptions.color);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (this._operationExistedBefore) {
	        this._operation.set(this._initialOptions);
	      } else {
	        this._ui.removeOperation('frames');
	      }
	      this._ui.canvas.render();
	    }
	
	    /**
	     * Gets called when the thickness has been changed
	     * @override
	     */
	  }, {
	    key: '_onThicknessUpdate',
	    value: function _onThicknessUpdate(value) {
	      this._operation.setThickness(value);
	      this._ui.canvas.render();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Gets called when the color has been changed
	     * @override
	     */
	  }, {
	    key: '_onColorUpdate',
	    value: function _onColorUpdate(value) {
	      this._operation.setColor(value);
	      this._ui.canvas.render();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      this._ui.addHistory(this._operation, {
	        color: this._initialOptions.color,
	        thickness: this._initialOptions.thickness
	      }, this._operationExistedBefore);
	    }
	  }]);
	
	  return FramesControl;
	})(_control2['default']);
	
	FramesControl.prototype.identifier = 'frames';
	
	exports['default'] = FramesControl;
	module.exports = exports['default'];

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE, Image */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i['return']) _i['return'](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError('Invalid attempt to destructure non-iterable instance'); } }; })();
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _libEventEmitter = __webpack_require__(1);
	
	var _libEventEmitter2 = _interopRequireDefault(_libEventEmitter);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var ColorPicker = (function (_EventEmitter) {
	  _inherits(ColorPicker, _EventEmitter);
	
	  function ColorPicker(ui, element) {
	    _classCallCheck(this, ColorPicker);
	
	    _get(Object.getPrototypeOf(ColorPicker.prototype), 'constructor', this).call(this);
	
	    this._ui = ui;
	    this._element = element;
	    this._visible = false;
	    this._loaded = false;
	
	    this._overlay = this._element.querySelector('.imglykit-color-picker-overlay');
	    this._currentColorCanvas = this._element.querySelector('.imglykit-color-picker-color');
	
	    this._alphaCanvas = this._element.querySelector('canvas.imglykit-color-picker-alpha');
	    this._alphaKnob = this._element.querySelector('.imglykit-color-picker-alpha-container .imglykit-transparent-knob');
	
	    this._hueCanvas = this._element.querySelector('canvas.imglykit-color-picker-hue');
	    this._hueKnob = this._element.querySelector('.imglykit-color-picker-hue-container .imglykit-transparent-knob');
	
	    this._saturationCanvas = this._element.querySelector('canvas.imglykit-color-picker-saturation');
	    this._saturationKnob = this._element.querySelector('.imglykit-color-picker-saturation-container .imglykit-transparent-knob');
	
	    this._transparencyImage = new Image();
	    this._transparencyImage.src = ui.helpers.assetPath('ui/night/transparency.png');
	    this._transparencyImage.addEventListener('load', this._onTransparencyImageLoad.bind(this));
	
	    this._onAlphaCanvasDown = this._onAlphaCanvasDown.bind(this);
	    this._onAlphaCanvasDrag = this._onAlphaCanvasDrag.bind(this);
	    this._onAlphaCanvasUp = this._onAlphaCanvasUp.bind(this);
	    this._onHueCanvasDown = this._onHueCanvasDown.bind(this);
	    this._onHueCanvasDrag = this._onHueCanvasDrag.bind(this);
	    this._onHueCanvasUp = this._onHueCanvasUp.bind(this);
	
	    this._onSaturationCanvasDown = this._onSaturationCanvasDown.bind(this);
	    this._onSaturationCanvasDrag = this._onSaturationCanvasDrag.bind(this);
	    this._onSaturationCanvasUp = this._onSaturationCanvasUp.bind(this);
	
	    this._onElementClick = this._onElementClick.bind(this);
	
	    this._handleToggle();
	    this._handleAlphaKnob();
	    this._handleHueKnob();
	    this._handleSaturationKnob();
	  }
	
	  _createClass(ColorPicker, [{
	    key: '_onTransparencyImageLoad',
	    value: function _onTransparencyImageLoad() {
	      this._loaded = true;
	      this._render();
	    }
	
	    /**
	     * The partial template string
	     * @type {String}
	     */
	  }, {
	    key: '_handleToggle',
	
	    /**
	     * Handles the toggling of the overlay
	     * @private
	     */
	    value: function _handleToggle() {
	      this._element.addEventListener('click', this._onElementClick);
	    }
	
	    /**
	     * Gets called when the element has been clicked
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onElementClick',
	    value: function _onElementClick(e) {
	      if (e.target === this._element || e.target === this._currentColorCanvas) {
	        if (this._visible) {
	          this.hide();
	          this.emit('hide');
	        } else {
	          this.show();
	          this.emit('show');
	        }
	      }
	    }
	
	    /**
	     * Hides the color picker
	     */
	  }, {
	    key: 'hide',
	    value: function hide() {
	      _libUtils2['default'].classList(this._overlay).remove('imglykit-visible');
	      this._visible = false;
	    }
	
	    /**
	     * Shows the color picker
	     */
	  }, {
	    key: 'show',
	    value: function show() {
	      _libUtils2['default'].classList(this._overlay).add('imglykit-visible');
	      this._visible = true;
	    }
	
	    /**
	     * Sets the given value
	     * @param {Number} value
	     */
	  }, {
	    key: 'setValue',
	    value: function setValue(value) {
	      this._value = value.clone();
	
	      var _value$toHSV = this._value.toHSV();
	
	      var _value$toHSV2 = _slicedToArray(_value$toHSV, 3);
	
	      var h = _value$toHSV2[0];
	      var s = _value$toHSV2[1];
	      var v = _value$toHSV2[2];
	
	      this._hsvColor = { h: h, s: s, v: v };
	      this._positionKnobs();
	      this._render();
	    }
	
	    /**
	     * Updates the knob positions to represent the current HSV color
	     * @private
	     */
	  }, {
	    key: '_positionKnobs',
	    value: function _positionKnobs() {
	      this._positionAlphaKnob();
	      this._positionHueKnob();
	      this._positionSaturationKnob();
	    }
	
	    /**
	     * Positions the alpha knob according to the current alpha value
	     * @private
	     */
	  }, {
	    key: '_positionAlphaKnob',
	    value: function _positionAlphaKnob() {
	      var canvas = this._alphaCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var left = this._value.a * canvasSize.x;
	      this._alphaKnob.style.left = left + 'px';
	    }
	
	    /**
	     * Positions the hue knob according to the current hue value
	     * @private
	     */
	  }, {
	    key: '_positionHueKnob',
	    value: function _positionHueKnob() {
	      var canvas = this._hueCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var top = this._hsvColor.h * canvasSize.y;
	      this._hueKnob.style.top = top + 'px';
	    }
	
	    /**
	     * Positions the saturation knob according to the current saturation value
	     * @private
	     */
	  }, {
	    key: '_positionSaturationKnob',
	    value: function _positionSaturationKnob() {
	      var canvas = this._saturationCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      var left = this._hsvColor.s * canvasSize.x;
	      this._saturationKnob.style.left = left + 'px';
	      var top = (1 - this._hsvColor.v) * canvasSize.y;
	      this._saturationKnob.style.top = top + 'px';
	    }
	
	    /**
	     * Updates and renders all controls to represent the current value
	     * @private
	     */
	  }, {
	    key: '_render',
	    value: function _render() {
	      if (!this._loaded) return;
	      this._renderCurrentColor();
	      this._renderAlpha();
	      this._renderHue();
	      this._renderSaturation();
	    }
	
	    /**
	     * Renders the currently selected color on the controls canvas
	     * @private
	     */
	  }, {
	    key: '_renderCurrentColor',
	    value: function _renderCurrentColor() {
	      var canvas = this._currentColorCanvas;
	      var context = canvas.getContext('2d');
	
	      var pattern = context.createPattern(this._transparencyImage, 'repeat');
	      context.rect(0, 0, canvas.width, canvas.height);
	      context.fillStyle = pattern;
	      context.fill();
	
	      context.fillStyle = this._value.toRGBA();
	      context.fill();
	    }
	
	    /**
	     * Renders the transparency canvas with the current color
	     * @private
	     */
	  }, {
	    key: '_renderAlpha',
	    value: function _renderAlpha() {
	      var canvas = this._alphaCanvas;
	      var context = canvas.getContext('2d');
	
	      var pattern = context.createPattern(this._transparencyImage, 'repeat');
	      context.rect(0, 0, canvas.width, canvas.height);
	      context.fillStyle = pattern;
	      context.fill();
	
	      var gradient = context.createLinearGradient(0, 0, canvas.width, canvas.height);
	
	      var color = this._value.clone();
	      color.a = 0;
	      gradient.addColorStop(0, color.toRGBA());
	      gradient.addColorStop(1, this._value.toHex());
	      context.fillStyle = gradient;
	      context.fill();
	    }
	
	    /**
	     * Renders the hue canvas
	     * @private
	     */
	  }, {
	    key: '_renderHue',
	    value: function _renderHue() {
	      var canvas = this._hueCanvas;
	      var context = canvas.getContext('2d');
	
	      var color = new _libColor2['default']();
	      for (var y = 0; y < canvas.height; y++) {
	        var ratio = y / canvas.height;
	        color.fromHSV(ratio, 1, 1);
	
	        context.strokeStyle = color.toRGBA();
	        context.beginPath();
	        context.moveTo(0, y);
	        context.lineTo(canvas.width, y);
	        context.stroke();
	      }
	    }
	
	    /**
	     * Renders the saturation canvas
	     * @private
	     */
	  }, {
	    key: '_renderSaturation',
	    value: function _renderSaturation() {
	      var canvas = this._saturationCanvas;
	      var context = canvas.getContext('2d');
	
	      var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
	
	      var color = new _libColor2['default'](1, 0, 0, 1);
	      for (var y = 0; y < canvas.height; y++) {
	        var value = (canvas.height - y) / canvas.height;
	        for (var x = 0; x < canvas.width; x++) {
	          var saturation = x / canvas.width;
	          color.fromHSV(this._hsvColor.h, saturation, value);
	          var r = color.r;
	          var g = color.g;
	          var b = color.b;
	          var a = color.a;
	
	          var index = (y * canvas.width + x) * 4;
	
	          imageData.data[index] = r * 255;
	          imageData.data[index + 1] = g * 255;
	          imageData.data[index + 2] = b * 255;
	          imageData.data[index + 3] = a * 255;
	        }
	      }
	
	      context.putImageData(imageData, 0, 0);
	    }
	
	    /**
	     * Handles the dragging of the alpha knob
	     * @private
	     */
	  }, {
	    key: '_handleAlphaKnob',
	    value: function _handleAlphaKnob() {
	      this._alphaCanvas.addEventListener('mousedown', this._onAlphaCanvasDown);
	      this._alphaCanvas.addEventListener('touchstart', this._onAlphaCanvasDown);
	    }
	
	    /**
	     * Gets called when the user clicks the alpha knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onAlphaCanvasDown',
	    value: function _onAlphaCanvasDown(e) {
	      e.preventDefault();
	
	      this._onAlphaCanvasDrag(e);
	
	      document.addEventListener('mousemove', this._onAlphaCanvasDrag);
	      document.addEventListener('touchmove', this._onAlphaCanvasDrag);
	
	      document.addEventListener('mouseup', this._onAlphaCanvasUp);
	      document.addEventListener('touchend', this._onAlphaCanvasUp);
	    }
	
	    /**
	     * Gets called when the user drags the alpha knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onAlphaCanvasDrag',
	    value: function _onAlphaCanvasDrag(e) {
	      e.preventDefault();
	
	      // Calculate relative mouse position on canvas
	      var canvas = this._alphaCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	
	      var _canvas$getBoundingClientRect = canvas.getBoundingClientRect();
	
	      var left = _canvas$getBoundingClientRect.left;
	      var top = _canvas$getBoundingClientRect.top;
	
	      var offset = new _libMathVector22['default'](left, top);
	      var relativePosition = mousePosition.subtract(offset);
	      relativePosition.clamp(new _libMathVector22['default'](0, 0), canvasSize);
	
	      // Update knob css positioning
	      this._alphaKnob.style.left = relativePosition.x + 'px';
	
	      // Update alpha value
	      this._value.a = relativePosition.x / canvasSize.x;
	      this._updateColor();
	    }
	
	    /**
	     * Gets called when the user stops dragging the alpha knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onAlphaCanvasUp',
	    value: function _onAlphaCanvasUp() {
	      document.removeEventListener('mousemove', this._onAlphaCanvasDrag);
	      document.removeEventListener('touchmove', this._onAlphaCanvasDrag);
	
	      document.removeEventListener('mouseup', this._onAlphaCanvasUp);
	      document.removeEventListener('touchend', this._onAlphaCanvasUp);
	    }
	
	    /**
	     * Handles the dragging of the hue knob
	     * @private
	     */
	  }, {
	    key: '_handleHueKnob',
	    value: function _handleHueKnob() {
	      this._hueCanvas.addEventListener('mousedown', this._onHueCanvasDown);
	      this._hueCanvas.addEventListener('touchstart', this._onHueCanvasDown);
	    }
	
	    /**
	     * Gets called when the user clicks the canvas knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onHueCanvasDown',
	    value: function _onHueCanvasDown(e) {
	      e.preventDefault();
	
	      this._onHueCanvasDrag(e);
	
	      document.addEventListener('mousemove', this._onHueCanvasDrag);
	      document.addEventListener('touchmove', this._onHueCanvasDrag);
	
	      document.addEventListener('mouseup', this._onHueCanvasUp);
	      document.addEventListener('touchend', this._onHueCanvasUp);
	    }
	
	    /**
	     * Gets called when the user drags the hue knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onHueCanvasDrag',
	    value: function _onHueCanvasDrag(e) {
	      e.preventDefault();
	
	      var canvas = this._hueCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      // Calculate relative mouse position on canvas
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	
	      var _canvas$getBoundingClientRect2 = canvas.getBoundingClientRect();
	
	      var left = _canvas$getBoundingClientRect2.left;
	      var top = _canvas$getBoundingClientRect2.top;
	
	      var offset = new _libMathVector22['default'](left, top);
	      var relativePosition = mousePosition.subtract(offset);
	      relativePosition.clamp(new _libMathVector22['default'](0, 0), canvasSize);
	
	      // Update saturaiton knob css positioning
	      this._hueKnob.style.top = relativePosition.y + 'px';
	
	      // Update saturation and value
	      relativePosition.divide(canvasSize);
	      this._hsvColor.h = relativePosition.y;
	      this._updateColor();
	    }
	
	    /**
	     * Gets called when the user stops dragging the alpha knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onHueCanvasUp',
	    value: function _onHueCanvasUp() {
	      document.removeEventListener('mousemove', this._onHueCanvasDrag);
	      document.removeEventListener('touchmove', this._onHueCanvasDrag);
	
	      document.removeEventListener('mouseup', this._onHueCanvasUp);
	      document.removeEventListener('touchend', this._onHueCanvasUp);
	    }
	
	    /**
	     * Handles the dragging of the saturation knob
	     * @private
	     */
	  }, {
	    key: '_handleSaturationKnob',
	    value: function _handleSaturationKnob() {
	      this._saturationCanvas.addEventListener('mousedown', this._onSaturationCanvasDown);
	      this._saturationCanvas.addEventListener('touchstart', this._onSaturationCanvasDown);
	    }
	
	    /**
	     * Gets called when the user clicks the saturation canvas
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onSaturationCanvasDown',
	    value: function _onSaturationCanvasDown(e) {
	      e.preventDefault();
	
	      this._onSaturationCanvasDrag(e);
	
	      document.addEventListener('mousemove', this._onSaturationCanvasDrag);
	      document.addEventListener('touchmove', this._onSaturationCanvasDrag);
	
	      document.addEventListener('mouseup', this._onSaturationCanvasUp);
	      document.addEventListener('touchend', this._onSaturationCanvasUp);
	    }
	
	    /**
	     * Gets called when the user drags the saturation knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onSaturationCanvasDrag',
	    value: function _onSaturationCanvasDrag(e) {
	      e.preventDefault();
	
	      var canvas = this._saturationCanvas;
	      var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	      // Calculate relative mouse position on canvas
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	
	      var _canvas$getBoundingClientRect3 = canvas.getBoundingClientRect();
	
	      var left = _canvas$getBoundingClientRect3.left;
	      var top = _canvas$getBoundingClientRect3.top;
	
	      var offset = new _libMathVector22['default'](left, top);
	      var relativePosition = mousePosition.subtract(offset);
	      relativePosition.clamp(0, canvas.width);
	
	      // Update saturaiton knob css positioning
	      this._saturationKnob.style.left = relativePosition.x + 'px';
	      this._saturationKnob.style.top = relativePosition.y + 'px';
	
	      // Update saturation and value
	      relativePosition.divide(canvasSize);
	      this._hsvColor.s = relativePosition.x;
	      this._hsvColor.v = 1 - relativePosition.y;
	      this._updateColor();
	    }
	
	    /**
	     * Gets called when the user stops dragging the saturation knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onSaturationCanvasUp',
	    value: function _onSaturationCanvasUp() {
	      document.removeEventListener('mousemove', this._onSaturationCanvasDrag);
	      document.removeEventListener('touchmove', this._onSaturationCanvasDrag);
	
	      document.removeEventListener('mouseup', this._onSaturationCanvasUp);
	      document.removeEventListener('touchend', this._onSaturationCanvasUp);
	    }
	
	    /**
	     * Updates the attached color, emits the `update` event and triggers
	     * a render
	     * @private
	     */
	  }, {
	    key: '_updateColor',
	    value: function _updateColor() {
	      this._value.fromHSV(this._hsvColor.h, this._hsvColor.s, this._hsvColor.v);
	      this.emit('update', this._value);
	      this._render();
	    }
	  }], [{
	    key: 'template',
	    get: function get() {
	      return function(it
	/**/) {
	var out='<div class="imglykit-color-picker" id="'+((typeof it.id === "undefined"?'':it.id))+'"> <canvas class="imglykit-color-picker-color" width="34" height="34"></canvas> <div class="imglykit-controls-item-label">'+((typeof it.label === "undefined"?'':it.label))+'</div> <div class="imglykit-color-picker-overlay"> <div class="imglykit-color-picker-alpha-container"> <canvas class="imglykit-color-picker-alpha" width="200" height="30"></canvas> <div class="imglykit-transparent-knob"></div> </div> <div class="imglykit-color-picker-saturation-container"> <canvas class="imglykit-color-picker-saturation" width="160" height="160"></canvas> <div class="imglykit-transparent-knob"></div> </div> <div class="imglykit-color-picker-hue-container"> <canvas class="imglykit-color-picker-hue" width="30" height="160"></canvas> <div class="imglykit-transparent-knob"></div> </div> </div></div>';return out;
	};
	    }
	  }]);
	
	  return ColorPicker;
	})(_libEventEmitter2['default']);
	
	exports['default'] = ColorPicker;
	module.exports = exports['default'];

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var StickersControl = (function (_Control) {
	  _inherits(StickersControl, _Control);
	
	  function StickersControl() {
	    _classCallCheck(this, StickersControl);
	
	    _get(Object.getPrototypeOf(StickersControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(StickersControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> '; for(var identifier in it.stickers) { out+=' '; var stickerPath = it.stickers[identifier]; out+=' '; var enabled = it.activeSticker === identifier; out+=' <li data-identifier="'+( identifier)+'"';if(enabled){out+=' class="imglykit-controls-item-active"';}out+='> <canvas class="imglykit-controls-item-canvas" data-image="'+(it.helpers.assetPath(stickerPath))+'"></canvas> </li> '; } out+=' </ul></div>'+( it.partials.doneButton );return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-stickers-container"> <div class="imglykit-canvas-stickers"> <img class="imglykit-canvas-sticker-image" /> <div class="imglykit-knob"></div> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      /**
	       * The registered stickers
	       * @type {Object.<string, class>}
	       */
	      this._availableStickers = {};
	      this._stickers = {};
	      this._addDefaultStickers();
	      this.selectStickers(null);
	    }
	
	    /**
	     * Registers the default stickers
	     * @private
	     */
	  }, {
	    key: '_addDefaultStickers',
	    value: function _addDefaultStickers() {
	      this.addSticker('glasses-nerd', 'stickers/sticker-glasses-nerd.png');
	      this.addSticker('glasses-normal', 'stickers/sticker-glasses-normal.png');
	      this.addSticker('glasses-shutter-green', 'stickers/sticker-glasses-shutter-green.png');
	      this.addSticker('glasses-shutter-yellow', 'stickers/sticker-glasses-shutter-yellow.png');
	      this.addSticker('glasses-sun', 'stickers/sticker-glasses-sun.png');
	      this.addSticker('hat-cap', 'stickers/sticker-hat-cap.png');
	      this.addSticker('hat-cylinder', 'stickers/sticker-hat-cylinder.png');
	      this.addSticker('hat-party', 'stickers/sticker-hat-party.png');
	      this.addSticker('hat-sheriff', 'stickers/sticker-hat-sheriff.png');
	      this.addSticker('heart', 'stickers/sticker-heart.png');
	      this.addSticker('mustache-long', 'stickers/sticker-mustache-long.png');
	      this.addSticker('mustache1', 'stickers/sticker-mustache1.png');
	      this.addSticker('mustache2', 'stickers/sticker-mustache2.png');
	      this.addSticker('mustache3', 'stickers/sticker-mustache3.png');
	      this.addSticker('pipe', 'stickers/sticker-pipe.png');
	      this.addSticker('snowflake', 'stickers/sticker-snowflake.png');
	      this.addSticker('star', 'stickers/sticker-star.png');
	    }
	
	    /**
	     * Registers the sticker with the given identifier and path
	     * @private
	     */
	  }, {
	    key: 'addSticker',
	    value: function addSticker(identifier, path) {
	      this._availableStickers[identifier] = path;
	      this._stickers[identifier] = this._availableStickers[identifier];
	
	      if (this._active) {
	        this._renderControls();
	      }
	    }
	
	    /**
	     * Selects the stickers
	     * @param {Selector} selector
	     */
	  }, {
	    key: 'selectStickers',
	    value: function selectStickers(selector) {
	      this._stickers = {};
	
	      var stickerIdentifiers = Object.keys(this._availableStickers);
	
	      var selectedStickers = _libUtils2['default'].select(stickerIdentifiers, selector);
	      for (var i = 0; i < selectedStickers.length; i++) {
	        var identifier = selectedStickers[i];
	        this._stickers[identifier] = this._availableStickers[identifier];
	      }
	
	      if (this._active) {
	        this._renderControls();
	      }
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._operationExistedBefore = !!this._ui.operations.stickers;
	      this._operation = this._ui.getOrCreateOperation('stickers');
	
	      // Don't render initially
	      this._ui.removeOperation('stickers');
	
	      this._initialSettings = {
	        sticker: this._operation.getSticker(),
	        position: this._operation.getPosition().clone(),
	        size: this._operation.getSize().clone()
	      };
	
	      var canvasSize = this._ui.canvas.size;
	
	      this._size = this._initialSettings.size.clone();
	      this._position = this._initialSettings.position.clone().multiply(canvasSize);
	
	      // Remember zoom level and zoom to fit the canvas
	      this._initialZoomLevel = this._ui.canvas.zoomLevel;
	      this._ui.canvas.zoomToFit();
	
	      // Find DOM elements
	      this._container = this._canvasControls.querySelector('.imglykit-canvas-stickers');
	      this._stickerImage = this._canvasControls.querySelector('img');
	      this._stickerImage.addEventListener('load', function () {
	        _this._stickerSize = new _libMathVector22['default'](_this._stickerImage.width, _this._stickerImage.height);
	        _this._onStickerLoad();
	      });
	      this._knob = this._canvasControls.querySelector('div.imglykit-knob');
	
	      // Mouse event callbacks bound to the class context
	      this._onImageDown = this._onImageDown.bind(this);
	      this._onImageDrag = this._onImageDrag.bind(this);
	      this._onImageUp = this._onImageUp.bind(this);
	      this._onKnobDown = this._onKnobDown.bind(this);
	      this._onKnobDrag = this._onKnobDrag.bind(this);
	      this._onKnobUp = this._onKnobUp.bind(this);
	
	      this._renderListItems();
	      this._handleListItems();
	      this._handleImage();
	      this._handleKnob();
	    }
	
	    /**
	     * Renders the stickers on the list item canvas elements
	     * @private
	     */
	  }, {
	    key: '_renderListItems',
	    value: function _renderListItems() {
	      var _this2 = this;
	
	      var canvasItems = this._controls.querySelectorAll('li canvas');
	      this._canvasItems = Array.prototype.slice.call(canvasItems);
	
	      var _loop = function (i) {
	        var canvas = _this2._canvasItems[i];
	        canvas.width = canvas.offsetWidth;
	        canvas.height = canvas.offsetHeight;
	
	        var context = canvas.getContext('2d');
	        var image = canvas.getAttribute('data-image');
	        var imageEl = document.createElement('img');
	
	        var canvasSize = new _libMathVector22['default'](canvas.width, canvas.height);
	
	        imageEl.addEventListener('load', function () {
	          var imageSize = new _libMathVector22['default'](imageEl.width, imageEl.height);
	          var newSize = _libUtils2['default'].resizeVectorToFit(imageSize, canvasSize);
	
	          var offset = canvasSize.clone().divide(2).subtract(newSize.clone().divide(2));
	
	          context.drawImage(imageEl, 0, 0, imageSize.x, imageSize.y, offset.x, offset.y, newSize.x, newSize.y);
	        });
	
	        imageEl.src = image;
	      };
	
	      for (var i = 0; i < this._canvasItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Handles the list item click events
	     * @private
	     */
	  }, {
	    key: '_handleListItems',
	    value: function _handleListItems() {
	      var _this3 = this;
	
	      var listItems = this._controls.querySelectorAll('li');
	      this._listItems = Array.prototype.slice.call(listItems);
	
	      // Listen to click events
	
	      var _loop2 = function (i) {
	        var listItem = _this3._listItems[i];
	        var identifier = listItem.getAttribute('data-identifier');
	        listItem.addEventListener('click', function () {
	          _this3._onListItemClick(listItem);
	        });
	
	        if (!_this3._operationExistedBefore && i === 0 || _this3._operationExistedBefore && _this3._stickers[identifier] === _this3._initialSettings.sticker) {
	          _this3._onListItemClick(listItem, false);
	        }
	      };
	
	      for (var i = 0; i < this._listItems.length; i++) {
	        _loop2(i);
	      }
	    }
	
	    /**
	     * Resizes and positions the sticker according to the current settings
	     * @private
	     */
	  }, {
	    key: '_applySettings',
	    value: function _applySettings() {
	      var ratio = this._stickerSize.y / this._stickerSize.x;
	      this._size.y = this._size.x * ratio;
	
	      this._stickerImage.style.width = this._size.x + 'px';
	      this._stickerImage.style.height = this._size.y + 'px';
	      this._container.style.left = this._position.x + 'px';
	      this._container.style.top = this._position.y + 'px';
	    }
	
	    /**
	     * Gets called when the user hits the back button
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (this._operationExistedBefore) {
	        this._operation = this._ui.getOrCreateOperation('stickers');
	        this._operation.set(this._initialSettings);
	      } else {
	        this._ui.removeOperation('stickers');
	      }
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel);
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @protected
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      // Map the position and size options to 0...1 values
	      var canvasSize = this._ui.canvas.size;
	      var position = this._position.clone().divide(canvasSize);
	      var size = this._size.clone().divide(canvasSize);
	
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel, false);
	
	      // Create a new operation and render it
	      this._operation = this._ui.getOrCreateOperation('stickers');
	      this._operation.set({
	        sticker: this._availableStickers[this._sticker],
	        position: position,
	        size: size
	      });
	      this._ui.canvas.render();
	
	      this._ui.addHistory(this, {
	        sticker: this._initialSettings.sticker,
	        position: this._initialSettings.position.clone(),
	        size: this._initialSettings.size.clone()
	      }, this._operationExistedBefore);
	    }
	
	    /**
	     * Handles the knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleKnob',
	    value: function _handleKnob() {
	      this._knob.addEventListener('mousedown', this._onKnobDown);
	      this._knob.addEventListener('touchstart', this._onKnobDown);
	    }
	
	    /**
	     * Gets called when the user clicks the knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onKnobDown',
	    value: function _onKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialSize = this._size.clone();
	
	      document.addEventListener('mousemove', this._onKnobDrag);
	      document.addEventListener('touchmove', this._onKnobDrag);
	
	      document.addEventListener('mouseup', this._onKnobUp);
	      document.addEventListener('touchend', this._onKnobUp);
	    }
	
	    /**
	     * Gets called when the user drags the knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onKnobDrag',
	    value: function _onKnobDrag(e) {
	      e.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.clone().subtract(this._initialMousePosition);
	
	      var size = this._initialSize.clone();
	      var ratio = this._stickerImage.height / this._stickerImage.width;
	      size.x += diff.x;
	      size.y = size.x * ratio;
	
	      this._size.copy(size);
	
	      this._applySettings();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Gets called when the user releases the knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onKnobUp',
	    value: function _onKnobUp() {
	      document.removeEventListener('mousemove', this._onKnobDrag);
	      document.removeEventListener('touchmove', this._onKnobDrag);
	
	      document.removeEventListener('mouseup', this._onKnobUp);
	      document.removeEventListener('touchend', this._onKnobUp);
	    }
	
	    /**
	     * Handles the image dragging
	     * @private
	     */
	  }, {
	    key: '_handleImage',
	    value: function _handleImage() {
	      this._stickerImage.addEventListener('mousedown', this._onImageDown);
	      this._stickerImage.addEventListener('touchstart', this._onImageDown);
	    }
	
	    /**
	     * Gets called when the user clicks the image
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onImageDown',
	    value: function _onImageDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialPosition = this._position.clone();
	
	      document.addEventListener('mousemove', this._onImageDrag);
	      document.addEventListener('touchmove', this._onImageDrag);
	
	      document.addEventListener('mouseup', this._onImageUp);
	      document.addEventListener('touchend', this._onImageUp);
	    }
	
	    /**
	     * Gets called when the user drags the image
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onImageDrag',
	    value: function _onImageDrag(e) {
	      e.preventDefault();
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.clone().subtract(this._initialMousePosition);
	
	      var position = this._initialPosition.clone();
	      position.add(diff);
	
	      this._position.copy(position);
	
	      this._applySettings();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Gets called when the user releases the image
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onImageUp',
	    value: function _onImageUp() {
	      document.removeEventListener('mousemove', this._onImageDrag);
	      document.removeEventListener('touchmove', this._onImageDrag);
	
	      document.removeEventListener('mouseup', this._onImageUp);
	      document.removeEventListener('touchend', this._onImageUp);
	    }
	
	    /**
	     * Gets called as soon as the sticker image has been loaded
	     * @private
	     */
	  }, {
	    key: '_onStickerLoad',
	    value: function _onStickerLoad() {
	      this._size = new _libMathVector22['default'](this._stickerImage.width, this._stickerImage.height);
	
	      if (typeof this._position === 'undefined') {
	        this._position = new _libMathVector22['default'](0, 0);
	      }
	
	      this._applySettings();
	    }
	
	    /**
	     * Gets called when the user clicked a list item
	     * @private
	     */
	  }, {
	    key: '_onListItemClick',
	    value: function _onListItemClick(item) {
	      var manually = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	      this._deactivateAllItems();
	
	      var identifier = item.getAttribute('data-identifier');
	      var stickerPath = this._availableStickers[identifier];
	      stickerPath = this._kit.getAssetPath(stickerPath);
	
	      try {
	        this._stickerImage.attributes.removeNamedItem('style');
	      } catch (e) {}
	
	      this._sticker = identifier;
	      this._stickerImage.src = stickerPath;
	
	      _libUtils2['default'].classList(item).add('imglykit-controls-item-active');
	
	      if (manually) {
	        this._highlightDoneButton();
	      }
	    }
	
	    /**
	     * Deactivates all list items
	     * @private
	     */
	  }, {
	    key: '_deactivateAllItems',
	    value: function _deactivateAllItems() {
	      for (var i = 0; i < this._listItems.length; i++) {
	        var listItem = this._listItems[i];
	        _libUtils2['default'].classList(listItem).remove('imglykit-controls-item-active');
	      }
	    }
	
	    /**
	     * The data that is available to the template
	     * @type {Object}
	     * @override
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      var context = _get(Object.getPrototypeOf(StickersControl.prototype), 'context', this);
	      context.stickers = this._stickers;
	      return context;
	    }
	  }]);
	
	  return StickersControl;
	})(_control2['default']);
	
	StickersControl.prototype.identifier = 'stickers';
	
	exports['default'] = StickersControl;
	module.exports = exports['default'];

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x2, _x3, _x4) { var _again = true; _function: while (_again) { var object = _x2, property = _x3, receiver = _x4; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x2 = parent; _x3 = property; _x4 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libColorPicker = __webpack_require__(108);
	
	var _libColorPicker2 = _interopRequireDefault(_libColorPicker);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var TextControl = (function (_Control) {
	  _inherits(TextControl, _Control);
	
	  function TextControl() {
	    _classCallCheck(this, TextControl);
	
	    _get(Object.getPrototypeOf(TextControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(TextControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='<div> <ul class="imglykit-controls-list imgly-controls-list-with-buttons"> ';var arr1=it.fonts;if(arr1){var value,index=-1,l1=arr1.length-1;while(index<l1){value=arr1[index+=1];out+=' <li data-name="'+( value.name)+'" data-weight="'+( value.weight)+'"> <canvas class="imglykit-controls-item-canvas"></canvas> </li> ';} } out+=' </ul></div><div class="imglykit-controls-button"> '+( it.partials.fgColorPicker)+'</div><div class="imglykit-controls-button"> '+( it.partials.bgColorPicker)+'</div>'+( it.partials.doneButton);return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-text-container"> <div class="imglykit-canvas-text"> <div class="imglykit-crosshair"> <img src="'+(it.helpers.assetPath('ui/night/crosshair.png'))+'" /> </div> <div class="imglykit-canvas-text-textarea"> <textarea></textarea> <div class="imglykit-knob"></div> </div> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      this._partialTemplates.fgColorPicker = _libColorPicker2['default'].template;
	      this._partialTemplates.fgColorPicker.additionalContext = {
	        id: 'imglykit-text-foreground-color-picker'
	      };
	
	      this._partialTemplates.bgColorPicker = _libColorPicker2['default'].template;
	      this._partialTemplates.bgColorPicker.additionalContext = {
	        id: 'imglykit-text-background-color-picker'
	      };
	
	      this._fonts = [];
	      this._addFonts();
	    }
	  }, {
	    key: '_renderControls',
	    value: function _renderControls() {
	      this._partialTemplates.fgColorPicker.additionalContext.label = this._ui.translate('controls.text.foreground');
	      this._partialTemplates.bgColorPicker.additionalContext.label = this._ui.translate('controls.text.background');
	      _get(Object.getPrototypeOf(TextControl.prototype), '_renderControls', this).call(this);
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      var _this = this;
	
	      this._operationExistedBefore = !!this._ui.operations.text;
	      this._operation = this._ui.getOrCreateOperation('text');
	
	      // Don't render initially
	      this._ui.removeOperation('text');
	
	      var canvasSize = this._ui.canvas.size;
	
	      this._initialSettings = {
	        lineHeight: this._operation.getLineHeight(),
	        fontSize: this._operation.getFontSize(),
	        fontFamily: this._operation.getFontFamily(),
	        fontWeight: this._operation.getFontWeight(),
	        color: this._operation.getColor(),
	        position: this._operation.getPosition(),
	        text: this._operation.getText() || '',
	        maxWidth: this._operation.getMaxWidth(),
	        backgroundColor: this._operation.getBackgroundColor()
	      };
	
	      this._settings = {
	        lineHeight: this._initialSettings.lineHeight,
	        fontSize: this._initialSettings.fontSize,
	        fontFamily: this._initialSettings.fontFamily,
	        fontWeight: this._initialSettings.fontWeight,
	        color: this._initialSettings.color.clone(),
	        position: this._initialSettings.position.clone().multiply(canvasSize),
	        text: this._initialSettings.text,
	        maxWidth: this._initialSettings.maxWidth * canvasSize.x,
	        backgroundColor: this._initialSettings.backgroundColor.clone()
	      };
	
	      // Remember zoom level and zoom to fit the canvas
	      this._initialZoomLevel = this._ui.canvas.zoomLevel;
	
	      this._container = this._canvasControls.querySelector('.imglykit-canvas-text');
	      this._textarea = this._canvasControls.querySelector('textarea');
	      this._textarea.focus();
	
	      this._moveKnob = this._canvasControls.querySelector('.imglykit-crosshair');
	      this._resizeKnob = this._canvasControls.querySelector('.imglykit-knob');
	
	      // If the text has been edited before, subtract the knob width and padding
	      if (this._operationExistedBefore) {
	        this._settings.position.x -= 2;
	        this._settings.position.y -= 2;
	      }
	
	      this._onTextareaKeyUp = this._onTextareaKeyUp.bind(this);
	      this._onResizeKnobDown = this._onResizeKnobDown.bind(this);
	      this._onResizeKnobDrag = this._onResizeKnobDrag.bind(this);
	      this._onResizeKnobUp = this._onResizeKnobUp.bind(this);
	      this._onMoveKnobDown = this._onMoveKnobDown.bind(this);
	      this._onMoveKnobDrag = this._onMoveKnobDrag.bind(this);
	      this._onMoveKnobUp = this._onMoveKnobUp.bind(this);
	      this._onForegroundColorUpdate = this._onForegroundColorUpdate.bind(this);
	      this._onBackgroundColorUpdate = this._onBackgroundColorUpdate.bind(this);
	
	      this._initColorPickers();
	      this._renderListItems();
	      this._handleListItems();
	      this._handleTextarea();
	      this._handleResizeKnob();
	      this._handleMoveKnob();
	
	      // Resize asynchronously to render a frame
	      setTimeout(function () {
	        _this._resizeTextarea();
	      }, 1);
	
	      this._ui.canvas.zoomToFit().then(function () {
	        _this._applySettings();
	      });
	    }
	
	    /**
	     * Initializes the color pickers
	     * @private
	     */
	  }, {
	    key: '_initColorPickers',
	    value: function _initColorPickers() {
	      var _this2 = this;
	
	      var foregroundColorPicker = this._controls.querySelector('#imglykit-text-foreground-color-picker');
	      this._foregroundColorPicker = new _libColorPicker2['default'](this._ui, foregroundColorPicker);
	      this._foregroundColorPicker.setValue(this._operation.getColor());
	      this._foregroundColorPicker.on('update', this._onForegroundColorUpdate);
	      this._foregroundColorPicker.on('show', function () {
	        _this2._backgroundColorPicker.hide();
	      });
	
	      var backgroundColorPicker = this._controls.querySelector('#imglykit-text-background-color-picker');
	      this._backgroundColorPicker = new _libColorPicker2['default'](this._ui, backgroundColorPicker);
	      this._backgroundColorPicker.setValue(this._operation.getBackgroundColor());
	      this._backgroundColorPicker.on('update', this._onBackgroundColorUpdate);
	      this._backgroundColorPicker.on('show', function () {
	        _this2._foregroundColorPicker.hide();
	      });
	    }
	
	    /**
	     * Renders the text on the list item canvas elements
	     * @private
	     */
	  }, {
	    key: '_renderListItems',
	    value: function _renderListItems() {
	      var canvasItems = this._controls.querySelectorAll('li canvas');
	      this._canvasItems = Array.prototype.slice.call(canvasItems);
	
	      for (var i = 0; i < this._canvasItems.length; i++) {
	        var canvas = this._canvasItems[i];
	        canvas.width = canvas.offsetWidth;
	        canvas.height = canvas.offsetHeight;
	
	        var listItem = canvas.parentNode;
	
	        var context = canvas.getContext('2d');
	        var fontFamily = listItem.getAttribute('data-name');
	        var fontWeight = listItem.getAttribute('data-weight');
	
	        context.font = fontWeight + ' 30px ' + fontFamily;
	        context.textBaseline = 'middle';
	        context.textAlign = 'center';
	        context.fillStyle = 'white';
	
	        context.fillText(fontFamily.substr(0, 2), canvas.width / 2, canvas.height / 2);
	      }
	    }
	
	    /**
	     * Handles the list item click events
	     * @private
	     */
	  }, {
	    key: '_handleListItems',
	    value: function _handleListItems() {
	      var _this3 = this;
	
	      var listItems = this._controls.querySelectorAll('li');
	      this._listItems = Array.prototype.slice.call(listItems);
	
	      // Listen to click events
	
	      var _loop = function (i) {
	        var listItem = _this3._listItems[i];
	        var name = listItem.getAttribute('data-name');
	        listItem.addEventListener('click', function () {
	          _this3._onListItemClick(listItem);
	        });
	
	        if (!_this3._operationExistedBefore && i === 0 || _this3._operationExistedBefore && name === _this3._initialSettings.fontFamily) {
	          _this3._onListItemClick(listItem, false);
	        }
	      };
	
	      for (var i = 0; i < this._listItems.length; i++) {
	        _loop(i);
	      }
	    }
	
	    /**
	     * Handles the text area key events
	     * @private
	     */
	  }, {
	    key: '_handleTextarea',
	    value: function _handleTextarea() {
	      this._textarea.addEventListener('keyup', this._onTextareaKeyUp);
	    }
	
	    /**
	     * Gets called when the user releases a key inside the text area
	     * @private
	     */
	  }, {
	    key: '_onTextareaKeyUp',
	    value: function _onTextareaKeyUp() {
	      this._resizeTextarea();
	      this._settings.text = this._textarea.value;
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Resizes the text area to fit the text inside of it
	     * @private
	     */
	  }, {
	    key: '_resizeTextarea',
	    value: function _resizeTextarea() {
	      var scrollTop = this._textarea.scrollTop;
	
	      if (!scrollTop) {
	        var _scrollHeight = undefined,
	            height = undefined;
	        do {
	          _scrollHeight = this._textarea.scrollHeight;
	          height = this._textarea.offsetHeight;
	          this._textarea.style.height = height - 5 + 'px';
	        } while (_scrollHeight && _scrollHeight !== this._textarea.scrollHeight);
	      }
	
	      var scrollHeight = this._textarea.scrollHeight;
	      this._textarea.style.height = scrollHeight + 20 + 'px';
	    }
	
	    /**
	     * Handles the move knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleMoveKnob',
	    value: function _handleMoveKnob() {
	      this._moveKnob.addEventListener('mousedown', this._onMoveKnobDown);
	      this._moveKnob.addEventListener('touchstart', this._onMoveKnobDown);
	    }
	
	    /**
	     * Gets called when the user clicks the move knob
	     * @private
	     */
	  }, {
	    key: '_onMoveKnobDown',
	    value: function _onMoveKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialPosition = this._settings.position.clone();
	
	      document.addEventListener('mousemove', this._onMoveKnobDrag);
	      document.addEventListener('touchmove', this._onMoveKnobDrag);
	
	      document.addEventListener('mouseup', this._onMoveKnobUp);
	      document.addEventListener('touchend', this._onMoveKnobUp);
	    }
	
	    /**
	     * Gets called when the user drags the move knob
	     * @private
	     */
	  }, {
	    key: '_onMoveKnobDrag',
	    value: function _onMoveKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.clone().subtract(this._initialMousePosition);
	
	      var minPosition = new _libMathVector22['default'](0, 0);
	      var containerSize = new _libMathVector22['default'](this._container.offsetWidth, this._container.offsetHeight);
	      var maxPosition = canvasSize.clone().subtract(containerSize);
	      var position = this._initialPosition.clone().add(diff).clamp(minPosition, maxPosition);
	
	      this._settings.position = position;
	
	      this._container.style.left = position.x + 'px';
	      this._container.style.top = position.y + 'px';
	    }
	
	    /**
	     * Gets called when the user releases the move knob
	     * @private
	     */
	  }, {
	    key: '_onMoveKnobUp',
	    value: function _onMoveKnobUp() {
	      document.removeEventListener('mousemove', this._onMoveKnobDrag);
	      document.removeEventListener('touchmove', this._onMoveKnobDrag);
	
	      document.removeEventListener('mouseup', this._onMoveKnobUp);
	      document.removeEventListener('touchend', this._onMoveKnobUp);
	    }
	
	    /**
	     * Handles the resize knob dragging
	     * @private
	     */
	  }, {
	    key: '_handleResizeKnob',
	    value: function _handleResizeKnob() {
	      this._resizeKnob.addEventListener('mousedown', this._onResizeKnobDown);
	      this._resizeKnob.addEventListener('touchstart', this._onResizeKnobDown);
	    }
	
	    /**
	     * Gets called when the user clicks the resize knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onResizeKnobDown',
	    value: function _onResizeKnobDown(e) {
	      e.preventDefault();
	
	      this._initialMousePosition = _libUtils2['default'].getEventPosition(e);
	      this._initialMaxWidth = this._settings.maxWidth;
	
	      document.addEventListener('mousemove', this._onResizeKnobDrag);
	      document.addEventListener('touchmove', this._onResizeKnobDrag);
	
	      document.addEventListener('mouseup', this._onResizeKnobUp);
	      document.addEventListener('touchend', this._onResizeKnobUp);
	    }
	
	    /**
	     * Gets called when the user drags the resize knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onResizeKnobDrag',
	    value: function _onResizeKnobDrag(e) {
	      e.preventDefault();
	
	      var canvasSize = this._ui.canvas.size;
	      var mousePosition = _libUtils2['default'].getEventPosition(e);
	      var diff = mousePosition.subtract(this._initialMousePosition);
	
	      var position = this._settings.position.clone();
	      var maxWidthAllowed = canvasSize.x - position.x;
	
	      var maxWidth = this._initialMaxWidth + diff.x;
	      maxWidth = Math.max(100, Math.min(maxWidthAllowed, maxWidth));
	      this._settings.maxWidth = maxWidth;
	      this._textarea.style.width = maxWidth + 'px';
	
	      this._resizeTextarea();
	    }
	
	    /**
	     * Gets called when the user releases the resize knob
	     * @param {Event} e
	     * @private
	     */
	  }, {
	    key: '_onResizeKnobUp',
	    value: function _onResizeKnobUp() {
	      document.removeEventListener('mousemove', this._onResizeKnobDrag);
	      document.removeEventListener('touchmove', this._onResizeKnobDrag);
	
	      document.removeEventListener('mouseup', this._onResizeKnobUp);
	      document.removeEventListener('touchend', this._onResizeKnobUp);
	    }
	
	    /**
	     * Gets called when the user selects another color using
	     * the color picker.
	     * @param {Color} value
	     * @private
	     */
	  }, {
	    key: '_onForegroundColorUpdate',
	    value: function _onForegroundColorUpdate(value) {
	      this._settings.color = value;
	      this._applySettings();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Gets called when the user selects another color using
	     * the color picker.
	     * @param {Color} value
	     * @private
	     */
	  }, {
	    key: '_onBackgroundColorUpdate',
	    value: function _onBackgroundColorUpdate(value) {
	      this._settings.backgroundColor = value;
	      this._applySettings();
	      this._highlightDoneButton();
	    }
	
	    /**
	     * Styles the textarea to represent the current settings
	     * @private
	     */
	  }, {
	    key: '_applySettings',
	    value: function _applySettings() {
	      var textarea = this._textarea;
	      var settings = this._settings;
	
	      var canvasSize = this._ui.canvas.size;
	      var actualFontSize = settings.fontSize * canvasSize.y;
	
	      this._container.style.left = settings.position.x + 'px';
	      this._container.style.top = settings.position.y + 'px';
	
	      textarea.value = settings.text;
	      textarea.style.fontFamily = settings.fontFamily;
	      textarea.style.fontSize = actualFontSize + 'px';
	      textarea.style.fontWeight = settings.fontWeight;
	      textarea.style.lineHeight = settings.lineHeight;
	      textarea.style.color = settings.color.toRGBA();
	      textarea.style.backgroundColor = settings.backgroundColor.toRGBA();
	      textarea.style.width = settings.maxWidth + 'px';
	    }
	
	    /**
	     * Gets called when the user clicked a list item
	     * @private
	     */
	  }, {
	    key: '_onListItemClick',
	    value: function _onListItemClick(item) {
	      var manually = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	      this._deactivateAllItems();
	
	      var name = item.getAttribute('data-name');
	      var weight = item.getAttribute('data-weight');
	      this._settings.fontFamily = name;
	      this._settings.fontWeight = weight;
	
	      this._applySettings();
	
	      _libUtils2['default'].classList(item).add('imglykit-controls-item-active');
	
	      if (manually) {
	        this._highlightDoneButton();
	      }
	    }
	
	    /**
	     * Deactivates all list items
	     * @private
	     */
	  }, {
	    key: '_deactivateAllItems',
	    value: function _deactivateAllItems() {
	      for (var i = 0; i < this._listItems.length; i++) {
	        var listItem = this._listItems[i];
	        _libUtils2['default'].classList(listItem).remove('imglykit-controls-item-active');
	      }
	    }
	
	    /**
	     * Adds the default fonts
	     * @private
	     */
	  }, {
	    key: '_addFonts',
	    value: function _addFonts() {
	      this.addFont('Helvetica', 'normal');
	      this.addFont('Verdana', 'normal');
	      this.addFont('Times New Roman', 'normal');
	    }
	
	    /**
	     * Adds a font with the given name and weight
	     * @param {String} name
	     * @param {String} weight
	     */
	  }, {
	    key: 'addFont',
	    value: function addFont(name, weight) {
	      this._fonts.push({ name: name, weight: weight });
	    }
	
	    /**
	     * Gets called when the done button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onDone',
	    value: function _onDone() {
	      var canvasSize = this._ui.canvas.size;
	      var padding = new _libMathVector22['default'](2, 2);
	      var position = this._settings.position.clone().add(padding).divide(canvasSize);
	
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel, false);
	
	      this._operation = this._ui.getOrCreateOperation('text');
	      this._operation.set({
	        fontSize: this._settings.fontSize,
	        fontFamily: this._settings.fontFamily,
	        fontWeight: this._settings.fontWeight,
	        color: this._settings.color,
	        backgroundColor: this._settings.backgroundColor,
	        position: position,
	        text: this._settings.text,
	        maxWidth: this._settings.maxWidth / canvasSize.x
	      });
	      this._ui.canvas.render();
	
	      this._ui.addHistory(this, {
	        fontFamily: this._initialSettings.fontFamily,
	        fontWeight: this._initialSettings.fontWeight,
	        color: this._initialSettings.color.clone(),
	        backgroundColor: this._initialSettings.backgroundColor.clone(),
	        position: this._initialSettings.position.clone(),
	        text: this._initialSettings.text,
	        maxWidth: this._initialSettings.maxWidth
	      }, this._operationExistedBefore);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (this._operationExistedBefore) {
	        this._operation = this._ui.getOrCreateOperation('text');
	        this._operation.set(this._initialSettings);
	      } else {
	        this._ui.removeOperation('text');
	      }
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel);
	    }
	
	    /**
	     * The data that is available to the template
	     * @type {Object}
	     * @override
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      var context = _get(Object.getPrototypeOf(TextControl.prototype), 'context', this);
	      context.fonts = this._fonts;
	      return context;
	    }
	  }]);
	
	  return TextControl;
	})(_control2['default']);
	
	TextControl.prototype.identifier = 'text';
	
	exports['default'] = TextControl;
	module.exports = exports['default'];

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	/* global __DOTJS_TEMPLATE */
	/*
	 * Photo Editor SDK - photoeditorsdk.com
	 * Copyright (c) 2013-2015 9elements GmbH
	 *
	 * Released under Attribution-NonCommercial 3.0 Unported
	 * http://creativecommons.org/licenses/by-nc/3.0/
	 *
	 * For commercial use, please contact us at contact@9elements.com
	 */
	
	'use strict';
	
	Object.defineProperty(exports, '__esModule', {
	  value: true
	});
	
	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();
	
	var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }
	
	function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
	
	var _control = __webpack_require__(96);
	
	var _control2 = _interopRequireDefault(_control);
	
	var _libMathVector2 = __webpack_require__(4);
	
	var _libMathVector22 = _interopRequireDefault(_libMathVector2);
	
	var _libUtils = __webpack_require__(13);
	
	var _libUtils2 = _interopRequireDefault(_libUtils);
	
	var _libSimpleSlider = __webpack_require__(105);
	
	var _libSimpleSlider2 = _interopRequireDefault(_libSimpleSlider);
	
	var _libColorPicker = __webpack_require__(108);
	
	var _libColorPicker2 = _interopRequireDefault(_libColorPicker);
	
	var _libColor = __webpack_require__(23);
	
	var _libColor2 = _interopRequireDefault(_libColor);
	
	var BrushControl = (function (_Control) {
	  _inherits(BrushControl, _Control);
	
	  function BrushControl() {
	    _classCallCheck(this, BrushControl);
	
	    _get(Object.getPrototypeOf(BrushControl.prototype), 'constructor', this).apply(this, arguments);
	  }
	
	  /**
	   * A unique string that identifies this control.
	   * @type {String}
	   */
	
	  _createClass(BrushControl, [{
	    key: 'init',
	
	    /**
	     * Entry point for this control
	     */
	    value: function init() {
	      var controlsTemplate = function(it
	/**/) {
	var out='';if(it.displayThickness){out+=' <div> '+( it.partials.slider)+' </div>';}else{out+=' <div> <ul class="imglykit-controls-list imglykit-controls-list-overflow"> <li class="imglykit-controls-item--with-label" id="imglykit-thickness-button"> <img src="'+(it.helpers.assetPath('ui/night/brush/thickness@2x.png') )+'" /> <div class="imglykit-controls-label">Thickness</div> </li> <li> '+( it.partials.colorPicker)+' </li> </ul> </div>';}return out;
	};
	      this._controlsTemplate = controlsTemplate;
	
	      var canvasControlsTemplate = function(it
	/**/) {
	var out='<div class="imglykit-canvas-brush-container"> <div class="imglykit-canvas-brush"> <canvas></canvas> </div> <div id="imglykit-brush-cursor"> </div></div>';return out;
	};
	      this._canvasControlsTemplate = canvasControlsTemplate;
	
	      this._partialTemplates.slider = _libSimpleSlider2['default'].template;
	      this._partialTemplates.colorPicker = _libColorPicker2['default'].template;
	
	      this._displayThickness = false;
	      this._painting = false;
	    }
	
	    /**
	     * Renders the controls
	     */
	  }, {
	    key: '_renderControls',
	    value: function _renderControls() {
	      this._partialTemplates.colorPicker.additionalContext = { label: this._ui.translate('controls.brush.color') };
	      _get(Object.getPrototypeOf(BrushControl.prototype), '_renderControls', this).call(this);
	    }
	
	    /**
	     * Gets called when this control is activated
	     * @override
	     */
	  }, {
	    key: '_onEnter',
	    value: function _onEnter() {
	      _get(Object.getPrototypeOf(BrushControl.prototype), '_onEnter', this).call(this);
	      this._handleThicknessButton();
	      this._setupCanvas();
	      this._setupOperation();
	      this._setupOptions();
	      this._bindEventHandlers();
	      this._setupContainer();
	      this._setupSlider();
	      this._initCurrentValues();
	      this._setupColorPicker();
	
	      this._initialZoomLevel = this._ui.canvas.zoomLevel;
	      this._ui.canvas.zoomToFit();
	
	      this._setupCursor();
	    }
	
	    /**
	     * Handles the thickness button
	     * @private
	     */
	  }, {
	    key: '_handleThicknessButton',
	    value: function _handleThicknessButton() {
	      if (this._displayThickness) return;
	
	      this._thicknessButton = this._controlsContainer.querySelector('#imglykit-thickness-button');
	      this._thicknessButton.addEventListener('click', this._onThicknessButtonClick.bind(this));
	    }
	
	    /**
	     * Gets called when the thickness button has been clicked
	     * @param  {Event} e
	     * @private
	     */
	  }, {
	    key: '_onThicknessButtonClick',
	    value: function _onThicknessButtonClick(e) {
	      e.preventDefault();
	      this._displayThickness = true;
	      this.enter();
	    }
	
	    /**
	     * This method sets the inital values for thickness and color.
	     * It will retrieve them from the opteration unless it has no values yet.
	     * In that case it will default some vales
	     */
	  }, {
	    key: '_initCurrentValues',
	    value: function _initCurrentValues() {
	      this._currentThickness = this._currentThickness || this._operation.getLastThickness();
	      this._currentColor = this._currentColor || this._operation.getLastColor();
	    }
	
	    /**
	     * Sets up the cursor
	     */
	  }, {
	    key: '_setupCursor',
	    value: function _setupCursor() {
	      this._cursor = this._canvasControls.querySelector('#imglykit-brush-cursor');
	      this._setCursorSize(this._currentThickness * this._getLongerSideSize());
	      this._setCursorColor(this._currentColor);
	    }
	
	    /**
	     * Sets the initital options up
	     */
	  }, {
	    key: '_setupOptions',
	    value: function _setupOptions() {
	      this._initialOptions = {
	        paths: this._operation.getPaths().slice(0)
	      };
	    }
	
	    /**
	     * Sets up the canvas
	     * @private
	     */
	  }, {
	    key: '_setupCanvas',
	    value: function _setupCanvas() {
	      var canvas = this._ui.canvas;
	
	      this._canvas = this._canvasControls.querySelector('canvas');
	      this._canvas.width = canvas.size.x;
	      this._canvas.height = canvas.size.y;
	    }
	
	    /**
	     * Sets up the operation
	     */
	  }, {
	    key: '_setupOperation',
	    value: function _setupOperation() {
	      this._operationExistedBefore = !!this._ui.operations.brush;
	      this._operation = this._ui.getOrCreateOperation('brush');
	    }
	
	    /**
	     * Sets up the container, adds events, etc
	     */
	  }, {
	    key: '_setupContainer',
	    value: function _setupContainer() {
	      this._container = this._canvasControls.querySelector('.imglykit-canvas-brush-container');
	      this._container.addEventListener('mousedown', this._onMouseDown);
	      this._container.addEventListener('touchstart', this._onMouseDown);
	      this._container.addEventListener('mouseup', this._onMouseUp);
	      this._container.addEventListener('touchend', this._onMouseUp);
	      document.addEventListener('mousemove', this._onMouseMove);
	      document.addEventListener('touchmove', this._onMouseMove);
	      this._container.addEventListener('mouseleave', this._onMouseLeave);
	    }
	
	    /**
	     * Bind event handlers
	     */
	  }, {
	    key: '_bindEventHandlers',
	    value: function _bindEventHandlers() {
	      this._onMouseDown = this._onMouseDown.bind(this);
	      this._onMouseUp = this._onMouseUp.bind(this);
	      this._onMouseMove = this._onMouseMove.bind(this);
	      this._onMouseLeave = this._onMouseLeave.bind(this);
	    }
	
	    /**
	     * Sets up the slider used to change the brush size
	     */
	  }, {
	    key: '_setupSlider',
	    value: function _setupSlider() {
	      if (!this._displayThickness) return;
	
	      var sliderElement = this._controls.querySelector('.imglykit-slider');
	      this._slider = new _libSimpleSlider2['default'](sliderElement, {
	        minValue: 0.01,
	        maxValue: 0.2
	      });
	      this._onThicknessUpdate = this._onThicknessUpdate.bind(this);
	      this._slider.on('update', this._onThicknessUpdate);
	      this._slider.setValue(this._currentThickness);
	    }
	
	    /**
	     * Sets up the color picker used to change the brush color
	     */
	  }, {
	    key: '_setupColorPicker',
	    value: function _setupColorPicker() {
	      if (this._displayThickness) return;
	
	      var colorPickerElement = this._controls.querySelector('.imglykit-color-picker');
	      this._colorPicker = new _libColorPicker2['default'](this._ui, colorPickerElement);
	      this._colorPicker.on('update', this._onColorUpdate.bind(this));
	      this._colorPicker.setValue(this._currentColor);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @private
	     */
	  }, {
	    key: '_onBackButtonClick',
	    value: function _onBackButtonClick() {
	      if (this._displayThickness) {
	        this._displayThickness = false;
	        return this.enter();
	      }
	
	      _get(Object.getPrototypeOf(BrushControl.prototype), '_onBackButtonClick', this).call(this);
	    }
	
	    /**
	     * Gets called when the back button has been clicked
	     * @override
	     */
	  }, {
	    key: '_onBack',
	    value: function _onBack() {
	      if (!this._operationExistedBefore && !this._operation.getPaths().length) {
	        this._ui.removeOperation('brush');
	      } else {
	        this._operation.dirty = true;
	      }
	      this._ui.canvas.setZoomLevel(this._initialZoomLevel);
	    }
	
	    /**
	     * Resets the operation options to the initial options
	     */
	  }, {
	    key: '_resetOperationSettings',
	    value: function _resetOperationSettings() {
	      this._operation.setPaths(this._initialOptions.paths);
	    }
	
	    /**
	     * Gets called when the user presses the mouse button.
	     * Here the painting phase is started
	     * @param  {Event} e
	     */
	  }, {
	    key: '_onMouseDown',
	    value: function _onMouseDown(e) {
	      var paths = this._operation.getPaths().slice(0);
	      this._operationExistedBeforeDraw = !!paths.length;
	      this._optionsBeforeDraw = { paths: paths };
	
	      if (_libUtils2['default'].isTouchEvent(e)) {
	        this._showCursor();
	      }
	      this._startPaint(e);
	    }
	
	    /**
	     * start painting
	     * @param  {Event} event
	     */
	  }, {
	    key: '_startPaint',
	    value: function _startPaint(event) {
	      event.preventDefault();
	      var mousePosition = this._getRelativeMousePositionFromEvent(event);
	      this._painting = true;
	
	      this._currentPath = this._operation.createPath(this._currentThickness, this._currentColor);
	      this._currentPath.addControlPoint(mousePosition);
	
	      this._redrawPath();
	    }
	
	    /**
	     * Gets called the the users releases the mouse button.
	     * Here the painting phase is stopped
	     * @param  {Event} e
	     */
	  }, {
	    key: '_onMouseUp',
	    value: function _onMouseUp(e) {
	      if (_libUtils2['default'].isTouchEvent(e)) {
	        this._hideCursor();
	      }
	      this._stopPaint();
	      this._ui.addHistory(this, {
	        paths: this._optionsBeforeDraw.paths
	      }, this._operationExistedBeforeDraw);
	    }
	
	    /**
	     * Stops the paint phase
	     */
	  }, {
	    key: '_stopPaint',
	    value: function _stopPaint() {
	      this._painting = false;
	    }
	
	    /**
	     * Redraws the current path
	     * @private
	     */
	  }, {
	    key: '_redrawPath',
	    value: function _redrawPath() {
	      this._operation.renderBrushCanvas(this._canvas, this._canvas);
	    }
	
	    /**
	     * Gets called when the user drags the mouse.
	     * If this happends while the mouse button is pressed,
	     * the visited points get added to the path
	     * @param  {Event} e
	     */
	  }, {
	    key: '_onMouseMove',
	    value: function _onMouseMove(e) {
	      var mousePosition = this._getRelativeMousePositionFromEvent(e);
	      if (!_libUtils2['default'].isTouchEvent(e)) {
	        this._moveCursorTo(mousePosition);
	        this._showCursor();
	      }
	      if (this._painting) {
	        this._currentPath.addControlPoint(mousePosition);
	        this._redrawPath();
	      }
	    }
	
	    /**
	     * Gets called when the user leaves the canvas.
	     * This will also stop the painting phase
	     * @param  {[type]} e [description]
	     * @return {[type]}   [description]
	     */
	  }, {
	    key: '_onMouseLeave',
	    value: function _onMouseLeave(e) {
	      this._hideCursor();
	    }
	
	    /**
	     * Calculates the mouse position, relative to the upper-left corner
	     * of the canvas
	     * @param  {Event} e
	     * @return {Vector2} The Mouse Position
	     */
	  }, {
	    key: '_getRelativeMousePositionFromEvent',
	    value: function _getRelativeMousePositionFromEvent(e) {
	      var clientRect = this._container.getBoundingClientRect();
	      var offset = new _libMathVector22['default'](clientRect.left, clientRect.top);
	      var absolutePosition = _libUtils2['default'].getEventPosition(e).subtract(offset);
	      return absolutePosition.divide(this._ui.canvas.size);
	    }
	
	    /**
	     * Gets called when the thickness has been changed
	     * @override
	     */
	  }, {
	    key: '_onThicknessUpdate',
	    value: function _onThicknessUpdate(value) {
	      this._currentThickness = value;
	      this._setCursorSize(this._currentThickness * this._getLongerSideSize());
	    }
	
	    /**
	     * Gets called when the color has been changed
	     * @override
	     */
	  }, {
	    key: '_onColorUpdate',
	    value: function _onColorUpdate(value) {
	      this._currentColor = value;
	      this._setCursorColor(value);
	    }
	
	    /**
	     * Returns the longer size of the ui canvas
	     * @return {Number}
	     */
	  }, {
	    key: '_getLongerSideSize',
	    value: function _getLongerSideSize() {
	      var size = this._ui.canvas.size;
	
	      return Math.max(size.x, size.y);
	    }
	
	    /**
	     * Moves our custom cursor to the specified position
	     * @param  {Vector2} position
	     */
	  }, {
	    key: '_moveCursorTo',
	    value: function _moveCursorTo(position) {
	      var halfThickness = this._currentThickness * this._getLongerSideSize() / 2.0;
	      this._cursor.style.left = position.x * this._ui.canvas.size.x - halfThickness + 'px';
	      this._cursor.style.top = position.y * this._ui.canvas.size.y - halfThickness + 'px';
	    }
	
	    /**
	     * Sets the curser size
	     * @param {Float} size
	     */
	  }, {
	    key: '_setCursorSize',
	    value: function _setCursorSize(size) {
	      this._cursor.style.width = size + 'px';
	      this._cursor.style.height = size + 'px';
	    }
	
	    /**
	     * Sets the cursor color
	     * @param {Color} color
	     */
	  }, {
	    key: '_setCursorColor',
	    value: function _setCursorColor(color) {
	      this._cursor.style.background = color.toHex();
	    }
	
	    /**
	     * Shows the cursor
	     */
	  }, {
	    key: '_showCursor',
	    value: function _showCursor() {
	      this._cursor.style.display = 'block';
	    }
	
	    /**
	     * Hides the cursor
	     */
	  }, {
	    key: '_hideCursor',
	    value: function _hideCursor() {
	      this._cursor.style.display = 'none';
	    }
	
	    /**
	     * The data that is available to the template
	     * @abstract
	     */
	  }, {
	    key: 'context',
	    get: function get() {
	      return {
	        displayThickness: this._displayThickness
	      };
	    }
	  }]);
	
	  return BrushControl;
	})(_control2['default']);
	
	BrushControl.prototype.identifier = 'brush';
	
	exports['default'] = BrushControl;
	module.exports = exports['default'];

/***/ },
/* 112 */
/***/ function(module, exports) {

	module.exports = {
		"operations": {
			"brightness": "Brightness",
			"contrast": "Contrast",
			"filters": "Filters",
			"flip": "Flip",
			"frames": "Frames",
			"radial-blur": "Radial Blur",
			"rotation": "Rotation",
			"saturation": "Saturation",
			"stickers": "Stickers",
			"text": "Text",
			"tilt-shift": "Tilt-Shift",
			"crop": "Crop",
			"brush": "Brush"
		},
		"top-controls": {
			"new": "New",
			"undo": "Undo",
			"export": "Export",
			"zoom": "Zoom"
		},
		"splash": {
			"upload": {
				"headline": "Upload a picture",
				"description": "Click here to upload a picture from your library or just drag and drop"
			},
			"or": "or",
			"webcam": {
				"headline": "Take a picture",
				"description": "Click here to take a picture with your webcam or phone"
			}
		},
		"generic": {
			"loading": "Loading",
			"exporting": "Exporting",
			"importing": "Importing",
			"color": "Color",
			"error_headline": "An error has occurred.",
			"warning_headline": "Warning!"
		},
		"controls": {
			"frames": {
				"color": "Color"
			},
			"brush": {
				"color": "Color"
			},
			"text": {
				"foreground": "Foreground",
				"background": "Background"
			}
		},
		"errors": {
			"WEBGL_CONTEXT_LOST": "Your browser took too long to render the image. Please try applying less operations.",
			"WEBGL_CONTEXT_LOST_LIMIT": "Your browser failed multiple times while rendering the image."
		},
		"warnings": {
			"image_resized": "Your image exceeds the maximum size of $1 megapixels and has therefore been resized to $2x$3 pixels."
		}
	};

/***/ },
/* 113 */
/***/ function(module, exports) {

	module.exports = {
		"operations": {
			"brightness": "Helligkeit",
			"contrast": "Kontrast",
			"filters": "Filter",
			"flip": "Spiegeln",
			"frames": "Rahmen",
			"radial-blur": "Radial Blur",
			"rotation": "Drehung",
			"saturation": "Sättigung",
			"stickers": "Sticker",
			"text": "Text",
			"tilt-shift": "Tilt-Shift",
			"crop": "Zuschneiden",
			"brush": "Malen"
		},
		"top-controls": {
			"new": "Neu",
			"undo": "Rückgängig",
			"export": "Exportieren",
			"zoom": "Zoom"
		},
		"splash": {
			"upload": {
				"headline": "Bild hochladen",
				"description": "Klicke hier, um ein Bild hochzuladen oder ziehe eine Bilddatei hier her"
			},
			"or": "oder",
			"webcam": {
				"headline": "Foto machen",
				"description": "Klicke hier, um ein Foto mit deiner Webcam oder deinem Smartphone zu machen"
			}
		},
		"generic": {
			"loading": "Laden",
			"exporting": "Exportiere",
			"importing": "Importiere",
			"error_headline": "Es ist ein Fehler aufgetreten.",
			"warning_headline": "Warnung!"
		},
		"controls": {
			"frames": {
				"color": "Farbe"
			},
			"brush": {
				"color": "Farbe"
			},
			"text": {
				"foreground": "Text",
				"background": "Hintergrund"
			}
		},
		"errors": {
			"context_lost": "Dein Browser hat zu lange gebraucht, um das Bild zu generieren. Bitte versuche es noch einmal.",
			"context_lost_limit": "Bild-Generierung ist mehrmals fehlgeschlagen."
		},
		"warnings": {
			"image_resized": "Dein Bild überschreitet die maximale Größe von $1 Megapixeln und wurde daher auf $2x$3 Pixel verkleinert."
		}
	};

/***/ }
/******/ ])
});
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCA2Nzk3MmNmMTU3ODJiYjg2M2JlZCIsIndlYnBhY2s6Ly8vLi9pbWdseWtpdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZXZlbnQtZW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcmVuZGVyLWltYWdlLmpzIiwid2VicGFjazovLy8uL2xpYi9pbWFnZS1kaW1lbnNpb25zLmpzIiwid2VicGFjazovLy8uL2xpYi9tYXRoL3ZlY3RvcjIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXJzL2NhbnZhcy1yZW5kZXJlci5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlcnMvcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vL2V4dGVybmFsIFwiY2FudmFzXCIiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL3Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL25hdGl2ZS1wcm9taXNlLW9ubHkuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tbmltZXIvRGV2ZWxvcG1lbnQvZ2l0aHViL0ZhbWlseURBTS9hcHAtZGFzaGJvYXJkL34vaW1nbHlraXQtc2RrL34vdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21uaW1lci9EZXZlbG9wbWVudC9naXRodWIvRmFtaWx5REFNL2FwcC1kYXNoYm9hcmQvfi9pbWdseWtpdC1zZGsvfi9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXJzL3dlYmdsLXJlbmRlcmVyLmpzIiwid2VicGFjazovLy8uL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL2xpYi9jbGFzcy1saXN0LmpzIiwid2VicGFjazovLy8uL2xpYi9pbWFnZS1leHBvcnRlci5qcyIsIndlYnBhY2s6Ly8vLi9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2V4aWYuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL2FycmF5LXN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvdmVyc2lvbi1jaGVja2VyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvcm90YXRpb24tb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL2xpYi9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvZXh0ZW5kLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmxpcC1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9tbmltZXIvRGV2ZWxvcG1lbnQvZ2l0aHViL0ZhbWlseURBTS9hcHAtZGFzaGJvYXJkL34vaW1nbHlraXQtc2RrL34vcGF0aC9wYXRoLmpzIiwid2VicGFjazovLy8vVXNlcnMvbW5pbWVyL0RldmVsb3BtZW50L2dpdGh1Yi9GYW1pbHlEQU0vYXBwLWRhc2hib2FyZC9+L2ltZ2x5a2l0LXNkay9+L3V0aWwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vL1VzZXJzL21uaW1lci9EZXZlbG9wbWVudC9naXRodWIvRmFtaWx5REFNL2FwcC1kYXNoYm9hcmQvfi9pbWdseWtpdC1zZGsvfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvbW5pbWVyL0RldmVsb3BtZW50L2dpdGh1Yi9GYW1pbHlEQU0vYXBwLWRhc2hib2FyZC9+L2ltZ2x5a2l0LXNkay9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy1zdGFjay5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zYXR1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3ByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvdG9uZS1jdXJ2ZS5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zb2Z0LWNvbG9yLW92ZXJsYXkuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZGVzYXR1cmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3g0MDAuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ3JheXNjYWxlLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2NvbnRyYXN0LmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dsb3cuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvZ29iYmxpbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9icmlnaHRuZXNzLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2lkZW50aXR5LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvc2F0dXJhdGlvbi1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9jb250cmFzdC1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9icmlnaHRuZXNzLW9wZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL3RpbHQtc2hpZnQtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL3ZlbmRvci9zdGFjay1ibHVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvcmFkaWFsLWJsdXItb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvdGV4dC1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9zdGlja2Vycy1vcGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9mcmFtZXMtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvYnJ1c2gtb3BlcmF0aW9uLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9hMTUtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9icmVlemUtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9idy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3aGFyZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2NlbHNpdXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9jaGVzdC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpeGllLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvZm9vZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZyaWRnZS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2Zyb250LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ2xhbS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2dvYmJsaW4tZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9rMS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2syLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvazYtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9rZHluYW1pYy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL2xlbmluLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvbG9tby1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9vcmNoaWQtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy9wb2xhLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYTY2OS1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3F1b3ppLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvc2VtaXJlZC1maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vb3BlcmF0aW9ucy9maWx0ZXJzL3N1bm55LWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi9vcGVyYXRpb25zL2ZpbHRlcnMvdGV4YXMtZmlsdGVyLmpzIiwid2VicGFjazovLy8uL29wZXJhdGlvbnMvZmlsdGVycy94NDAwLWZpbHRlci5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC91aS5qcyIsIndlYnBhY2s6Ly8vLi91aS9iYXNlL3VpLmpzIiwid2VicGFjazovLy8uL3VpL2Jhc2UvaGVscGVycy5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvY2FudmFzLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2xpYi9maWxlLWxvYWRlci5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvaW1hZ2UtcmVzaXplci5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvd2ViY2FtLWhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvbmlnaHQvbGliL3RvcC1jb250cm9scy5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvc2Nyb2xsYmFyLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL2ZpbHRlcnMtY29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9jb250cm9scy9jb250cm9sLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL3JvdGF0aW9uLWNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvbmlnaHQvY29udHJvbHMvZmxpcC1jb250cm9sLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL2JyaWdodG5lc3MtY29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvc2xpZGVyLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL2NvbnRyYXN0LWNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvbmlnaHQvY29udHJvbHMvc2F0dXJhdGlvbi1jb250cm9sLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL2Nyb3AtY29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9jb250cm9scy9yYWRpYWwtYmx1ci1jb250cm9sLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2xpYi9zaW1wbGUtc2xpZGVyLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL3RpbHQtc2hpZnQtY29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9jb250cm9scy9mcmFtZXMtY29udHJvbC5qcyIsIndlYnBhY2s6Ly8vLi91aS9uaWdodC9saWIvY29sb3ItcGlja2VyLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL3N0aWNrZXJzLWNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvbmlnaHQvY29udHJvbHMvdGV4dC1jb250cm9sLmpzIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2NvbnRyb2xzL2JydXNoLWNvbnRyb2wuanMiLCJ3ZWJwYWNrOi8vLy4vdWkvbmlnaHQvbGFuZy9lbi5qc29uIiwid2VicGFjazovLy8uL3VpL25pZ2h0L2xhbmcvZGUuanNvbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsTztBQ1ZBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVELGtDQUFpQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWxqQix5Q0FBd0MsbUJBQW1CLDRCQUE0QixrREFBa0QsZ0JBQWdCLGtEQUFrRCw4REFBOEQsMEJBQTBCLDRDQUE0Qyx1QkFBdUIsa0JBQWtCLEVBQUUsT0FBTyxjQUFjLGdCQUFnQixnQkFBZ0IsZUFBZSwyQkFBMkIsb0JBQW9CLEVBQUUsRUFBRSw0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LE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQLE1BQUs7QUFDTCxJQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUCxNQUFLO0FBQ0wsSUFBRzs7QUFFSDtBQUNBLEVBQUMsRTs7Ozs7OztBQzFXRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTJDLGlCQUFpQjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHOzs7Ozs7O0FDM0VBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWU7QUFDZixrQkFBaUI7QUFDakI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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LHdCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCLFlBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE0QyxLQUFLOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0Esb0NBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLDBEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWCxVQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBLFlBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDemtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRTs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLEVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxLQUFLO0FBQ3BCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQSxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVCxRQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZTtBQUNmOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckIsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1QsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxlQUFjO0FBQ2Q7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWM7QUFDZDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0EscUM7Ozs7OztBQzFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQsa0NBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbGpCLHdDQUF1QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixrQkFBa0IsRUFBRSxPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQixvQkFBb0IsRUFBRSxFQUFFLDRCQUE0QixtQkFBbUIsRUFBRSxPQUFPLHVCQUF1Qiw0QkFBNEIsa0JBQWtCLEVBQUUsOEJBQThCLEVBQUUsRUFBRTs7QUFFL29CLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0xBQXVMO0FBQ3ZMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRXQUEyVztBQUMzVztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7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QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQSxJQUFHOztBQUVIO0FBQ0EsRUFBQzs7QUFFRDs7QUFFQTtBQUNBLHFDOzs7Ozs7QUNqYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQsa0NBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbGpCLHdDQUF1QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixrQkFBa0IsRUFBRSxPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQixvQkFBb0IsRUFBRSxFQUFFLDRCQUE0QixtQkFBbUIsRUFBRSxPQUFPLHVCQUF1Qiw0QkFBNEIsa0JBQWtCLEVBQUUsOEJBQThCLEVBQUUsRUFBRTs7QUFFL29CLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0pBQXFKO0FBQ3JKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBLCtEQUE4RDs7QUFFOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDtBQUNBLElBQUc7O0FBRUg7QUFDQSxFQUFDOztBQUVEOztBQUVBO0FBQ0EscUM7Ozs7OztBQ3hLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRCxvQ0FBbUMsaUNBQWlDLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLHlDQUF5QyxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhLEVBQUUsMkJBQTJCLDBCQUEwQixZQUFZLEVBQUUsMkNBQTJDLDhCQUE4QixFQUFFLE9BQU8sNkVBQTZFLEVBQUUsR0FBRyxFQUFFOztBQUV0cEIsa0NBQWlDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFbGpCLHdDQUF1QyxtQkFBbUIsNEJBQTRCLGlEQUFpRCxnQkFBZ0Isa0RBQWtELDhEQUE4RCwwQkFBMEIsNENBQTRDLHVCQUF1QixrQkFBa0IsRUFBRSxPQUFPLGFBQWEsZ0JBQWdCLGdCQUFnQixlQUFlLDJCQUEyQixvQkFBb0IsRUFBRSxFQUFFLDRCQUE0QixtQkFBbUIsRUFBRSxPQUFPLHVCQUF1Qiw0QkFBNEIsa0JBQWtCLEVBQUUsOEJBQThCLEVBQUUsRUFBRTs7QUFFL29CLHVDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRixrREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBYztBQUNkO0FBQ0EsSUFBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE9BQU87QUFDdEI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBd0I7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0Esd0JBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FB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QUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQU87O0FBRVA7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXFCLDhCQUE4QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBcUIsNEJBQTRCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FB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QTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWdCLE1BQU07QUFDdEI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE1BQU07QUFDdEI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsTUFBTTtBQUN0QjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE9BQU87QUFDdkIsaUJBQWdCLE9BQU87QUFDdkI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWdCLE1BQU07QUFDdEIsaUJBQWdCLFFBQVE7QUFDeEI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBZ0I7QUFDaEI7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWUsTUFBTTtBQUNyQjtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZSxNQUFNO0FBQ3JCO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBLEVBQUM7O0FBRUQ7O0FBRUE7QUFDQSxxQzs7Ozs7O0FDbGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxHOzs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEciLCJmaWxlIjoiaW1nbHlraXQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJjYW52YXNcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wiY2FudmFzXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkltZ2x5S2l0XCJdID0gZmFjdG9yeShyZXF1aXJlKFwiY2FudmFzXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJJbWdseUtpdFwiXSA9IGZhY3Rvcnkocm9vdFtcImNhbnZhc1wiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXykge1xucmV0dXJuIFxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIHdlYnBhY2svdW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvblxuICoqLyIsIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgNjc5NzJjZjE1NzgyYmI4NjNiZWRcbiAqKi8iLCIvKiFcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9saWJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2xpYi9ldmVudC1lbWl0dGVyJyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkV2ZW50RW1pdHRlcik7XG5cbnZhciBfbGliUmVuZGVySW1hZ2UgPSByZXF1aXJlKCcuL2xpYi9yZW5kZXItaW1hZ2UnKTtcblxudmFyIF9saWJSZW5kZXJJbWFnZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJSZW5kZXJJbWFnZSk7XG5cbnZhciBfbGliSW1hZ2VFeHBvcnRlciA9IHJlcXVpcmUoJy4vbGliL2ltYWdlLWV4cG9ydGVyJyk7XG5cbnZhciBfbGliSW1hZ2VFeHBvcnRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJJbWFnZUV4cG9ydGVyKTtcblxudmFyIF9saWJWZXJzaW9uQ2hlY2tlciA9IHJlcXVpcmUoJy4vbGliL3ZlcnNpb24tY2hlY2tlcicpO1xuXG52YXIgX2xpYlZlcnNpb25DaGVja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlZlcnNpb25DaGVja2VyKTtcblxudmFyIF9jb25zdGFudHMgPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfbGliRXhpZiA9IHJlcXVpcmUoJy4vbGliL2V4aWYnKTtcblxudmFyIF9saWJFeGlmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkV4aWYpO1xuXG52YXIgX29wZXJhdGlvbnNSb3RhdGlvbk9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9yb3RhdGlvbi1vcGVyYXRpb24nKTtcblxudmFyIF9vcGVyYXRpb25zUm90YXRpb25PcGVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BlcmF0aW9uc1JvdGF0aW9uT3BlcmF0aW9uKTtcblxudmFyIF9vcGVyYXRpb25zRmxpcE9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9mbGlwLW9wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbnNGbGlwT3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbnNGbGlwT3BlcmF0aW9uKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge0ltYWdlfSBbb3B0aW9ucy5pbWFnZV0gLSBUaGUgc291cmNlIGltYWdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbb3B0aW9ucy5jb250YWluZXJdIC0gU3BlY2lmaWVzIHdoZXJlIHRoZSBVSSBzaG91bGQgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkZWQgdG8uIElmIG5vbmUgaXMgZ2l2ZW4sIHRoZSBVSVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgZGlzYWJsZWQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnVpLmVuYWJsZWQ9dHJ1ZV0gLSBFbmFibGVzIG9yIGRpc2FibGVzIHRoZSBVSVxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZW5kZXJPbldpbmRvd1Jlc2l6ZV0gLSBTcGVjaWZpZXMgd2hldGhlciB0aGUgY2FudmFzXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGQgcmUtcmVuZGVyIGl0c2VsZiB3aGVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgd2luZG93IGlzIGJlaW5nIHJlc2l6ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYXNzZXRzVXJsPSdhc3NldHMnXSAtIFRoZSBiYXNlIHBhdGggZm9yIGFsbCBleHRlcm5hbCBhc3NldHMuXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVuZGVyZXI9J3dlYmdsJ10gLSBUaGUgcmVuZGVyZXIgaWRlbnRpZmllci4gQ2FuIGVpdGhlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlICd3ZWJnbCcgb3IgJ2NhbnZhcycuXG4gKi9cbnZhciBWRVJTSU9OID0gJzIuMC4zLTEzJztcblxudmFyIEltZ2x5S2l0ID0gKGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhJbWdseUtpdCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gSW1nbHlLaXQob3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWdseUtpdCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihJbWdseUtpdC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gYG9wdGlvbnNgIGlzIHJlcXVpcmVkXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBvcHRpb25zIGdpdmVuLicpO1xuICAgIH1cblxuICAgIC8vIFNldCBkZWZhdWx0IG9wdGlvbnNcbiAgICBvcHRpb25zID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgIGFzc2V0c1VybDogJ2Fzc2V0cycsXG4gICAgICBjb250YWluZXI6IG51bGwsXG4gICAgICByZW5kZXJPbldpbmRvd1Jlc2l6ZTogZmFsc2UsXG4gICAgICB2ZXJzaW9uQ2hlY2s6IHRydWVcbiAgICB9KTtcbiAgICBvcHRpb25zLnVpID0gb3B0aW9ucy51aSB8fCB7fTtcbiAgICBvcHRpb25zLnVpID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmRlZmF1bHRzKG9wdGlvbnMudWksIHtcbiAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICB9KTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5pbWFnZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIW9wdGlvbnMudWkuZW5hYmxlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgb3B0aW9ucy5pbWFnZWAgbmVlZHMgdG8gYmUgc2V0IHdoZW4gVUkgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHN0YWNrIG9mIHtAbGluayBPcGVyYXRpb259IGluc3RhbmNlcyB0aGF0IHdpbGwgYmUgdXNlZFxuICAgICAqIHRvIHJlbmRlciB0aGUgZmluYWwgSW1hZ2VcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEltZ2x5S2l0Lk9wZXJhdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5vcGVyYXRpb25zU3RhY2sgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFRoZSByZWdpc3RlcmVkIFVJIHR5cGVzIHRoYXQgY2FuIGJlIHNlbGVjdGVkIHZpYSB0aGUgYHVpYCBvcHRpb25cbiAgICAgKiBAdHlwZSB7T2JqZWN0LjxTdHJpbmcsIFVJPn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRVSXMgPSB7fTtcblxuICAgIC8vIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IFVJc1xuICAgIHRoaXMuX3JlZ2lzdGVyVUlzKCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVnaXN0ZXJlZCBvcGVyYXRpb25zXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLCBJbWdseUtpdC5PcGVyYXRpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRPcGVyYXRpb25zID0ge307XG5cbiAgICAvLyBSZWdpc3RlciB0aGUgZGVmYXVsdCBvcGVyYXRpb25zXG4gICAgdGhpcy5fcmVnaXN0ZXJPcGVyYXRpb25zKCk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fb3B0aW9ucy52ZXJzaW9uQ2hlY2spIHtcbiAgICAgIHRoaXMuX3ZlcnNpb25DaGVja2VyID0gbmV3IF9saWJWZXJzaW9uQ2hlY2tlcjJbJ2RlZmF1bHQnXShWRVJTSU9OKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgdGhpcy5fcGFyc2VFeGlmKHRoaXMuX29wdGlvbnMuaW1hZ2UpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnVpLmVuYWJsZWQpIHtcbiAgICAgIHRoaXMuX2luaXRVSSgpO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVuZGVyT25XaW5kb3dSZXNpemUpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlV2luZG93UmVzaXplKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgdGhlIFNES1xuICAgKiBAbmFtZSBJbWdseUtpdC52ZXJzaW9uXG4gICAqIEBpbnRlcm5hbCBLZWVwIGluIHN5bmMgd2l0aCBwYWNrYWdlLmpzb25cbiAgICovXG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGltYWdlXG4gICAqIEBwYXJhbSAge0ltZ2x5S2l0LlJlbmRlclR5cGV9IFtyZW5kZXJUeXBlPUltZ2x5S2l0LlJlbmRlclR5cGUuREFUQVVSTF0gLSBUaGUgb3V0cHV0IHR5cGVcbiAgICogQHBhcmFtICB7SW1nbHlLaXQuSW1hZ2VGb3JtYXR9IFtpbWFnZUZvcm1hdD1JbWdseUtpdC5JbWFnZUZvcm1hdC5QTkddIC0gVGhlIG91dHB1dCBpbWFnZSBmb3JtYXRcbiAgICogQHBhcmFtICB7c3RyaW5nfSBbZGltZW5zaW9uc10gLSBUaGUgZmluYWwgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2VcbiAgICogQHBhcmFtICB7TnVtYmVyfSBbcXVhbGl0eV0gLSBUaGUgaW1hZ2UgcXVhbGl0eSwgYmV0d2VlbiAwIGFuZCAxXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhJbWdseUtpdCwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyVHlwZSwgaW1hZ2VGb3JtYXQsIGRpbWVuc2lvbnMsIHF1YWxpdHkpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzZXR0aW5ncyA9IF9saWJJbWFnZUV4cG9ydGVyMlsnZGVmYXVsdCddLnZhbGlkYXRlU2V0dGluZ3MocmVuZGVyVHlwZSwgaW1hZ2VGb3JtYXQpO1xuXG4gICAgICByZW5kZXJUeXBlID0gc2V0dGluZ3MucmVuZGVyVHlwZTtcbiAgICAgIGltYWdlRm9ybWF0ID0gc2V0dGluZ3MuaW1hZ2VGb3JtYXQ7XG5cbiAgICAgIC8vIENyZWF0ZSBhIFJlbmRlckltYWdlXG4gICAgICB2YXIgcmVuZGVySW1hZ2UgPSBuZXcgX2xpYlJlbmRlckltYWdlMlsnZGVmYXVsdCddKHRoaXMuX29wdGlvbnMuaW1hZ2UsIHRoaXMub3BlcmF0aW9uc1N0YWNrLCBkaW1lbnNpb25zLCB0aGlzLl9vcHRpb25zLnJlbmRlcmVyKTtcblxuICAgICAgLy8gU2V0IGFsbCBvcGVyYXRpb25zIHRvIGRpcnR5LCBzaW5jZSB3ZSBoYXZlIGFub3RoZXIgd2ViZ2wgcmVuZGVyZXJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcGVyYXRpb25zU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMub3BlcmF0aW9uc1N0YWNrW2ldO1xuICAgICAgICBpZiAoIW9wZXJhdGlvbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIG9wZXJhdGlvbi5kaXJ0eSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYXRlIGltYWdlIHJlbmRlcmluZ1xuICAgICAgcmV0dXJuIHJlbmRlckltYWdlLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FudmFzID0gcmVuZGVySW1hZ2UuZ2V0UmVuZGVyZXIoKS5nZXRDYW52YXMoKTtcbiAgICAgICAgcmV0dXJuIF9saWJJbWFnZUV4cG9ydGVyMlsnZGVmYXVsdCddWydleHBvcnQnXShfdGhpcywgX3RoaXMuX29wdGlvbnMuaW1hZ2UsIGNhbnZhcywgcmVuZGVyVHlwZSwgaW1hZ2VGb3JtYXQsIHF1YWxpdHkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW1hZ2UgYW5kIHBhcnNlcyB0aGUgZXhpZiBkYXRhXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0V4aWZ9IGV4aWYgPSBudWxsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEltYWdlKGltYWdlKSB7XG4gICAgICB2YXIgZXhpZiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIHRoaXMuX29wdGlvbnMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgIGlmICghZXhpZikge1xuICAgICAgICB0aGlzLl9wYXJzZUV4aWYoaW1hZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhpZiA9IGV4aWY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBleGlmIGRhdGEgYW5kIGZpeGVzIHRoZSBvcmllbnRhdGlvbiBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcGFyc2VFeGlmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlRXhpZihpbWFnZSkge1xuICAgICAgaWYgKF9saWJFeGlmMlsnZGVmYXVsdCddLmlzSlBFRyhpbWFnZS5zcmMpKSB7XG4gICAgICAgIHRoaXMuX2V4aWYgPSBudWxsO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuX2V4aWYgPSBfbGliRXhpZjJbJ2RlZmF1bHQnXS5mcm9tQmFzZTY0U3RyaW5nKGltYWdlLnNyYyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIGlmICghdGhpcy5fZXhpZikgcmV0dXJuO1xuXG4gICAgICAgIHZhciBleGlmVGFncyA9IHRoaXMuX2V4aWYuZ2V0VGFncygpO1xuXG4gICAgICAgIGlmIChleGlmVGFncyAmJiBleGlmVGFncy5PcmllbnRhdGlvbikge1xuICAgICAgICAgIGlmIChleGlmVGFncy5PcmllbnRhdGlvbiAhPT0gMSAmJiBleGlmVGFncy5PcmllbnRhdGlvbiAhPT0gMikge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byByb3RhdGVcbiAgICAgICAgICAgIHZhciBkZWdyZWVzID0gMDtcbiAgICAgICAgICAgIHN3aXRjaCAoZXhpZlRhZ3MuT3JpZW50YXRpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgZGVncmVlcyA9IC05MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZGVncmVlcyA9IC0xODA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIGRlZ3JlZXMgPSA5MDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJvdGF0aW9uT3BlcmF0aW9uID0gbmV3IF9vcGVyYXRpb25zUm90YXRpb25PcGVyYXRpb24yWydkZWZhdWx0J10odGhpcywgeyBkZWdyZWVzOiBkZWdyZWVzIH0pO1xuICAgICAgICAgICAgdGhpcy5vcGVyYXRpb25zU3RhY2sucHVzaChyb3RhdGlvbk9wZXJhdGlvbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFsyLCA0LCA1LCA3XS5pbmRleE9mKGV4aWZUYWdzLk9yaWVudGF0aW9uKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBmbGlwT3BlcmF0aW9uID0gbmV3IF9vcGVyYXRpb25zRmxpcE9wZXJhdGlvbjJbJ2RlZmF1bHQnXSh0aGlzLCB7IGhvcml6b250YWw6IHRydWUgfSk7XG4gICAgICAgICAgICB0aGlzLm9wZXJhdGlvbnNTdGFjay5wdXNoKGZsaXBPcGVyYXRpb24pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2V4aWYuc2V0T3JpZW50YXRpb24oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgYWxsIGN1c3RvbSBhbmQgc2VsZWN0ZWQgb3BlcmF0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBhc3NldCBwYXRoIGZvciB0aGUgZ2l2ZW4gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGFzc2V0XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0QXNzZXRQYXRoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXNzZXRQYXRoKGFzc2V0KSB7XG4gICAgICB2YXIgaXNCcm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmFzc2V0c1VybCArICcvJyArIGFzc2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG4gICAgICAgIHJldHVybiBwYXRoLnJlc29sdmUodGhpcy5fb3B0aW9ucy5hc3NldHNVcmwsIGFzc2V0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZiBgb3B0aW9ucy5yZW5kZXJPbldpbmRvd1Jlc2l6ZWAgaXMgc2V0IHRvIHRydWUsIHRoaXMgZnVuY3Rpb25cbiAgICAgKiB3aWxsIHJlLXJlbmRlciB0aGUgY2FudmFzIHdpdGggYSBzbGlnaHQgZGVsYXkgc28gdGhhdCBpdCB3b24ndFxuICAgICAqIGNhdXNlIGxhZ2dpbmcgb2YgdGhlIHJlc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlV2luZG93UmVzaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVdpbmRvd1Jlc2l6ZSgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdGltZXIgPSBudWxsO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICAgIF90aGlzMi51aS5yZW5kZXIoKTtcbiAgICAgICAgfSwgMzAwKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbGwgZGVmYXVsdCBVSXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlZ2lzdGVyVUlzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyVUlzKCkge1xuICAgICAgdGhpcy5yZWdpc3RlclVJKEltZ2x5S2l0Lk5pZ2h0VUkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhbGwgZGVmYXVsdCBvcGVyYXRpb25zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZWdpc3Rlck9wZXJhdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVnaXN0ZXJPcGVyYXRpb25zKCkge1xuICAgICAgZm9yICh2YXIgb3BlcmF0aW9uTmFtZSBpbiBJbWdseUtpdC5PcGVyYXRpb25zKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJPcGVyYXRpb24oSW1nbHlLaXQuT3BlcmF0aW9uc1tvcGVyYXRpb25OYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge0ltZ2x5S2l0Lk9wZXJhdGlvbn0gb3BlcmF0aW9uIC0gVGhlIG9wZXJhdGlvbiBjbGFzc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJPcGVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlck9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRPcGVyYXRpb25zW29wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllcl0gPSBvcGVyYXRpb247XG4gICAgICBpZiAodGhpcy51aSkge1xuICAgICAgICB0aGlzLnVpLmFkZE9wZXJhdGlvbihvcGVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gVUlcbiAgICAgKiBAcGFyYW0ge1VJfSB1aVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJVSScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyVUkodWkpIHtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRVSXNbdWkucHJvdG90eXBlLmlkZW50aWZpZXJdID0gdWk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFVJXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRVSScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0VUkoKSB7XG4gICAgICB2YXIgVUk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnVpLmVuYWJsZWQgPT09IHRydWUpIHtcbiAgICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCBVSSBieSBkZWZhdWx0XG4gICAgICAgIFVJID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLnZhbHVlcyh0aGlzLl9yZWdpc3RlcmVkVUlzKVswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFVSSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0ltZ2x5S2l0LlVJfVxuICAgICAgICovXG4gICAgICB0aGlzLnVpID0gbmV3IFVJKHRoaXMsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgdGhpcy51aS5waXBlRXZlbnRzKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIE9wZXJhdGlvbiBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBpZGVudGlmaWVyLFxuICAgICAqIGlmIGl0IGV4aXN0c1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMge09wZXJhdGlvbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldE9wZXJhdGlvbkZyb21TdGFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wZXJhdGlvbkZyb21TdGFjayhpZGVudGlmaWVyKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5vcGVyYXRpb25zU3RhY2suZmlsdGVyKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbi5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyO1xuICAgICAgfSlbMF07XG4gICAgICByZXR1cm4gb3BlcmF0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIFVJLCBpZiBwcmVzZW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMudWkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudWkucnVuKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzcG9zZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9leGlmLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2V4aWYgPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2V4aWYnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2V4aWY7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJlZE9wZXJhdGlvbnMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRPcGVyYXRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWdseUtpdDtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5JbWdseUtpdC52ZXJzaW9uID0gVkVSU0lPTjtcblxuLy8gRXhwb3NlZCBjbGFzc2VzXG5JbWdseUtpdC5SZW5kZXJJbWFnZSA9IF9saWJSZW5kZXJJbWFnZTJbJ2RlZmF1bHQnXTtcbkltZ2x5S2l0LkNvbG9yID0gcmVxdWlyZSgnLi9saWIvY29sb3InKTtcbkltZ2x5S2l0LkZpbHRlciA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlcicpO1xuSW1nbHlLaXQuT3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL29wZXJhdGlvbicpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucyA9IHt9O1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5GaWx0ZXJzID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMtb3BlcmF0aW9uJyk7XG5JbWdseUtpdC5PcGVyYXRpb25zLkNyb3AgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvY3JvcC1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuUm90YXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvcm90YXRpb24tb3BlcmF0aW9uJyk7XG5JbWdseUtpdC5PcGVyYXRpb25zLlNhdHVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvc2F0dXJhdGlvbi1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuQ29udHJhc3QgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvY29udHJhc3Qtb3BlcmF0aW9uJyk7XG5JbWdseUtpdC5PcGVyYXRpb25zLkJyaWdodG5lc3MgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvYnJpZ2h0bmVzcy1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuRmxpcCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9mbGlwLW9wZXJhdGlvbicpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5UaWx0U2hpZnQgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvdGlsdC1zaGlmdC1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuUmFkaWFsQmx1ciA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9yYWRpYWwtYmx1ci1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuVGV4dCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy90ZXh0LW9wZXJhdGlvbicpO1xuSW1nbHlLaXQuT3BlcmF0aW9ucy5TdGlja2VycyA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9zdGlja2Vycy1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuRnJhbWVzID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZyYW1lcy1vcGVyYXRpb24nKTtcbkltZ2x5S2l0Lk9wZXJhdGlvbnMuQnJ1c2ggPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvYnJ1c2gtb3BlcmF0aW9uJyk7XG5cbkltZ2x5S2l0LkZpbHRlcnMgPSB7fTtcbkltZ2x5S2l0LkZpbHRlcnMuQTE1ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvYTE1LWZpbHRlcicpO1xuSW1nbHlLaXQuRmlsdGVycy5CcmVlemUgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9icmVlemUtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkJXID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnctZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkJXSGFyZCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3aGFyZC1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuQ2Vsc2l1cyA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL2NlbHNpdXMtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkNoZXN0ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2hlc3QtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkZpeGllID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvZml4aWUtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkZvb2QgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9mb29kLWZpbHRlcicpO1xuSW1nbHlLaXQuRmlsdGVycy5GcmlkZ2UgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9mcmlkZ2UtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkZyb250ID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvZnJvbnQtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLkdsYW0gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9nbGFtLWZpbHRlcicpO1xuSW1nbHlLaXQuRmlsdGVycy5Hb2JibGluID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ29iYmxpbi1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuSzEgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9rMS1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuSzIgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9rMi1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuSzYgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9rNi1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuS0R5bmFtaWMgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9rZHluYW1pYy1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuTGVuaW4gPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9sZW5pbi1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuTG9tbyA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL2xvbW8tZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLk1lbGxvdyA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuTW9ybmluZyA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLk9yY2hpZCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL29yY2hpZC1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuUG9sYSA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGEtZmlsdGVyJyk7XG5JbWdseUtpdC5GaWx0ZXJzLlBvbGE2NjkgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9wb2xhNjY5LWZpbHRlcicpO1xuSW1nbHlLaXQuRmlsdGVycy5RdW96aSA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL3F1b3ppLWZpbHRlcicpO1xuSW1nbHlLaXQuRmlsdGVycy5TZW1pcmVkID0gcmVxdWlyZSgnLi9vcGVyYXRpb25zL2ZpbHRlcnMvc2VtaXJlZC1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuU3VubnkgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy9zdW5ueS1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuVGV4YXMgPSByZXF1aXJlKCcuL29wZXJhdGlvbnMvZmlsdGVycy90ZXhhcy1maWx0ZXInKTtcbkltZ2x5S2l0LkZpbHRlcnMuWDQwMCA9IHJlcXVpcmUoJy4vb3BlcmF0aW9ucy9maWx0ZXJzL3g0MDAtZmlsdGVyJyk7XG5cbi8vIEV4cG9zZWQgY29uc3RhbnRzXG5JbWdseUtpdC5SZW5kZXJUeXBlID0gX2NvbnN0YW50cy5SZW5kZXJUeXBlO1xuSW1nbHlLaXQuSW1hZ2VGb3JtYXQgPSBfY29uc3RhbnRzLkltYWdlRm9ybWF0O1xuSW1nbHlLaXQuVmVjdG9yMiA9IHJlcXVpcmUoJy4vbGliL21hdGgvdmVjdG9yMicpO1xuXG4vLyBVSVxuSW1nbHlLaXQuTmlnaHRVSSA9IHJlcXVpcmUoJy4vdWkvbmlnaHQvdWknKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1nbHlLaXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vaW1nbHlraXQuanNcbiAqKiBtb2R1bGUgaWQgPSAwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKipcbiAqIEV2ZW50RW1pdHRlciAoRVM2KSBmcm9tOlxuICogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYmxvb2R5b3dsLzQxYjFkZTMzODhjNjI2Nzk2ZWNhXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBERUZBVUxUX01BWF9MSVNURU5FUlMgPSAxMjtcblxuZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGNvbnNvbGUuZXJyb3IuYXBwbHkoY29uc29sZSwgW21lc3NhZ2VdLmNvbmNhdChhcmdzKSk7XG4gIGNvbnNvbGUudHJhY2UoKTtcbn1cblxudmFyIEV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXZlbnRFbWl0dGVyKTtcblxuICAgIHRoaXMuX21heExpc3RlbmVycyA9IERFRkFVTFRfTUFYX0xJU1RFTkVSUztcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICB0aGlzLl9waXBlRGVzdGluYXRpb25zID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRFbWl0dGVyLCBbe1xuICAgIGtleTogJ3BpcGVFdmVudHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwaXBlRXZlbnRzKGRlc3RpbmF0aW9uKSB7XG4gICAgICB0aGlzLl9waXBlRGVzdGluYXRpb25zLnB1c2goZGVzdGluYXRpb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3VucGlwZUV2ZW50cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucGlwZUV2ZW50cyhkZXN0aW5hdGlvbikge1xuICAgICAgdmFyIGkgPSB0aGlzLl9waXBlRGVzdGluYXRpb25zLmluZGV4T2YoZGVzdGluYXRpb24pO1xuICAgICAgaWYgKGkgPT09IC0xKSByZXR1cm47XG4gICAgICB0aGlzLl9waXBlRGVzdGluYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXSB8fCAodGhpcy5fZXZlbnRzW3R5cGVdID0gW10pO1xuICAgICAgaWYgKGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gdGhpcy5fbWF4TGlzdGVuZXJzKSB7XG4gICAgICAgIGVycm9yKCdwb3NzaWJsZSBtZW1vcnkgbGVhaywgYWRkZWQgJWkgJXMgbGlzdGVuZXJzLFxcbiAgICAgICAgdXNlIEV2ZW50RW1pdHRlciNzZXRNYXhMaXN0ZW5lcnMobnVtYmVyKSBpZiB5b3VcXG4gICAgICAgIHdhbnQgdG8gaW5jcmVhc2UgdGhlIGxpbWl0ICglaSBub3cpJywgbGlzdGVuZXJzLmxlbmd0aCwgdHlwZSwgdGhpcy5fbWF4TGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ29uY2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgZXZlbnRzSW5zdGFuY2UgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gb25jZUNhbGxiYWNrKCkge1xuICAgICAgICBldmVudHNJbnN0YW5jZS5vZmYodHlwZSwgb25jZUNhbGxiYWNrKTtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm9uKHR5cGUsIG9uY2VDYWxsYmFjayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb2ZmJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKHR5cGUpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IG51bGw7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGlzdGVuZXIgPSBhcmdzWzBdO1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgICBpZiAoIWxpc3RlbmVycyB8fCAhbGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4T2ZMaXN0ZW5lciA9IGxpc3RlbmVycy5pbmRleE9mKGxpc3RlbmVyKTtcbiAgICAgIGlmIChpbmRleE9mTGlzdGVuZXIgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4T2ZMaXN0ZW5lciwgMSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICAgIGFyZ3NbX2tleTMgLSAxXSA9IGFyZ3VtZW50c1tfa2V5M107XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BpcGVEZXN0aW5hdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoZGVzdCkge1xuICAgICAgICBkZXN0LmVtaXQuYXBwbHkoZGVzdCwgW3R5cGVdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdGVuZXJzIHx8ICFsaXN0ZW5lcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXRNYXhMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobmV3TWF4TGlzdGVuZXJzKSB7XG4gICAgICBpZiAocGFyc2VJbnQobmV3TWF4TGlzdGVuZXJzLCAxMCkgIT09IG5ld01heExpc3RlbmVycykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21heExpc3RlbmVycyA9IG5ld01heExpc3RlbmVycztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXZlbnRFbWl0dGVyO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9ldmVudC1lbWl0dGVyLmpzXG4gKiogbW9kdWxlIGlkID0gMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9ldmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL2V2ZW50LWVtaXR0ZXInKTtcblxudmFyIF9ldmVudEVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZXZlbnRFbWl0dGVyKTtcblxudmFyIF9pbWFnZURpbWVuc2lvbnMgPSByZXF1aXJlKCcuL2ltYWdlLWRpbWVuc2lvbnMnKTtcblxudmFyIF9pbWFnZURpbWVuc2lvbnMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW1hZ2VEaW1lbnNpb25zKTtcblxudmFyIF9tYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4vbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0aFZlY3RvcjIpO1xuXG52YXIgX3JlbmRlcmVyc0NhbnZhc1JlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL2NhbnZhcy1yZW5kZXJlcicpO1xuXG52YXIgX3JlbmRlcmVyc0NhbnZhc1JlbmRlcmVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcmVyc0NhbnZhc1JlbmRlcmVyKTtcblxudmFyIF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL3dlYmdsLXJlbmRlcmVyJyk7XG5cbnZhciBfcmVuZGVyZXJzV2ViZ2xSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyKTtcblxudmFyIF91dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxudmFyIF91dGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91dGlscyk7XG5cbi8qKlxuICogSGFuZGxlcyB0aGUgaW1hZ2UgcmVuZGVyaW5nIHByb2Nlc3NcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LlJlbmRlckltYWdlXG4gKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICogQHBhcmFtIHtBcnJheS48SW1nbHlLaXQuT3BlcmF0aW9uPn0gb3BlcmF0aW9uc1N0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uc1xuICogQHBhcmFtIHtzdHJpbmd9IHByZWZlcnJlZFJlbmRlcmVyXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBSZW5kZXJJbWFnZSA9IChmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoUmVuZGVySW1hZ2UsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIFJlbmRlckltYWdlKGltYWdlLCBvcGVyYXRpb25zU3RhY2ssIGRpbWVuc2lvbnMsIHByZWZlcnJlZFJlbmRlcmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlckltYWdlKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJlbmRlckltYWdlLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fb3B0aW9ucyA9IHtcbiAgICAgIHByZWZlcnJlZFJlbmRlcmVyOiBwcmVmZXJyZWRSZW5kZXJlclxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgdGhpcy5fd2ViZ2xFbmFibGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UmVuZGVyZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9yZW5kZXJlciA9IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SW1hZ2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pbWFnZSA9IGltYWdlO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5LjxJbWdseUtpdC5PcGVyYXRpb24+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhY2sgPSBvcGVyYXRpb25zU3RhY2s7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SW1nbHlLaXQuSW1hZ2VEaW1lbnNpb25zfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGltZW5zaW9ucyA9IG5ldyBfaW1hZ2VEaW1lbnNpb25zMlsnZGVmYXVsdCddKGRpbWVuc2lvbnMpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9pbml0aWFsRGltZW5zaW9ucyA9IG5ldyBfbWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5faW1hZ2Uud2lkdGgsIHRoaXMuX2ltYWdlLmhlaWdodCk7XG5cbiAgICB0aGlzLl9pbml0UmVuZGVyZXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcmVuZGVyZXIgKGNhbnZhcyBvciB3ZWJnbCwgZGVwZW5kaW5nIG9uIHN1cHBvcnQpXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJJbWFnZSwgW3tcbiAgICBrZXk6ICdfaW5pdFJlbmRlcmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRSZW5kZXJlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyMlsnZGVmYXVsdCddLmlzU3VwcG9ydGVkKCkgJiYgdGhpcy5fb3B0aW9ucy5wcmVmZXJyZWRSZW5kZXJlciAhPT0gJ2NhbnZhcycpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgX3JlbmRlcmVyc1dlYmdsUmVuZGVyZXIyWydkZWZhdWx0J10odGhpcy5faW5pdGlhbERpbWVuc2lvbnMsIG51bGwsIHRoaXMuX2ltYWdlKTtcbiAgICAgICAgdGhpcy5fd2ViZ2xFbmFibGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoX3JlbmRlcmVyc0NhbnZhc1JlbmRlcmVyMlsnZGVmYXVsdCddLmlzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyZXIgPSBuZXcgX3JlbmRlcmVyc0NhbnZhc1JlbmRlcmVyMlsnZGVmYXVsdCddKHRoaXMuX2luaXRpYWxEaW1lbnNpb25zLCBudWxsLCB0aGlzLl9pbWFnZSk7XG4gICAgICAgIHRoaXMuX3dlYmdsRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICh0aGlzLl9yZW5kZXJlciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05laXRoZXIgQ2FudmFzIG5vciBXZWJHTCByZW5kZXJlciBhcmUgc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJlci5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBfdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBpbWFnZVxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHN0YWNrID0gdGhpcy5zYW5pdGl6ZWRTdGFjaztcbiAgICAgIHZhciBpbml0aWFsRGltZW5zaW9ucyA9IHRoaXMuX3JlbmRlcmVyLmdldEluaXRpYWxEaW1lbnNpb25zRm9yU3RhY2soc3RhY2ssIHRoaXMuX2RpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIucmVzaXplVG8oaW5pdGlhbERpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5fcmVuZGVyZXIuZHJhd0ltYWdlKHRoaXMuX2ltYWdlKTtcblxuICAgICAgdmFyIHZhbGlkYXRpb25Qcm9taXNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3BlcmF0aW9uID0gc3RhY2tbaV07XG4gICAgICAgIHZhbGlkYXRpb25Qcm9taXNlcy5wdXNoKG9wZXJhdGlvbi52YWxpZGF0ZVNldHRpbmdzKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodmFsaWRhdGlvblByb21pc2VzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgIHZhciBvcGVyYXRpb24gPSBzdGFja1tpXTtcbiAgICAgICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIF91dGlsczJbJ2RlZmF1bHQnXS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbi5yZW5kZXIoX3RoaXMyLl9yZW5kZXJlcik7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBfbG9vcChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9yZW5kZXJlci5yZW5kZXJGaW5hbCgpO1xuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuX3JlbmRlcmVyLnBvc3RSZW5kZXIoX3RoaXMyLl9kaW1lbnNpb25zKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UmVuZGVyZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRSZW5kZXJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlcmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlbmRlcmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9wZXJhdGlvbnMgc3RhY2sgd2l0aG91dCBmYWxzeSB2YWx1ZXNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPE9wZXJhdGlvbj59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZWRTdGFjaycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2FuaXRpemVkU3RhY2sgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHRoaXMuX3N0YWNrW2ldO1xuICAgICAgICBpZiAoIW9wZXJhdGlvbikgY29udGludWU7XG4gICAgICAgIHNhbml0aXplZFN0YWNrLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzYW5pdGl6ZWRTdGFjaztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVuZGVySW1hZ2U7XG59KShfZXZlbnRFbWl0dGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUmVuZGVySW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL3JlbmRlci1pbWFnZS5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgZGltZW5zaW9ucyBzdHJpbmcgYW5kIHByb3ZpZGVzIGNhbGN1bGF0aW9uIGZ1bmN0aW9uc1xuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuSW1hZ2VEaW1lbnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZGltZW5zaW9uc1xuICogQHByaXZhdGVcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBJbWFnZURpbWVuc2lvbnMgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbWFnZURpbWVuc2lvbnMoZGltZW5zaW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZURpbWVuc2lvbnMpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF2YWlsYWJsZSBkaW1lbnNpb24gbW9kaWZpZXJzXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX21vZGlmaWVycyA9IHtcbiAgICAgIEZJWEVEOiAnISdcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2RpbWVuc2lvbnNTdHJpbmcgPSBkaW1lbnNpb25zO1xuXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgcGFyc2VkIGRpbWVuc2lvbnMgc3RyaW5nXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLl9ydWxlcyA9IHRoaXMuX3BhcnNlKCk7XG5cbiAgICB0aGlzLl92YWxpZGF0ZVJ1bGVzKCk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2VzIHRoZSBkaW1lbnNpb25zIHN0cmluZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoSW1hZ2VEaW1lbnNpb25zLCBbe1xuICAgIGtleTogJ19wYXJzZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZSgpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fZGltZW5zaW9uc1N0cmluZyA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5fZGltZW5zaW9uc1N0cmluZyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hdGNoID0gdGhpcy5fZGltZW5zaW9uc1N0cmluZy5tYXRjaCgvXihbMC05XSspP3goWzAtOV0rKT8oW1xcIV0pPyQvaSk7XG4gICAgICBpZiAoIW1hdGNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaXplIG9wdGlvbjogJyArIHRoaXMuX2RpbWVuc2lvbnNTdHJpbmcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBpc05hTihtYXRjaFsxXSkgPyBudWxsIDogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSxcbiAgICAgICAgeTogaXNOYU4obWF0Y2hbMl0pID8gbnVsbCA6IHBhcnNlSW50KG1hdGNoWzJdLCAxMCksXG4gICAgICAgIG1vZGlmaWVyOiBtYXRjaFszXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhlIHJ1bGVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ192YWxpZGF0ZVJ1bGVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3ZhbGlkYXRlUnVsZXMoKSB7XG4gICAgICBpZiAodGhpcy5fcnVsZXMgPT09IG51bGwpIHJldHVybjtcblxuICAgICAgdmFyIHhBdmFpbGFibGUgPSB0aGlzLl9ydWxlcy54ICE9PSBudWxsO1xuICAgICAgdmFyIHlBdmFpbGFibGUgPSB0aGlzLl9ydWxlcy55ICE9PSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fcnVsZXMubW9kaWZpZXIgPT09IHRoaXMuX21vZGlmaWVycy5GSVhFRCAmJiAhKHhBdmFpbGFibGUgJiYgeUF2YWlsYWJsZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb3RoIGB4YCBhbmQgYHlgIGhhdmUgdG8gYmUgc2V0IHdoZW4gdXNpbmcgdGhlIGZpeGVkICghKSBtb2RpZmllci4nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF4QXZhaWxhYmxlICYmICF5QXZhaWxhYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTmVpdGhlciBgeGAgbm9yIGB5YCBhcmUgZ2l2ZW4uJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgZmluYWwgZGltZW5zaW9ucyB1c2luZyB0aGUgZGltZW5zaW9ucyBzdHJpbmcgYW5kIHRoZVxuICAgICAqIGdpdmVuIGluaXRpYWwgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGluaXRpYWxEaW1lbnNpb25zXG4gICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NhbGN1bGF0ZUZpbmFsRGltZW5zaW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUZpbmFsRGltZW5zaW9ucyhpbml0aWFsRGltZW5zaW9ucykge1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBpbml0aWFsRGltZW5zaW9ucy5jbG9uZSgpLFxuICAgICAgICAgIHJhdGlvO1xuXG4gICAgICBpZiAodGhpcy5fcnVsZXMgPT09IG51bGwpIHJldHVybiBkaW1lbnNpb25zO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgaWYgKHRoaXMuX3J1bGVzLm1vZGlmaWVyID09PSB0aGlzLl9tb2RpZmllcnMuRklYRUQpIHtcbiAgICAgICAgLy8gRml4ZWQgZGltZW5zaW9uc1xuICAgICAgICBkaW1lbnNpb25zLnNldCh0aGlzLl9ydWxlcy54LCB0aGlzLl9ydWxlcy55KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcnVsZXMueCAhPT0gbnVsbCAmJiB0aGlzLl9ydWxlcy55ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEJvdGggeCBhbmQgeSBnaXZlbiwgcmVzaXplIHRvIGZpdFxuICAgICAgICByYXRpbyA9IE1hdGgubWluKHRoaXMuX3J1bGVzLnggLyBkaW1lbnNpb25zLngsIHRoaXMuX3J1bGVzLnkgLyBkaW1lbnNpb25zLnkpO1xuICAgICAgICBkaW1lbnNpb25zLm11bHRpcGx5KHJhdGlvKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fcnVsZXMueCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBGaXhlZCB4LCB5IGJ5IHJhdGlvXG4gICAgICAgIHJhdGlvID0gaW5pdGlhbERpbWVuc2lvbnMueSAvIGluaXRpYWxEaW1lbnNpb25zLng7XG4gICAgICAgIGRpbWVuc2lvbnMueCA9IHRoaXMuX3J1bGVzLng7XG4gICAgICAgIGRpbWVuc2lvbnMueSA9IGRpbWVuc2lvbnMueCAqIHJhdGlvO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ydWxlcy55ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEZpeGVkIHksIHggYnkgcmF0aW9cbiAgICAgICAgcmF0aW8gPSBpbml0aWFsRGltZW5zaW9ucy54IC8gaW5pdGlhbERpbWVuc2lvbnMueTtcbiAgICAgICAgZGltZW5zaW9ucy55ID0gdGhpcy5fcnVsZXMueTtcbiAgICAgICAgZGltZW5zaW9ucy54ID0gZGltZW5zaW9ucy55ICogcmF0aW87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkaW1lbnNpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZURpbWVuc2lvbnM7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBJbWFnZURpbWVuc2lvbnM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2ltYWdlLWRpbWVuc2lvbnMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgMi1kaW1lbnNpb25hbCB2ZWN0b3Igd2hpbGUgcHJvdmlkaW5nIG1hdGggZnVuY3Rpb25zIHRvXG4gKiBtb2RpZnkgLyBjbG9uZSB0aGUgdmVjdG9yLiBGdWxseSBjaGFpbmFibGUuXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5WZWN0b3IyXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwcml2YXRlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgVmVjdG9yMiA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlY3RvcjIoeCwgeSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWZWN0b3IyKTtcblxuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgICBpZiAodHlwZW9mIHRoaXMueCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGhpcy55ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy55ID0gMDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gdmFsdWVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhWZWN0b3IyLCBbe1xuICAgIGtleTogJ3NldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldCh4LCB5KSB7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGlzIHZlY3RvclxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjbG9uZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZWN0b3IyKHRoaXMueCwgdGhpcy55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiB0aGUgZ2l2ZW4gdmVjdG9yXG4gICAgICogQHBhcmFtICB7VmVjdG9yMn0gb3RoZXJcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29weScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkob3RoZXIpIHtcbiAgICAgIHRoaXMueCA9IG90aGVyLng7XG4gICAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xhbXBzIHRoaXMgdmVjdG9yIHdpdGggdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXJcbiAgICAgKiBAcGFyYW0gIHsobnVtYmVyfFZlY3RvcjIpfSBtaW5pbXVtXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gbWF4aW11bVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjbGFtcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYW1wKG1pbmltdW0sIG1heGltdW0pIHtcbiAgICAgIHZhciBtaW5pbXVtU2V0ID0gbWluaW11bSAhPT0gbnVsbCAmJiB0eXBlb2YgbWluaW11bSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICB2YXIgbWF4aW11bVNldCA9IG1heGltdW0gIT09IG51bGwgJiYgdHlwZW9mIG1heGltdW0gIT09ICd1bmRlZmluZWQnO1xuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbiAgICAgIGlmICghKG1pbmltdW0gaW5zdGFuY2VvZiBWZWN0b3IyKSAmJiBtaW5pbXVtU2V0KSB7XG4gICAgICAgIG1pbmltdW0gPSBuZXcgVmVjdG9yMihtaW5pbXVtLCBtaW5pbXVtKTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgaWYgKCEobWF4aW11bSBpbnN0YW5jZW9mIFZlY3RvcjIpICYmIG1heGltdW1TZXQpIHtcbiAgICAgICAgbWF4aW11bSA9IG5ldyBWZWN0b3IyKG1heGltdW0sIG1heGltdW0pO1xuICAgICAgfVxuXG4gICAgICBpZiAobWluaW11bVNldCkge1xuICAgICAgICB0aGlzLnggPSBNYXRoLm1heChtaW5pbXVtLngsIHRoaXMueCk7XG4gICAgICAgIHRoaXMueSA9IE1hdGgubWF4KG1pbmltdW0ueSwgdGhpcy55KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heGltdW1TZXQpIHtcbiAgICAgICAgdGhpcy54ID0gTWF0aC5taW4obWF4aW11bS54LCB0aGlzLngpO1xuICAgICAgICB0aGlzLnkgPSBNYXRoLm1pbihtYXhpbXVtLnksIHRoaXMueSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXZpZGVzIHRoaXMgdmVjdG9yIGJ5IHRoZSBnaXZlbiBWZWN0b3IyIC8gbnVtYmVyXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gZGl2aXNvclxuICAgICAqIEBwYXJhbSAge251bWJlcn0gW3ldXG4gICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RpdmlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpdmlkZShkaXZpc29yLCB5KSB7XG4gICAgICBpZiAoZGl2aXNvciBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgICAgdGhpcy54IC89IGRpdmlzb3IueDtcbiAgICAgICAgdGhpcy55IC89IGRpdmlzb3IueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueCAvPSBkaXZpc29yO1xuICAgICAgICB0aGlzLnkgLz0gdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnID8gZGl2aXNvciA6IHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdHMgdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXIgZnJvbSB0aGlzIHZlY3RvclxuICAgICAqIEBwYXJhbSAgeyhudW1iZXJ8VmVjdG9yMil9IHN1YnRyYWhlbmRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5XVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzdWJ0cmFjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN1YnRyYWN0KHN1YnRyYWhlbmQsIHkpIHtcbiAgICAgIGlmIChzdWJ0cmFoZW5kIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgICB0aGlzLnggLT0gc3VidHJhaGVuZC54O1xuICAgICAgICB0aGlzLnkgLT0gc3VidHJhaGVuZC55O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54IC09IHN1YnRyYWhlbmQ7XG4gICAgICAgIHRoaXMueSAtPSB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBzdWJ0cmFoZW5kIDogeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE11bHRpcGxpZXMgdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXIgd2l0aCB0aGlzIHZlY3RvclxuICAgICAqIEBwYXJhbSAgeyhudW1iZXJ8VmVjdG9yMil9IHN1YnRyYWhlbmRcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IFt5XVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdtdWx0aXBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG11bHRpcGx5KGZhY3RvciwgeSkge1xuICAgICAgaWYgKGZhY3RvciBpbnN0YW5jZW9mIFZlY3RvcjIpIHtcbiAgICAgICAgdGhpcy54ICo9IGZhY3Rvci54O1xuICAgICAgICB0aGlzLnkgKj0gZmFjdG9yLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggKj0gZmFjdG9yO1xuICAgICAgICB0aGlzLnkgKj0gdHlwZW9mIHkgPT09ICd1bmRlZmluZWQnID8gZmFjdG9yIDogeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIFZlY3RvcjIgLyBudW1iZXJzIHRvIHRoaXMgdmVjdG9yXG4gICAgICogQHBhcmFtIHsobnVtYmVyfFZlY3RvcjIpfSBhZGRlbmRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ldXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoYWRkZW5kLCB5KSB7XG4gICAgICBpZiAoYWRkZW5kIGluc3RhbmNlb2YgVmVjdG9yMikge1xuICAgICAgICB0aGlzLnggKz0gYWRkZW5kLng7XG4gICAgICAgIHRoaXMueSArPSBhZGRlbmQueTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueCArPSBhZGRlbmQ7XG4gICAgICAgIHRoaXMueSArPSB0eXBlb2YgeSA9PT0gJ3VuZGVmaW5lZCcgPyBhZGRlbmQgOiB5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIHggYW5kIHkgdmFsdWUgYXJlIHRoZSBzYW1lIGFzIHRoZSBnaXZlbiBvbmVzXG4gICAgICogQHBhcmFtICB7KG51bWJlcnxWZWN0b3IyKX0gdmVjXG4gICAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2VxdWFscycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFscyh2ZWMsIHkpIHtcbiAgICAgIGlmICh2ZWMgaW5zdGFuY2VvZiBWZWN0b3IyKSB7XG4gICAgICAgIHJldHVybiB2ZWMueCA9PT0gdGhpcy54ICYmIHZlYy55ID09PSB0aGlzLnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmVjID09PSB0aGlzLnggJiYgeSA9PT0gdGhpcy55O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIHRoZSB4IGFuZCB5IHZhbHVlcyBvZiB0aGlzIHZlY3RvclxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdmbGlwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmxpcCgpIHtcbiAgICAgIHZhciB0ZW1wWCA9IHRoaXMueDtcbiAgICAgIHRoaXMueCA9IHRoaXMueTtcbiAgICAgIHRoaXMueSA9IHRlbXBYO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIHRoZSB2YWx1ZXMgb2YgdGhpcyB2ZWN0b3JcbiAgICAgKiBAcmV0dXJucyB7VmVjdG9yMn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JvdW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLnJvdW5kKHRoaXMueCk7XG4gICAgICB0aGlzLnkgPSBNYXRoLnJvdW5kKHRoaXMueSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSb3VuZHMgdXAgdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY2VpbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgICB0aGlzLnggPSBNYXRoLmNlaWwodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguY2VpbCh0aGlzLnkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm91bmRzIGRvd24gdGhlIHZhbHVlcyBvZiB0aGlzIHZlY3RvclxuICAgICAqIEByZXR1cm5zIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZmxvb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICAgIHRoaXMueCA9IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGJvdGggbnVtYmVycyBvZiB0aGlzIHZlY3RvciBwb3NpdGl2ZVxuICAgICAqIEByZXR1cm5zIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJzKCkge1xuICAgICAgdGhpcy54ID0gTWF0aC5hYnModGhpcy54KTtcbiAgICAgIHRoaXMueSA9IE1hdGguYWJzKHRoaXMueSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdmVjdG9yXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndG9TdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAnVmVjdG9yMih7IHg6ICcgKyB0aGlzLnggKyAnLCB5OiAnICsgdGhpcy55ICsgJyB9KSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFZlY3RvcjI7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWZWN0b3IyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9tYXRoL3ZlY3RvcjIuanNcbiAqKiBtb2R1bGUgaWQgPSA0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcblxudmFyIF9yZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX3ZlbmRvclByb21pc2UgPSByZXF1aXJlKCcuLi92ZW5kb3IvcHJvbWlzZScpO1xuXG52YXIgX3ZlbmRvclByb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVuZG9yUHJvbWlzZSk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuQ2FudmFzUmVuZGVyZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5SZW5kZXJlcn1cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIENhbnZhc1JlbmRlcmVyID0gKGZ1bmN0aW9uIChfUmVuZGVyZXIpIHtcbiAgX2luaGVyaXRzKENhbnZhc1JlbmRlcmVyLCBfUmVuZGVyZXIpO1xuXG4gIGZ1bmN0aW9uIENhbnZhc1JlbmRlcmVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXNSZW5kZXJlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDYW52YXNSZW5kZXJlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhc1JlbmRlcmVyLCBbe1xuICAgIGtleTogJ2NhY2hlJyxcblxuICAgIC8qKlxuICAgICAqIENhY2hlcyB0aGUgY3VycmVudCBjYW52YXMgY29udGVudCBmb3IgdGhlIGdpdmVuIGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZShpZGVudGlmaWVyKSB7XG4gICAgICB0aGlzLl9jYWNoZVtpZGVudGlmaWVyXSA9IHtcbiAgICAgICAgZGF0YTogdGhpcy5fY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KSxcbiAgICAgICAgc2l6ZTogbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBzdG9yZWQgdGV4dHVyZSAvIGltYWdlIGRhdGEgZm9yIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RyYXdDYWNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2FjaGVkKGlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBfY2FjaGUkaWRlbnRpZmllciA9IHRoaXMuX2NhY2hlW2lkZW50aWZpZXJdO1xuICAgICAgdmFyIGRhdGEgPSBfY2FjaGUkaWRlbnRpZmllci5kYXRhO1xuICAgICAgdmFyIHNpemUgPSBfY2FjaGUkaWRlbnRpZmllci5zaXplO1xuXG4gICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gc2l6ZS55O1xuICAgICAgdGhpcy5fY29udGV4dC5wdXRJbWFnZURhdGEoZGF0YSwgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyB0eXBlIG9mIHJlbmRlcmVyIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2dldENvbnRleHQnLFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZnJvbSB0aGUgQ2FudmFcbiAgICAgKiBAcmV0dXJuIHtSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGV4dCgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIGltYWdlIG9uIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZHJhd0ltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ltYWdlKGltYWdlKSB7XG4gICAgICB0aGlzLl9jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHJldHVybiBfdmVuZG9yUHJvbWlzZTJbJ2RlZmF1bHQnXS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY3VycmVudCBjYW52YXMgcGljdHVyZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzaXplVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVUbyhkaW1lbnNpb25zKSB7XG4gICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucy5jbG9uZSgpLmZsb29yKCk7XG4gICAgICBpZiAodGhpcy5fY2FudmFzLndpZHRoID09PSBkaW1lbnNpb25zLnggJiYgdGhpcy5fY2FudmFzLmhlaWdodCA9PT0gZGltZW5zaW9ucy55KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyB0byBkcmF3IHRvXG4gICAgICB2YXIgbmV3Q2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgIG5ld0NhbnZhcy53aWR0aCA9IGRpbWVuc2lvbnMueDtcbiAgICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLnk7XG4gICAgICB2YXIgbmV3Q29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAvLyBEcmF3IHRoZSBzb3VyY2UgY2FudmFzIG9udG8gdGhlIG5ldyBvbmVcbiAgICAgIG5ld0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuX2NhbnZhcywgMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0LCAwLCAwLCBuZXdDYW52YXMud2lkdGgsIG5ld0NhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBTZXQgdGhlIG5ldyBjYW52YXMgYW5kIGNvbnRleHRcbiAgICAgIHRoaXMuc2V0Q2FudmFzKG5ld0NhbnZhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBjdXJyZW50IGNhbnZhc1xuICAgICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Nsb25lQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmVDYW52YXMoKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMoKTtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIC8vIFJlc2l6ZSB0aGUgY2FudmFzXG4gICAgICBjYW52YXMud2lkdGggPSB0aGlzLl9jYW52YXMud2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5fY2FudmFzLmhlaWdodDtcblxuICAgICAgLy8gRHJhdyB0aGUgY3VycmVudCBjYW52YXMgb24gdGhlIG5ldyBvbmVcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKHRoaXMuX2NhbnZhcywgMCwgMCk7XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzZXRDYWNoZSA9IGZhbHNlXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdmFyIHJlc2V0Q2FjaGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgaWYgKHJlc2V0Q2FjaGUpIHtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbml0aWFsIGRpbWVuc2lvbnMgYmVmb3JlIGFueSBvcGVyYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlcmF0aW9uPn0gc3RhY2tcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGltZW5zaW9uc30gZGltZW5zaW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0SW5pdGlhbERpbWVuc2lvbnNGb3JTdGFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluaXRpYWxEaW1lbnNpb25zRm9yU3RhY2soc3RhY2ssIGRpbWVuc2lvbnMpIHtcbiAgICAgIC8vIFNpbmNlIGNhbnZhcyBvcGVyYXRpb25zIHJlc2l6ZSB0aGUgY2FudmFzLCB0aGUgaW5pdGlhbFxuICAgICAgLy8gZGltZW5zaW9ucyBpcyB0aGUgc2FtZSBhcyB0aGUgaW1hZ2UgZGltZW5zaW9uc1xuICAgICAgcmV0dXJuIG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5faW1hZ2Uud2lkdGgsIHRoaXMuX2ltYWdlLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2FudmFzIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaXplKGRpbWVuc2lvbnMpIHtcbiAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zLmNsb25lKCkuZmxvb3IoKTtcbiAgICAgIGlmICh0aGlzLl9jYW52YXMud2lkdGggPT09IGRpbWVuc2lvbnMueCAmJiB0aGlzLl9jYW52YXMuaGVpZ2h0ID09PSBkaW1lbnNpb25zLnkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBkaW1lbnNpb25zLng7XG4gICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZGltZW5zaW9ucy55O1xuICAgICAgdGhpcy5fc2l6ZS5jb3B5KGRpbWVuc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGFmdGVyIHRoZSByZW5kZXJpbmcgaGFzIGJlZW4gZG9uZS4gUmVzaXplcyB0aGUgY2FudmFzXG4gICAgICogdG8gaXRzIGZpbmFsIHNpemVcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGltZW5zaW9uc30gZGltZW5zaW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncG9zdFJlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RSZW5kZXIoZGltZW5zaW9ucykge1xuICAgICAgdmFyIGNhbnZhc0RpbWVuc2lvbnMgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgbmV3RGltZW5zaW9ucyA9IGRpbWVuc2lvbnMuY2FsY3VsYXRlRmluYWxEaW1lbnNpb25zKGNhbnZhc0RpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5yZXNpemVUbyhuZXdEaW1lbnNpb25zKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lzU3VwcG9ydGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNTdXBwb3J0ZWQoKSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucHJvdG90eXBlLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIHJlbmRlcmVyXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnY2FudmFzJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FudmFzUmVuZGVyZXI7XG59KShfcmVuZGVyZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDYW52YXNSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9yZW5kZXJlcnMvY2FudmFzLXJlbmRlcmVyLmpzXG4gKiogbW9kdWxlIGlkID0gNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypqc2hpbnQgdW51c2VkOmZhbHNlICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gyLCBfeDMsIF94NCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDIsIHByb3BlcnR5ID0gX3gzLCByZWNlaXZlciA9IF94NDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDIgPSBwYXJlbnQ7IF94MyA9IHByb3BlcnR5OyBfeDQgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9saWIvZXZlbnQtZW1pdHRlcicpO1xuXG52YXIgX2xpYkV2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LlJlbmRlcmVyXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIFJlbmRlcmVyID0gKGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhSZW5kZXJlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gUmVuZGVyZXIoZGltZW5zaW9ucywgY2FudmFzLCBpbWFnZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZW5kZXJlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihSZW5kZXJlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Q2FudmFzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY2FudmFzID0gY2FudmFzIHx8IHRoaXMuY3JlYXRlQ2FudmFzKCk7XG5cbiAgICBpZiAoIWNhbnZhcykge1xuICAgICAgdGhpcy5zZXRTaXplKGRpbWVuc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY29udGV4dCA9IHRoaXMuX2dldENvbnRleHQoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIC8gaW1hZ2UgZGF0YSBjYWNoZVxuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZywgKj59XG4gICAgICovXG4gICAgdGhpcy5fY2FjaGUgPSB7fTtcblxuICAgIHRoaXMuX2ltYWdlID0gaW1hZ2U7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIHJlbmRlcmVyXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhSZW5kZXJlciwgW3tcbiAgICBrZXk6ICdjYWNoZScsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoaWRlbnRpZmllcikge31cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBzdG9yZWQgdGV4dHVyZSAvIGltYWdlIGRhdGEgZm9yIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RyYXdDYWNoZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3Q2FjaGVkKGlkZW50aWZpZXIpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNhbnZhc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbd2lkdGhdXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtoZWlnaHRdXG4gICAgICogQHJldHVybiB7Q2FudmFzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjcmVhdGVDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgdmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuICAgICAgdmFyIGNhbnZhcztcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgICAgIGNhbnZhcyA9IG5ldyBDYW52YXMoKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgd2lkdGhcbiAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBBcHBseSBoZWlnaHRcbiAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2l6ZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHJldHVybiB7VmVjdG9yMn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaXplKCkge1xuICAgICAgcmV0dXJuIG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmcm9tIHRoZSBDYW52YVxuICAgICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q29udGV4dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDb250ZXh0KCkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZXIjX2dldENvbnRleHQgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgY3VycmVudCBjYW52YXMgcGljdHVyZSB0byB0aGUgZ2l2ZW4gZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSAge1ZlY3RvcjJ9IGRpbWVuc2lvbnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzaXplVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVUbyhkaW1lbnNpb25zKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlciNyZXNpemVUbyBpcyBhYnN0cmFjdCBhbmQgbm90IGltcGxlbWVudGVkIGluIGluaGVyaXRlZCBjbGFzcy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgZ2l2ZW4gaW1hZ2Ugb24gdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge0ltYWdlfSBpbWFnZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZHJhd0ltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ltYWdlKGltYWdlKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlciNkcmF3SW1hZ2UgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIHN0YWNrIGhhcyBiZWVuIHJlbmRlcmVkXG4gICAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJGaW5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckZpbmFsKCkge31cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldENhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbnZhcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGV4dFxuICAgICAqIEByZXR1cm4ge1JlbmRlcmluZ0NvbnRleHR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDb250ZXh0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGV4dCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgY2FudmFzIHRvIHRoZSBnaXZlbiBvbmVcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYW52YXMoY2FudmFzKSB7XG4gICAgICB0aGlzLl9jYW52YXMgPSBjYW52YXM7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuXG4gICAgICB0aGlzLmVtaXQoJ25ldy1jYW52YXMnLCB0aGlzLl9jYW52YXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhbnZhcyBzaXplIGFmdGVyIGFsbCBvcGVyYXRpb25zIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlcmF0aW9uPn0gc3RhY2tcbiAgICAgKiBAcGFyYW0ge0ltYWdlRGltZW5zaW9uc30gZGltZW5zaW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0T3V0cHV0RGltZW5zaW9uc0ZvclN0YWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3V0cHV0RGltZW5zaW9uc0ZvclN0YWNrKHN0YWNrLCBkaW1lbnNpb25zKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5faW1hZ2Uud2lkdGgsIHRoaXMuX2ltYWdlLmhlaWdodCk7XG4gICAgICBzdGFjay5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IG9wZXJhdGlvbi5nZXROZXdEaW1lbnNpb25zKF90aGlzLCBzaXplKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGRpbWVuc2lvbnMpIHtcbiAgICAgICAgc2l6ZSA9IGRpbWVuc2lvbnMuY2FsY3VsYXRlRmluYWxEaW1lbnNpb25zKHNpemUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgaW5pdGlhbCBkaW1lbnNpb25zIGJlZm9yZSBhbnkgb3BlcmF0aW9ucyBoYXZlIGJlZW4gYXBwbGllZFxuICAgICAqIEBwYXJhbSB7QXJyYXkuPE9wZXJhdGlvbj59IHN0YWNrXG4gICAgICogQHBhcmFtIHtJbWFnZURpbWVuc2lvbnN9IGRpbWVuc2lvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldEluaXRpYWxEaW1lbnNpb25zRm9yU3RhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbml0aWFsRGltZW5zaW9uc0ZvclN0YWNrKHN0YWNrLCBkaW1lbnNpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRPdXRwdXREaW1lbnNpb25zRm9yU3RhY2soc3RhY2ssIGRpbWVuc2lvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgY29udGV4dCB0byB0aGUgZ2l2ZW4gb25lXG4gICAgICogQHBhcmFtIHtSZW5kZXJpbmdDb250ZXh0MkR9IGNvbnRleHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldENvbnRleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyB0aGUgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlc2V0Q2FjaGUgPSBmYWxzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHZhciByZXNldENhY2hlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgYWZ0ZXIgdGhlIHJlbmRlcmluZyBoYXMgYmVlbiBkb25lLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncG9zdFJlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvc3RSZW5kZXIoZGltZW5zaW9ucykge31cbiAgfSwge1xuICAgIGtleTogJ3NldFNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTaXplKHNpemUpIHtcbiAgICAgIHRoaXMuX3NpemUuY29weShzaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgdHlwZSBvZiByZW5kZXJlciBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZW52aXJvbm1lbnRcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgfV0sIFt7XG4gICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVyI2lzU3VwcG9ydGVkIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSZW5kZXJlcjtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBSZW5kZXJlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9yZW5kZXJlcnMvcmVuZGVyZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogZXh0ZXJuYWwgXCJjYW52YXNcIlxuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIHJvb3QgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogbnVsbDtcbnZhciBwID0gcm9vdC5Qcm9taXNlO1xuXG5pZiAoIXApIHtcbiAgcCA9IHJlcXVpcmUoJy4vbmF0aXZlLXByb21pc2Utb25seScpO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3ZlbmRvci9wcm9taXNlLmpzXG4gKiogbW9kdWxlIGlkID0gOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBOYXRpdmUgUHJvbWlzZSBPbmx5XG4gKiB2MC44LjAtYSAoYykgS3lsZSBTaW1wc29uXG4gKiBNSVQgTGljZW5zZTogaHR0cDovL2dldGlmeS5taXQtbGljZW5zZS5vcmdcbiAqIEBsaWNlbnNlXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbiBVTUQobmFtZSwgY29udGV4dCwgZGVmaW5pdGlvbikge1xuICAvLyBzcGVjaWFsIGZvcm0gb2YgVU1EIGZvciBwb2x5ZmlsbGluZyBhY3Jvc3MgZXZpcm9ubWVudHNcbiAgY29udGV4dFtuYW1lXSA9IGNvbnRleHRbbmFtZV0gfHwgZGVmaW5pdGlvbigpO1xuICBpZiAodHlwZW9mIG1vZHVsZSAhPSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBjb250ZXh0W25hbWVdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24gJEFNRCQoKSB7XG4gICAgICByZXR1cm4gY29udGV4dFtuYW1lXTtcbiAgICB9KTtcbiAgfVxufSkoXCJQcm9taXNlXCIsIHR5cGVvZiBnbG9iYWwgIT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHVuZGVmaW5lZCwgZnVuY3Rpb24gREVGKCkge1xuICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICBcInVzZSBzdHJpY3RcIjtcblxuICB2YXIgYnVpbHRJblByb3AsXG4gICAgICBjeWNsZSxcbiAgICAgIHNjaGVkdWxpbmdfcXVldWUsXG4gICAgICBUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcsXG4gICAgICB0aW1lciA9IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT0gXCJ1bmRlZmluZWRcIiA/IGZ1bmN0aW9uIHRpbWVyKGZuKSB7XG4gICAgcmV0dXJuIHNldEltbWVkaWF0ZShmbik7XG4gIH0gOiBzZXRUaW1lb3V0O1xuXG4gIC8vIGRhbW1pdCwgSUU4LlxuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgXCJ4XCIsIHt9KTtcbiAgICBidWlsdEluUHJvcCA9IGZ1bmN0aW9uIGJ1aWx0SW5Qcm9wKG9iaiwgbmFtZSwgdmFsLCBjb25maWcpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBuYW1lLCB7XG4gICAgICAgIHZhbHVlOiB2YWwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IGNvbmZpZyAhPT0gZmFsc2VcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGJ1aWx0SW5Qcm9wID0gZnVuY3Rpb24gYnVpbHRJblByb3Aob2JqLCBuYW1lLCB2YWwpIHtcbiAgICAgIG9ialtuYW1lXSA9IHZhbDtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE5vdGU6IHVzaW5nIGEgcXVldWUgaW5zdGVhZCBvZiBhcnJheSBmb3IgZWZmaWNpZW5jeVxuICBzY2hlZHVsaW5nX3F1ZXVlID0gKGZ1bmN0aW9uIFF1ZXVlKCkge1xuICAgIHZhciBmaXJzdCwgbGFzdCwgaXRlbTtcblxuICAgIGZ1bmN0aW9uIEl0ZW0oZm4sIHNlbGYpIHtcbiAgICAgIHRoaXMuZm4gPSBmbjtcbiAgICAgIHRoaXMuc2VsZiA9IHNlbGY7XG4gICAgICB0aGlzLm5leHQgPSB2b2lkIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZDogZnVuY3Rpb24gYWRkKGZuLCBzZWxmKSB7XG4gICAgICAgIGl0ZW0gPSBuZXcgSXRlbShmbiwgc2VsZik7XG4gICAgICAgIGlmIChsYXN0KSB7XG4gICAgICAgICAgbGFzdC5uZXh0ID0gaXRlbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaXJzdCA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdCA9IGl0ZW07XG4gICAgICAgIGl0ZW0gPSB2b2lkIDA7XG4gICAgICB9LFxuICAgICAgZHJhaW46IGZ1bmN0aW9uIGRyYWluKCkge1xuICAgICAgICB2YXIgZiA9IGZpcnN0O1xuICAgICAgICBmaXJzdCA9IGxhc3QgPSBjeWNsZSA9IHZvaWQgMDtcblxuICAgICAgICB3aGlsZSAoZikge1xuICAgICAgICAgIGYuZm4uY2FsbChmLnNlbGYpO1xuICAgICAgICAgIGYgPSBmLm5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlKGZuLCBzZWxmKSB7XG4gICAgc2NoZWR1bGluZ19xdWV1ZS5hZGQoZm4sIHNlbGYpO1xuICAgIGlmICghY3ljbGUpIHtcbiAgICAgIGN5Y2xlID0gdGltZXIoc2NoZWR1bGluZ19xdWV1ZS5kcmFpbik7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJvbWlzZSBkdWNrIHR5cGluZ1xuICBmdW5jdGlvbiBpc1RoZW5hYmxlKG8pIHtcbiAgICB2YXIgX3RoZW4sXG4gICAgICAgIG9fdHlwZSA9IHR5cGVvZiBvO1xuXG4gICAgaWYgKG8gIT0gbnVsbCAmJiAob190eXBlID09IFwib2JqZWN0XCIgfHwgb190eXBlID09IFwiZnVuY3Rpb25cIikpIHtcbiAgICAgIF90aGVuID0gby50aGVuO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIF90aGVuID09IFwiZnVuY3Rpb25cIiA/IF90aGVuIDogZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBub3RpZnkoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoYWluLmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3RpZnlJc29sYXRlZCh0aGlzLCB0aGlzLnN0YXRlID09PSAxID8gdGhpcy5jaGFpbltpXS5zdWNjZXNzIDogdGhpcy5jaGFpbltpXS5mYWlsdXJlLCB0aGlzLmNoYWluW2ldKTtcbiAgICB9XG4gICAgdGhpcy5jaGFpbi5sZW5ndGggPSAwO1xuICB9XG5cbiAgLy8gTk9URTogVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGlzb2xhdGVcbiAgLy8gdGhlIGB0cnkuLmNhdGNoYCBzbyB0aGF0IG90aGVyIGNvZGUgY2FuIGJlXG4gIC8vIG9wdGltaXplZCBiZXR0ZXJcbiAgZnVuY3Rpb24gbm90aWZ5SXNvbGF0ZWQoc2VsZiwgY2IsIGNoYWluKSB7XG4gICAgdmFyIHJldCwgX3RoZW47XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjYiA9PT0gZmFsc2UpIHtcbiAgICAgICAgY2hhaW4ucmVqZWN0KHNlbGYubXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChjYiA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHJldCA9IHNlbGYubXNnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9IGNiLmNhbGwodm9pZCAwLCBzZWxmLm1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0ID09PSBjaGFpbi5wcm9taXNlKSB7XG4gICAgICAgICAgY2hhaW4ucmVqZWN0KFR5cGVFcnJvcihcIlByb21pc2UtY2hhaW4gY3ljbGVcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGVuID0gaXNUaGVuYWJsZShyZXQpKSB7XG4gICAgICAgICAgX3RoZW4uY2FsbChyZXQsIGNoYWluLnJlc29sdmUsIGNoYWluLnJlamVjdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhaW4ucmVzb2x2ZShyZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjaGFpbi5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNvbHZlKG1zZykge1xuICAgIHZhciBfdGhlbixcbiAgICAgICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKF90aGVuID0gaXNUaGVuYWJsZShtc2cpKSB7XG4gICAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgZGVmX3dyYXBwZXIgPSBuZXcgTWFrZURlZldyYXBwZXIoc2VsZik7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIF90aGVuLmNhbGwobXNnLCBmdW5jdGlvbiAkcmVzb2x2ZSQoKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUuYXBwbHkoZGVmX3dyYXBwZXIsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAkcmVqZWN0JCgpIHtcbiAgICAgICAgICAgICAgcmVqZWN0LmFwcGx5KGRlZl93cmFwcGVyLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QuY2FsbChkZWZfd3JhcHBlciwgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5tc2cgPSBtc2c7XG4gICAgICAgIHNlbGYuc3RhdGUgPSAxO1xuICAgICAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgc2NoZWR1bGUobm90aWZ5LCBzZWxmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0LmNhbGwobmV3IE1ha2VEZWZXcmFwcGVyKHNlbGYpLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlamVjdChtc2cpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBhbHJlYWR5IHRyaWdnZXJlZD9cbiAgICBpZiAoc2VsZi50cmlnZ2VyZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzZWxmLnRyaWdnZXJlZCA9IHRydWU7XG5cbiAgICAvLyB1bndyYXBcbiAgICBpZiAoc2VsZi5kZWYpIHtcbiAgICAgIHNlbGYgPSBzZWxmLmRlZjtcbiAgICB9XG5cbiAgICBzZWxmLm1zZyA9IG1zZztcbiAgICBzZWxmLnN0YXRlID0gMjtcbiAgICBpZiAoc2VsZi5jaGFpbi5sZW5ndGggPiAwKSB7XG4gICAgICBzY2hlZHVsZShub3RpZnksIHNlbGYpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGl0ZXJhdGVQcm9taXNlcyhDb25zdHJ1Y3RvciwgYXJyLCByZXNvbHZlciwgcmVqZWN0ZXIpIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBhcnIubGVuZ3RoOyBpZHgrKykge1xuICAgICAgKGZ1bmN0aW9uIElJRkUoaWR4KSB7XG4gICAgICAgIENvbnN0cnVjdG9yLnJlc29sdmUoYXJyW2lkeF0pLnRoZW4oZnVuY3Rpb24gJHJlc29sdmVyJChtc2cpIHtcbiAgICAgICAgICByZXNvbHZlcihpZHgsIG1zZyk7XG4gICAgICAgIH0sIHJlamVjdGVyKTtcbiAgICAgIH0pKGlkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gTWFrZURlZldyYXBwZXIoc2VsZikge1xuICAgIHRoaXMuZGVmID0gc2VsZjtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gTWFrZURlZihzZWxmKSB7XG4gICAgdGhpcy5wcm9taXNlID0gc2VsZjtcbiAgICB0aGlzLnN0YXRlID0gMDtcbiAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2hhaW4gPSBbXTtcbiAgICB0aGlzLm1zZyA9IHZvaWQgMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcbiAgICBpZiAodHlwZW9mIGV4ZWN1dG9yICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX19OUE9fXyAhPT0gMCkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgcHJvbWlzZVwiKTtcbiAgICB9XG5cbiAgICAvLyBpbnN0YW5jZSBzaGFkb3dpbmcgdGhlIGluaGVyaXRlZCBcImJyYW5kXCJcbiAgICAvLyB0byBzaWduYWwgYW4gYWxyZWFkeSBcImluaXRpYWxpemVkXCIgcHJvbWlzZVxuICAgIHRoaXMuX19OUE9fXyA9IDE7XG5cbiAgICB2YXIgZGVmID0gbmV3IE1ha2VEZWYodGhpcyk7XG5cbiAgICB0aGlzW1widGhlblwiXSA9IGZ1bmN0aW9uIHRoZW4oc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIHN1Y2Nlc3M6IHR5cGVvZiBzdWNjZXNzID09IFwiZnVuY3Rpb25cIiA/IHN1Y2Nlc3MgOiB0cnVlLFxuICAgICAgICBmYWlsdXJlOiB0eXBlb2YgZmFpbHVyZSA9PSBcImZ1bmN0aW9uXCIgPyBmYWlsdXJlIDogZmFsc2VcbiAgICAgIH07XG4gICAgICAvLyBOb3RlOiBgdGhlbiguLilgIGl0c2VsZiBjYW4gYmUgYm9ycm93ZWQgdG8gYmUgdXNlZCBhZ2FpbnN0XG4gICAgICAvLyBhIGRpZmZlcmVudCBwcm9taXNlIGNvbnN0cnVjdG9yIGZvciBtYWtpbmcgdGhlIGNoYWluZWQgcHJvbWlzZSxcbiAgICAgIC8vIGJ5IHN1YnN0aXR1dGluZyBhIGRpZmZlcmVudCBgdGhpc2AgYmluZGluZy5cbiAgICAgIG8ucHJvbWlzZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4dHJhY3RDaGFpbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRocm93IFR5cGVFcnJvcihcIk5vdCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgby5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgby5yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIGRlZi5jaGFpbi5wdXNoKG8pO1xuXG4gICAgICBpZiAoZGVmLnN0YXRlICE9PSAwKSB7XG4gICAgICAgIHNjaGVkdWxlKG5vdGlmeSwgZGVmKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG8ucHJvbWlzZTtcbiAgICB9O1xuICAgIHRoaXNbXCJjYXRjaFwiXSA9IGZ1bmN0aW9uICRjYXRjaCQoZmFpbHVyZSkge1xuICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIGZhaWx1cmUpO1xuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgZXhlY3V0b3IuY2FsbCh2b2lkIDAsIGZ1bmN0aW9uIHB1YmxpY1Jlc29sdmUobXNnKSB7XG4gICAgICAgIHJlc29sdmUuY2FsbChkZWYsIG1zZyk7XG4gICAgICB9LCBmdW5jdGlvbiBwdWJsaWNSZWplY3QobXNnKSB7XG4gICAgICAgIHJlamVjdC5jYWxsKGRlZiwgbXNnKTtcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVqZWN0LmNhbGwoZGVmLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBQcm9taXNlUHJvdG90eXBlID0gYnVpbHRJblByb3Aoe30sIFwiY29uc3RydWN0b3JcIiwgUHJvbWlzZSxcbiAgLypjb25maWd1cmFibGU9Ki9mYWxzZSk7XG5cbiAgLy8gTm90ZTogQW5kcm9pZCA0IGNhbm5vdCB1c2UgYE9iamVjdC5kZWZpbmVQcm9wZXJ0eSguLilgIGhlcmVcbiAgUHJvbWlzZS5wcm90b3R5cGUgPSBQcm9taXNlUHJvdG90eXBlO1xuXG4gIC8vIGJ1aWx0LWluIFwiYnJhbmRcIiB0byBzaWduYWwgYW4gXCJ1bmluaXRpYWxpemVkXCIgcHJvbWlzZVxuICBidWlsdEluUHJvcChQcm9taXNlUHJvdG90eXBlLCBcIl9fTlBPX19cIiwgMCxcbiAgLypjb25maWd1cmFibGU9Ki9mYWxzZSk7XG5cbiAgYnVpbHRJblByb3AoUHJvbWlzZSwgXCJyZXNvbHZlXCIsIGZ1bmN0aW9uIFByb21pc2UkcmVzb2x2ZShtc2cpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSB0aGlzO1xuXG4gICAgLy8gc3BlYyBtYW5kYXRlZCBjaGVja3NcbiAgICAvLyBub3RlOiBiZXN0IFwiaXNQcm9taXNlXCIgY2hlY2sgdGhhdCdzIHByYWN0aWNhbCBmb3Igbm93XG4gICAgaWYgKG1zZyAmJiB0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnLl9fTlBPX18gPT09IDEpIHtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobXNnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgYnVpbHRJblByb3AoUHJvbWlzZSwgXCJyZWplY3RcIiwgZnVuY3Rpb24gUHJvbWlzZSRyZWplY3QobXNnKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG1zZyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2UsIFwiYWxsXCIsIGZ1bmN0aW9uIFByb21pc2UkYWxsKGFycikge1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IHRoaXM7XG5cbiAgICAvLyBzcGVjIG1hbmRhdGVkIGNoZWNrc1xuICAgIGlmIChUb1N0cmluZy5jYWxsKGFycikgIT0gXCJbb2JqZWN0IEFycmF5XVwiKSB7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVqZWN0KFR5cGVFcnJvcihcIk5vdCBhbiBhcnJheVwiKSk7XG4gICAgfVxuICAgIGlmIChhcnIubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQ29uc3RydWN0b3IucmVzb2x2ZShbXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBDb25zdHJ1Y3RvcihmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzb2x2ZSAhPSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJlamVjdCAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTm90IGEgZnVuY3Rpb25cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoLFxuICAgICAgICAgIG1zZ3MgPSBBcnJheShsZW4pLFxuICAgICAgICAgIGNvdW50ID0gMDtcblxuICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLCBhcnIsIGZ1bmN0aW9uIHJlc29sdmVyKGlkeCwgbXNnKSB7XG4gICAgICAgIG1zZ3NbaWR4XSA9IG1zZztcbiAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbikge1xuICAgICAgICAgIHJlc29sdmUobXNncyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGJ1aWx0SW5Qcm9wKFByb21pc2UsIFwicmFjZVwiLCBmdW5jdGlvbiBQcm9taXNlJHJhY2UoYXJyKSB7XG4gICAgdmFyIENvbnN0cnVjdG9yID0gdGhpcztcblxuICAgIC8vIHNwZWMgbWFuZGF0ZWQgY2hlY2tzXG4gICAgaWYgKFRvU3RyaW5nLmNhbGwoYXJyKSAhPSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgIHJldHVybiBDb25zdHJ1Y3Rvci5yZWplY3QoVHlwZUVycm9yKFwiTm90IGFuIGFycmF5XCIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgaWYgKHR5cGVvZiByZXNvbHZlICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgcmVqZWN0ICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJOb3QgYSBmdW5jdGlvblwiKTtcbiAgICAgIH1cblxuICAgICAgaXRlcmF0ZVByb21pc2VzKENvbnN0cnVjdG9yLCBhcnIsIGZ1bmN0aW9uIHJlc29sdmVyKGlkeCwgbXNnKSB7XG4gICAgICAgIHJlc29sdmUobXNnKTtcbiAgICAgIH0sIHJlamVjdCk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBQcm9taXNlO1xufSk7XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3ZlbmRvci9uYXRpdmUtcHJvbWlzZS1vbmx5LmpzXG4gKiogbW9kdWxlIGlkID0gOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvbW5pbWVyL0RldmVsb3BtZW50L2dpdGh1Yi9GYW1pbHlEQU0vYXBwLWRhc2hib2FyZC9+L2ltZ2x5a2l0LXNkay9+L3RpbWVycy1icm93c2VyaWZ5L21haW4uanNcbiAqKiBtb2R1bGUgaWQgPSAxMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9tbmltZXIvRGV2ZWxvcG1lbnQvZ2l0aHViL0ZhbWlseURBTS9hcHAtZGFzaGJvYXJkL34vaW1nbHlraXQtc2RrL34vcHJvY2Vzcy9icm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MywgX3g0LCBfeDUpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gzLCBwcm9wZXJ0eSA9IF94NCwgcmVjZWl2ZXIgPSBfeDU7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gzID0gcGFyZW50OyBfeDQgPSBwcm9wZXJ0eTsgX3g1ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZW5kZXJlciA9IHJlcXVpcmUoJy4vcmVuZGVyZXInKTtcblxudmFyIF9yZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX3ZlbmRvclByb21pc2UgPSByZXF1aXJlKCcuLi92ZW5kb3IvcHJvbWlzZScpO1xuXG52YXIgX3ZlbmRvclByb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVuZG9yUHJvbWlzZSk7XG5cbi8qKlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuV2ViR0xSZW5kZXJlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LlJlbmRlcmVyfVxuICogQHByaXZhdGVcbiAqL1xudmFyIE1BWF9DT05URVhUX0xPU1RfQ09VTlQgPSAzO1xuXG52YXIgV2ViR0xSZW5kZXJlciA9IChmdW5jdGlvbiAoX1JlbmRlcmVyKSB7XG4gIF9pbmhlcml0cyhXZWJHTFJlbmRlcmVyLCBfUmVuZGVyZXIpO1xuXG4gIGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdlYkdMUmVuZGVyZXIpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoV2ViR0xSZW5kZXJlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB0aGlzLl9jb250ZXh0TG9zdENvdW50ID0gMDtcbiAgICB0aGlzLl9oYW5kbGVDb250ZXh0TG9zcygpO1xuXG4gICAgdGhpcy5fZGVmYXVsdFByb2dyYW0gPSB0aGlzLnNldHVwR0xTTFByb2dyYW0oKTtcbiAgICB0aGlzLnJlc2V0KCk7XG5cbiAgICB0aGlzLmlkID0gV2ViR0xSZW5kZXJlci5jb250ZXh0SWQ7XG4gICAgV2ViR0xSZW5kZXJlci5jb250ZXh0SWQrKztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB3ZWJnbCBjb250ZXh0IGhhcyBiZWVuIGxvc3RcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFdlYkdMUmVuZGVyZXIsIFt7XG4gICAga2V5OiAnX2hhbmRsZUNvbnRleHRMb3NzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUNvbnRleHRMb3NzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dGxvc3QnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLl9jb250ZXh0TG9zdENvdW50Kys7XG5cbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignV2ViR0wgY29udGV4dCBoYXMgYmVlbiBsb3N0Jyk7XG4gICAgICAgIGVyci5jb2RlID0gJ1dFQkdMX0NPTlRFWFRfTE9TVCc7XG4gICAgICAgIF90aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXMuX2NvbnRleHRMb3N0Q291bnQgPj0gTUFYX0NPTlRFWFRfTE9TVF9DT1VOVCkge1xuICAgICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1dlYkdMIGNvbnRleHQgaGFzIGJlZW4gbG9zdCBhbmQgY291bGQgbm90IGJlIHJlc3RvcmVkJyk7XG4gICAgICAgICAgZXJyLmNvZGUgPSAnV0VCR0xfQ09OVEVYVF9MT1NUX0xJTUlUJztcbiAgICAgICAgICByZXR1cm4gX3RoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmVtaXQoJ3Jlc2V0Jyk7XG4gICAgICAgIF90aGlzLnJlc2V0KHRydWUsIHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29udGV4dCBvcHRpb25zIHBhc3NlZCB0byBnZXRDb250ZXh0KClcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdjYWNoZScsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGUoaWRlbnRpZmllcikge1xuICAgICAgLy8gUmUtdXNlIEZCTyBhbmQgdGV4dHVyZXNcbiAgICAgIHZhciBmYm8gPSB1bmRlZmluZWQsXG4gICAgICAgICAgdGV4dHVyZSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBjYWNoZU9iamVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICghdGhpcy5fY2FjaGVbaWRlbnRpZmllcl0pIHtcbiAgICAgICAgY2FjaGVPYmplY3QgPSB0aGlzLl9jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVPYmplY3QgPSB0aGlzLl9jYWNoZVtpZGVudGlmaWVyXTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0cmFjdCBGQk8gYW5kIHRleHR1cmVcbiAgICAgIGZibyA9IGNhY2hlT2JqZWN0LmZibztcbiAgICAgIHRleHR1cmUgPSBjYWNoZU9iamVjdC50ZXh0dXJlO1xuXG4gICAgICAvLyBSZXNpemUgb3V0cHV0IHRleHR1cmVcbiAgICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICBnbC51c2VQcm9ncmFtKHRoaXMuX2RlZmF1bHRQcm9ncmFtKTtcbiAgICAgIHRoaXMuX3NldENvb3JkaW5hdGVzKHRoaXMuX2RlZmF1bHRQcm9ncmFtKTtcblxuICAgICAgLy8gUmVzaXplIGNhY2hlZCB0ZXh0dXJlXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy5fc2l6ZS54LCB0aGlzLl9zaXplLnksIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuXG4gICAgICAvLyBSZW5kZXIgdG8gRkJPXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZibyk7XG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLl9zaXplLngsIHRoaXMuX3NpemUueSk7XG5cbiAgICAgIC8vIFVzZSBsYXN0IGZibyB0ZXh0dXJlIGFzIGlucHV0XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9sYXN0VGV4dHVyZSk7XG5cbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAgICAgdGhpcy5fY2FjaGVbaWRlbnRpZmllcl0gPSB7IGZibzogZmJvLCB0ZXh0dXJlOiB0ZXh0dXJlLCBzaXplOiB0aGlzLl9zaXplLmNsb25lKCkgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEcmF3cyB0aGUgc3RvcmVkIHRleHR1cmUgLyBpbWFnZSBkYXRhIGZvciB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkcmF3Q2FjaGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0NhY2hlZChpZGVudGlmaWVyKSB7XG4gICAgICB2YXIgX2NhY2hlJGlkZW50aWZpZXIgPSB0aGlzLl9jYWNoZVtpZGVudGlmaWVyXTtcbiAgICAgIHZhciB0ZXh0dXJlID0gX2NhY2hlJGlkZW50aWZpZXIudGV4dHVyZTtcbiAgICAgIHZhciBzaXplID0gX2NhY2hlJGlkZW50aWZpZXIuc2l6ZTtcblxuICAgICAgdmFyIGZibyA9IHRoaXMuZ2V0Q3VycmVudEZyYW1lYnVmZmVyKCk7XG4gICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB0aGlzLmdldEN1cnJlbnRUZXh0dXJlKCk7XG5cbiAgICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICBnbC51c2VQcm9ncmFtKHRoaXMuX2RlZmF1bHRQcm9ncmFtKTtcbiAgICAgIHRoaXMuX3NldENvb3JkaW5hdGVzKHRoaXMuX2RlZmF1bHRQcm9ncmFtKTtcblxuICAgICAgLy8gUmVzaXplIGFsbCB0ZXh0dXJlc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZXh0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3RoZXJUZXh0dXJlID0gdGhpcy5fdGV4dHVyZXNbaV07XG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG90aGVyVGV4dHVyZSk7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgc2l6ZS54LCBzaXplLnksIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWxlY3QgdGhlIGN1cnJlbnQgZnJhbWVidWZmZXIgdG8gZHJhdyB0b1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmYm8pO1xuXG4gICAgICAvLyBSZXNpemUgdGhlIHRleHR1cmUgd2UncmUgZHJhd2luZyB0b1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY3VycmVudFRleHR1cmUpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBzaXplLngsIHNpemUueSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgIC8vIFVzZSB0aGUgY2FjaGVkIHRleHR1cmUgYXMgaW5wdXRcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuXG4gICAgICBnbC52aWV3cG9ydCgwLCAwLCBzaXplLngsIHNpemUueSk7XG5cbiAgICAgIC8vIENsZWFyXG4gICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZVxuICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuXG4gICAgICB0aGlzLnNldExhc3RUZXh0dXJlKGN1cnJlbnRUZXh0dXJlKTtcbiAgICAgIHRoaXMuc2VsZWN0TmV4dEJ1ZmZlcigpO1xuXG4gICAgICB0aGlzLl9zaXplID0gc2l6ZS5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IHZlcnRleCBzaGFkZXIgd2hpY2gganVzdCBwYXNzZXMgdGhlIHRleENvb3JkIHRvIHRoZVxuICAgICAqIGZyYWdtZW50IHNoYWRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0Q29udGV4dCcsXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSByZW5kZXJpbmcgY29udGV4dCBmcm9tIHRoZSBDYW52YXNcbiAgICAgKiBAcmV0dXJuIHtSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0Q29udGV4dCgpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB2YXIgZ2wgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB0aGlzLl9jb250ZXh0T3B0aW9ucykgfHwgdGhpcy5fY2FudmFzLmdldENvbnRleHQoJ2V4cGVyaW1lbnRhbC13ZWJnbCcsIHRoaXMuX2NvbnRleHRPcHRpb25zKTtcblxuICAgICAgaWYgKHdpbmRvdy5XZWJHTERlYnVnVXRpbHMpIHtcbiAgICAgICAgZ2wgPSB3aW5kb3cuV2ViR0xEZWJ1Z1V0aWxzLm1ha2VEZWJ1Z0NvbnRleHQoZ2wpO1xuICAgICAgfVxuXG4gICAgICBnbC5kaXNhYmxlKGdsLkRFUFRIX1RFU1QpO1xuICAgICAgZ2wuZGlzYWJsZShnbC5DVUxMX0ZBQ0UpO1xuXG4gICAgICB0aGlzLl9tYXhUZXh0dXJlU2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKTtcblxuICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBnaXZlbiBpbWFnZSBvbiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgfSwge1xuICAgIGtleTogJ2RyYXdJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdJbWFnZShpbWFnZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICB0aGlzLl9zaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgcmV0dXJuIG5ldyBfdmVuZG9yUHJvbWlzZTJbJ2RlZmF1bHQnXShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGdsLnVzZVByb2dyYW0oX3RoaXMyLl9kZWZhdWx0UHJvZ3JhbSk7XG4gICAgICAgIF90aGlzMi5fc2V0Q29vcmRpbmF0ZXMoX3RoaXMyLl9kZWZhdWx0UHJvZ3JhbSk7XG5cbiAgICAgICAgdmFyIGZibyA9IF90aGlzMi5nZXRDdXJyZW50RnJhbWVidWZmZXIoKTtcbiAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gX3RoaXMyLmdldEN1cnJlbnRUZXh0dXJlKCk7XG5cbiAgICAgICAgLy8gU2VsZWN0IHRoZSBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgX3RoaXMyLl9zaXplLngsIF90aGlzMi5fc2l6ZS55KTtcbiAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgY3VycmVudFRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIF90aGlzMi5fc2l6ZS54LCBfdGhpczIuX3NpemUueSwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB0ZXh0dXJlXG4gICAgICAgIHZhciB0ZXh0dXJlID0gX3RoaXMyLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgdHJ1ZSk7XG4gICAgICAgIF90aGlzMi5faW5wdXRUZXh0dXJlID0gdGV4dHVyZTtcbiAgICAgICAgX3RoaXMyLnNldExhc3RUZXh0dXJlKHRleHR1cmUpO1xuXG4gICAgICAgIC8vIFNldCBwcmVtdWx0aXBsaWVkIGFscGhhXG4gICAgICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19QUkVNVUxUSVBMWV9BTFBIQV9XRUJHTCwgdHJ1ZSk7XG5cbiAgICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlXG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xuXG4gICAgICAgIC8vIERyYXcgdGhlIHJlY3RhbmdsZVxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgNik7XG5cbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgZ2l2ZW4gaW1hZ2UgdG8gZml0IHRoZSBtYXhpbXVtIHRleHR1cmUgc2l6ZVxuICAgICAqIEBwYXJhbSB7SW1hZ2V9XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3ByZXBhcmVJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByZXBhcmVJbWFnZShpbWFnZSkge1xuICAgICAgaWYgKGltYWdlLndpZHRoIDw9IHRoaXMuX21heFRleHR1cmVTaXplICYmIGltYWdlLmhlaWdodCA8PSB0aGlzLl9tYXhUZXh0dXJlU2l6ZSkge1xuICAgICAgICByZXR1cm4gX3ZlbmRvclByb21pc2UyWydkZWZhdWx0J10ucmVzb2x2ZShpbWFnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBuZXcgc2l6ZSB0aGF0IGZpdHMgdGhlIGdyYXBoaWNzIGNhcmQncyBtYXggdGV4dHVyZSBzaXplXG4gICAgICB2YXIgbWF4U2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5fbWF4VGV4dHVyZVNpemUsIHRoaXMuX21heFRleHR1cmVTaXplKTtcbiAgICAgIHZhciBzaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcbiAgICAgIHZhciBzY2FsZSA9IE1hdGgubWluKG1heFNpemUueCAvIHNpemUueCwgbWF4U2l6ZS55IC8gc2l6ZS55KTtcbiAgICAgIHZhciBuZXdTaXplID0gc2l6ZS5jbG9uZSgpLm11bHRpcGx5KHNjYWxlKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNhbnZhcyB0byBkcmF3IHRoZSBpbWFnZSB0b1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKG5ld1NpemUueCwgbmV3U2l6ZS55KTtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHJlc2l6ZWQgaW1hZ2VcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBzaXplLngsIHNpemUueSwgMCwgMCwgbmV3U2l6ZS54LCBuZXdTaXplLnkpO1xuXG4gICAgICAvLyBUdXJuIGludG8gYSBkYXRhIHVybCBhbmQgbWFrZSBhbiBpbWFnZSBvdXQgb2YgaXRcbiAgICAgIHZhciBkYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvanBlZycpO1xuXG4gICAgICByZXR1cm4gbmV3IF92ZW5kb3JQcm9taXNlMlsnZGVmYXVsdCddKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbWFnZS5zcmMgPSBkYXRhO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBXZWJHTCBjb250ZXh0XG4gICAgICogQHBhcmFtIHtXZWJHTFJlbmRlcmluZ0NvbnRleHR9IGdsXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19jbGVhcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jbGVhcihnbCkge1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19zZXRDb29yZGluYXRlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDb29yZGluYXRlcyhwcm9ncmFtLCB0ZXh0dXJlQ29vcmRpbmF0ZXMsIHRyaWFuZ2xlQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG5cbiAgICAgIC8vIExvb2t1cCB0ZXh0dXJlIGNvb3JkaW5hdGVzIGxvY2F0aW9uXG4gICAgICB2YXIgcG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3Bvc2l0aW9uJyk7XG4gICAgICB2YXIgdGV4Q29vcmRMb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sICdhX3RleENvb3JkJyk7XG5cbiAgICAgIHRleHR1cmVDb29yZGluYXRlcyA9IHRleHR1cmVDb29yZGluYXRlcyB8fCBuZXcgRmxvYXQzMkFycmF5KFtcbiAgICAgIC8vIEZpcnN0IHRyaWFuZ2xlXG4gICAgICAwLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLFxuXG4gICAgICAvLyBTZWNvbmQgdHJpYW5nbGVcbiAgICAgIDAuMCwgMS4wLCAxLjAsIDAuMCwgMS4wLCAxLjBdKTtcblxuICAgICAgLy8gUHJvdmlkZSB0ZXh0dXJlIGNvb3JkaW5hdGVzXG4gICAgICB2YXIgdGV4Q29vcmRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCB0ZXhDb29yZEJ1ZmZlcik7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGV4dHVyZUNvb3JkaW5hdGVzLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZExvY2F0aW9uKTtcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGV4Q29vcmRMb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcblxuICAgICAgdHJpYW5nbGVDb29yZGluYXRlcyA9IHRyaWFuZ2xlQ29vcmRpbmF0ZXMgfHwgbmV3IEZsb2F0MzJBcnJheShbXG4gICAgICAvLyBGaXJzdCB0cmlhbmdsZVxuICAgICAgLTEuMCwgLTEuMCwgMS4wLCAtMS4wLCAtMS4wLCAxLjAsXG5cbiAgICAgIC8vIFNlY29uZCB0cmlhbmdsZVxuICAgICAgLTEuMCwgMS4wLCAxLjAsIC0xLjAsIDEuMCwgMS4wXSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBmb3IgdGhlIHJlY3RhbmdsZSBwb3NpdGlvbnNcbiAgICAgIHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdHJpYW5nbGVDb29yZGluYXRlcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3J1blByb2dyYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW5Qcm9ncmFtKHByb2dyYW0sIG9wdGlvbnMpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMuX2NvbnRleHQ7XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgdGhpcy5fc2V0Q29vcmRpbmF0ZXMocHJvZ3JhbSwgb3B0aW9ucy50ZXh0dXJlQ29vcmRpbmF0ZXMsIG9wdGlvbnMudHJpYW5nbGVDb29yZGluYXRlcyk7XG5cbiAgICAgIHZhciBmYm8gPSB0aGlzLmdldEN1cnJlbnRGcmFtZWJ1ZmZlcigpO1xuICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gdGhpcy5nZXRDdXJyZW50VGV4dHVyZSgpO1xuXG4gICAgICAvLyBTZWxlY3QgdGhlIGN1cnJlbnQgZnJhbWVidWZmZXJcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcbiAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuX3NpemUueCwgdGhpcy5fc2l6ZS55KTtcblxuICAgICAgLy8gUmVzaXplIHRoZSB0ZXh0dXJlIHRvIGNhbnZhcyBzaXplXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjdXJyZW50VGV4dHVyZSk7XG5cbiAgICAgIC8vIFNldCBwcmVtdWx0aXBsaWVkIGFscGhhXG4gICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMuX3NpemUueCwgdGhpcy5fc2l6ZS55LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHdlIHNlbGVjdCB0aGUgY3VycmVudCB0ZXh0dXJlXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl9sYXN0VGV4dHVyZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgdW5pZm9ybXNcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucy51bmlmb3Jtcykge1xuICAgICAgICB2YXIgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgbmFtZSk7XG4gICAgICAgIHZhciB1bmlmb3JtID0gb3B0aW9ucy51bmlmb3Jtc1tuYW1lXTtcblxuICAgICAgICBzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2knOlxuICAgICAgICAgIGNhc2UgJzFpJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICBjYXNlICcxZic6XG4gICAgICAgICAgICBnbC51bmlmb3JtMWYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnMmYnOlxuICAgICAgICAgICAgZ2wudW5pZm9ybTJmKGxvY2F0aW9uLCB1bmlmb3JtLnZhbHVlWzBdLCB1bmlmb3JtLnZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJzNmJzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0zZihsb2NhdGlvbiwgdW5pZm9ybS52YWx1ZVswXSwgdW5pZm9ybS52YWx1ZVsxXSwgdW5pZm9ybS52YWx1ZVsyXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICc0Zic6XG4gICAgICAgICAgICBnbC51bmlmb3JtNGYobG9jYXRpb24sIHVuaWZvcm0udmFsdWVbMF0sIHVuaWZvcm0udmFsdWVbMV0sIHVuaWZvcm0udmFsdWVbMl0sIHVuaWZvcm0udmFsdWVbM10pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnMmZ2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHVuaWZvcm0udmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnbWF0M2Z2JzpcbiAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIGZhbHNlLCB1bmlmb3JtLnZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pZm9ybSB0eXBlOiAnICsgdW5pZm9ybS50eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDbGVhclxuICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuXG4gICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcblxuICAgICAgdGhpcy5zZXRMYXN0VGV4dHVyZShjdXJyZW50VGV4dHVyZSk7XG4gICAgICB0aGlzLnNlbGVjdE5leHRCdWZmZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIHRoZSBnaXZlbiBzaGFkZXJcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IFt2ZXJ0ZXhTaGFkZXJdXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBbZnJhZ21lbnRTaGFkZXJdXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgfSwge1xuICAgIGtleTogJ3J1blNoYWRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1blNoYWRlcih2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBvcHRpb25zKSB7XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKSBvcHRpb25zID0ge307XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbnMudW5pZm9ybXMgPT09ICd1bmRlZmluZWQnKSBvcHRpb25zLnVuaWZvcm1zID0ge307XG5cbiAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5zZXR1cEdMU0xQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgdGhpcy5ydW5Qcm9ncmFtKHByb2dyYW0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERyYXdzIHRoZSBsYXN0IHVzZWQgYnVmZmVyIG9udG8gdGhlIGNhbnZhc1xuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJGaW5hbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckZpbmFsKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5fZGVmYXVsdFByb2dyYW07XG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAvLyBEb24ndCBkcmF3IHRvIGZyYW1lYnVmZmVyXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHZpZXdwb3J0IHNpemUgaXMgY29ycmVjdFxuICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcblxuICAgICAgLy8gU2VsZWN0IHRoZSBsYXN0IHRleHR1cmUgdGhhdCBoYXMgYmVlbiByZW5kZXJlZCB0b1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fbGFzdFRleHR1cmUpO1xuXG4gICAgICAvLyBDbGVhclxuICAgICAgdGhpcy5fY2xlYXIoZ2wpO1xuXG4gICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGVcbiAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGEgR0xTTCBwcm9ncmFtLiBVc2VzIHRoZSBkZWZhdWx0IHZlcnRleCBhbmQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICogaWYgbm9uZSBhcmUgZ2l2ZW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFt2ZXJ0ZXhTaGFkZXJdXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtmcmFnbWVudFNoYWRlcl1cbiAgICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldHVwR0xTTFByb2dyYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXR1cEdMU0xQcm9ncmFtKHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIsIHRleHR1cmVDb29yZGluYXRlcykge1xuICAgICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgIHZhciBzaGFkZXJzID0gW107XG5cbiAgICAgIC8vIFVzZSBkZWZhdWx0IHZlcnRleCBzaGFkZXJcbiAgICAgIHZlcnRleFNoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlcihnbC5WRVJURVhfU0hBREVSLCB2ZXJ0ZXhTaGFkZXIgfHwgV2ViR0xSZW5kZXJlci5wcm90b3R5cGUuZGVmYXVsdFZlcnRleFNoYWRlcik7XG4gICAgICBzaGFkZXJzLnB1c2godmVydGV4U2hhZGVyKTtcblxuICAgICAgLy8gVXNlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyXG4gICAgICBmcmFnbWVudFNoYWRlciA9IHRoaXMuX2NyZWF0ZVNoYWRlcihnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdtZW50U2hhZGVyIHx8IFdlYkdMUmVuZGVyZXIucHJvdG90eXBlLmRlZmF1bHRGcmFnbWVudFNoYWRlcik7XG4gICAgICBzaGFkZXJzLnB1c2goZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgICAvLyBDcmVhdGUgdGhlIHByb2dyYW1cbiAgICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgICAvLyBBdHRhY2ggdGhlIHNoYWRlcnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpbmsgdGhlIHByb2dyYW1cbiAgICAgIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gICAgICAvLyBDaGVjayBsaW5raW5nIHN0YXR1c1xuICAgICAgdmFyIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICAgICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIHByb2dyYW0gbGlua2luZyBlcnJvcjogJyArIGxhc3RFcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBXZWJHTCBzaGFkZXIgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgc291cmNlIGNvZGVcbiAgICAgKiBAcGFyYW0gIHtXZWJHTFNoYWRlclR5cGV9IHNoYWRlclR5cGVcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IHNoYWRlclNvdXJjZVxuICAgICAqIEByZXR1cm4ge1dlYkdMU2hhZGVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgfSwge1xuICAgIGtleTogJ19jcmVhdGVTaGFkZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlU2hhZGVyKHNoYWRlclR5cGUsIHNoYWRlclNvdXJjZSkge1xuICAgICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgLy8gQ3JlYXRlIHRoZSBzaGFkZXIgYW5kIGNvbXBpbGUgaXRcbiAgICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzaGFkZXJTb3VyY2UpO1xuICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gICAgICAvLyBDaGVjayBjb21waWxhdGlvbiBzdGF0dXNcbiAgICAgIHZhciBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcbiAgICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgICAgdmFyIGxhc3RFcnJvciA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViR0wgc2hhZGVyIGNvbXBpbGF0aW9uIGVycm9yOiAnICsgbGFzdEVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGVtcHR5IHRleHR1cmVcbiAgICAgKiBAcmV0dXJuIHtXZWJHTFRleHR1cmV9XG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVRleHR1cmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcbiAgICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcblxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcblxuICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0d28gdGV4dHVyZXMgYW5kIGZyYW1lYnVmZmVycyB0aGF0IGFyZSB1c2VkIGZvciB0aGUgc3RhY2tcbiAgICAgKiByZW5kZXJpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlRnJhbWVidWZmZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUZyYW1lYnVmZmVycygpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBfY3JlYXRlRnJhbWVidWZmZXIyID0gdGhpcy5fY3JlYXRlRnJhbWVidWZmZXIoKTtcblxuICAgICAgICB2YXIgZmJvID0gX2NyZWF0ZUZyYW1lYnVmZmVyMi5mYm87XG4gICAgICAgIHZhciB0ZXh0dXJlID0gX2NyZWF0ZUZyYW1lYnVmZmVyMi50ZXh0dXJlO1xuXG4gICAgICAgIHRoaXMuX3RleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgICAgIHRoaXMuX2ZyYW1lYnVmZmVycy5wdXNoKGZibyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGZyYW1lIGJ1ZmZlciBhbmQgdGV4dHVyZVxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZUZyYW1lYnVmZmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZUZyYW1lYnVmZmVyKCkge1xuICAgICAgdmFyIGdsID0gdGhpcy5fY29udGV4dDtcblxuICAgICAgLy8gQ3JlYXRlIHRleHR1cmVcbiAgICAgIHZhciB0ZXh0dXJlID0gdGhpcy5jcmVhdGVUZXh0dXJlKCk7XG5cbiAgICAgIC8vIFNldCBwcmVtdWx0aXBsaWVkIGFscGhhXG4gICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMuX3NpemUueCwgdGhpcy5fc2l6ZS55LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcblxuICAgICAgLy8gQ3JlYXRlIGZyYW1lYnVmZmVyXG4gICAgICB2YXIgZmJvID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZmJvKTtcblxuICAgICAgLy8gQXR0YWNoIHRoZSB0ZXh0dXJlXG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleHR1cmUsIDApO1xuXG4gICAgICByZXR1cm4geyBmYm86IGZibywgdGV4dHVyZTogdGV4dHVyZSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGN1cnJlbnQgY2FudmFzIHBpY3R1cmUgdG8gdGhlIGdpdmVuIGRpbWVuc2lvbnNcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBkaW1lbnNpb25zXG4gICAgICogQHRvZG8gVXNlIGEgZG93bnNhbXBsaW5nIHNoYWRlciBmb3Igc21vb3RoZXIgaW1hZ2UgcmVzaXppbmdcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzaXplVG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVUbyhkaW1lbnNpb25zKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgICAvLyBSZXNpemUgdGhlIGNhbnZhc1xuICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gZGltZW5zaW9ucy54O1xuICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGRpbWVuc2lvbnMueTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGZyYW1lYnVmZmVyXG4gICAgICogQHJldHVybiB7V2ViR0xGcmFtZWJ1ZmZlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldEN1cnJlbnRGcmFtZWJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRGcmFtZWJ1ZmZlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mcmFtZWJ1ZmZlcnNbdGhpcy5fYnVmZmVySW5kZXggJSAyXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHRleHR1cmVcbiAgICAgKiBAcmV0dXJuIHtXZWJHTFRleHR1cmV9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRDdXJyZW50VGV4dHVyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEN1cnJlbnRUZXh0dXJlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RleHR1cmVzW3RoaXMuX2J1ZmZlckluZGV4ICUgMl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5jcmVhc2VzIHRoZSBidWZmZXIgaW5kZXhcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdE5leHRCdWZmZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3ROZXh0QnVmZmVyKCkge1xuICAgICAgdGhpcy5fYnVmZmVySW5kZXgrKztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb2dyYW1cbiAgICAgKiBAcmV0dXJuIHtXZWJHTFByb2dyYW19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXREZWZhdWx0UHJvZ3JhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9ncmFtKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmF1bHRQcm9ncmFtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhc3QgdGV4dHVyZSB0aGF0IGhhcyBiZWVuIGRyYXduIHRvXG4gICAgICogQHJldHVybiB7V2ViR0xUZXh0dXJlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0TGFzdFRleHR1cmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0VGV4dHVyZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXN0VGV4dHVyZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFsbCB0ZXh0dXJlc1xuICAgICAqIEByZXR1cm4ge0FycmF5LjxXZWJHTFRleHR1cmU+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0VGV4dHVyZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0dXJlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90ZXh0dXJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsYXN0IHRleHR1cmVcbiAgICAgKiBAcGFyYW0ge1dlYkdMVGV4dHVyZX0gdGV4dHVyZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2V0TGFzdFRleHR1cmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMYXN0VGV4dHVyZSh0ZXh0dXJlKSB7XG4gICAgICB0aGlzLl9sYXN0VGV4dHVyZSA9IHRleHR1cmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSByZW5kZXJlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzZXRDYWNoZSA9IGZhbHNlXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBuZXdDb250ZXh0ID0gZmFsc2VcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3Jlc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIgcmVzZXRDYWNoZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgdGhpcy5fbGFzdFRleHR1cmUgPSBudWxsO1xuICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcbiAgICAgIHRoaXMuX2ZyYW1lYnVmZmVycyA9IFtdO1xuICAgICAgdGhpcy5fYnVmZmVySW5kZXggPSAwO1xuXG4gICAgICBpZiAocmVzZXRDYWNoZSkge1xuICAgICAgICB0aGlzLl9jYWNoZSA9IFtdO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3Q29udGV4dCkge1xuICAgICAgICB0aGlzLl9pbnB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gdGhpcy5fZ2V0Q29udGV4dCgpO1xuICAgICAgICB0aGlzLl9kZWZhdWx0UHJvZ3JhbSA9IHRoaXMuc2V0dXBHTFNMUHJvZ3JhbSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jcmVhdGVGcmFtZWJ1ZmZlcnMoKTtcbiAgICAgIHRoaXMuc2V0TGFzdFRleHR1cmUodGhpcy5faW5wdXRUZXh0dXJlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfY29udGV4dE9wdGlvbnMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWxwaGE6IHRydWUsXG4gICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3dlYmdsJztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZWZhdWx0VmVydGV4U2hhZGVyJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBzaGFkZXIgPSAnXFxuICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAwLCAxKTtcXG4gICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbiAgICAgIH1cXG4gICAgJztcbiAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgZnJhZ21lbnQgc2hhZGVyIHdoaWNoIHdpbGwganVzdCBsb29rIHVwIHRoZSBjb2xvcnMgZnJvbSB0aGVcbiAgICAgKiB0ZXh0dXJlLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RlZmF1bHRGcmFnbWVudFNoYWRlcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgIH1cXG4gICAgJztcbiAgICAgIHJldHVybiBzaGFkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhpcyB0eXBlIG9mIHJlbmRlcmVyIGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnbWF4VGV4dHVyZVNpemUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21heFRleHR1cmVTaXplO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1N1cHBvcnRlZCgpIHtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgIHZhciBnbCA9IGNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpIHx8IGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnKTtcbiAgICAgIHJldHVybiAhIWdsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJHTFJlbmRlcmVyO1xufSkoX3JlbmRlcmVyMlsnZGVmYXVsdCddKTtcblxuV2ViR0xSZW5kZXJlci5jb250ZXh0SWQgPSAwO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBXZWJHTFJlbmRlcmVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3JlbmRlcmVycy93ZWJnbC1yZW5kZXJlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2Jhc2U2NCA9IHJlcXVpcmUoJy4vYmFzZTY0Jyk7XG5cbnZhciBfYmFzZTY0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2U2NCk7XG5cbnZhciBfbWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX21hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21hdGhWZWN0b3IyKTtcblxudmFyIF9jbGFzc0xpc3QgPSByZXF1aXJlKCcuL2NsYXNzLWxpc3QnKTtcblxudmFyIF9jbGFzc0xpc3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY2xhc3NMaXN0KTtcblxuLyoqXG4gKiBQcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgaW50ZXJuYWwgdXNlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuXG52YXIgVXRpbHMgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVdGlscygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVXRpbHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFV0aWxzLCBudWxsLCBbe1xuICAgIGtleTogJ2lzQXJyYXknLFxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gQXJyYXlcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FycmF5KG9iamVjdCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGl0ZW1zIHNlbGVjdGVkIGJ5IHRoZSBnaXZlbiBzZWxlY3RvclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBpdGVtc1xuICAgICAqIEBwYXJhbSAge0ltZ2x5S2l0flNlbGVjdG9yfSBzZWxlY3RvciAtIFRoZSBzZWxlY3RvclxuICAgICAqIEByZXR1cm4ge0FycmF5fSBUaGUgc2VsZWN0ZWQgaXRlbXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdChpdGVtcykge1xuICAgICAgdmFyIHNlbGVjdG9yID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgaWYgKHNlbGVjdG9yID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICAgIH1cblxuICAgICAgLy8gVHVybiBzdHJpbmcgcGFyYW1ldGVyIGludG8gYW4gYXJyYXlcbiAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3Iuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gaWRlbnRpZmllci50cmltKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUdXJuIGFycmF5IHBhcmFtZXRlciBpbnRvIGFuIG9iamVjdCB3aXRoIGBvbmx5YFxuICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoc2VsZWN0b3IpKSB7XG4gICAgICAgIHNlbGVjdG9yID0geyBvbmx5OiBzZWxlY3RvciB9O1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yLm9ubHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3Iub25seSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBzZWxlY3Rvci5vbmx5ID0gc2VsZWN0b3Iub25seS5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIudHJpbSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IG9ubHkgdGhlIGdpdmVuIGlkZW50aWZpZXJzXG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3Iub25seS5pbmRleE9mKGl0ZW0pICE9PSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzZWxlY3Rvci5leGNlcHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0b3IuZXhjZXB0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHNlbGVjdG9yLmV4Y2VwdCA9IHNlbGVjdG9yLmV4Y2VwdC5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoaWRlbnRpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIGlkZW50aWZpZXIudHJpbSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2VsZWN0IGFsbCBidXQgdGhlIGdpdmVuIGlkZW50aWZpZXJzXG4gICAgICAgIHJldHVybiBpdGVtcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gc2VsZWN0b3IuZXhjZXB0LmluZGV4T2YoaXRlbSkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVdGlscyNzZWxlY3QgZmFpbGVkIHRvIGZpbHRlciBpdGVtcy4nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBnaXZlbiBvYmplY3QncyB2YWx1ZXMgYXMgYW4gYXJyYXlcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybnMge0FycmF5PCo+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndmFsdWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICB2YWx1ZXMucHVzaChvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9ICBvXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB9LCB7XG4gICAga2V5OiAnaXNET01FbGVtZW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNET01FbGVtZW50KG8pIHtcbiAgICAgIHJldHVybiB0eXBlb2YgSFRNTEVsZW1lbnQgPT09ICdvYmplY3QnID8gbyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IDogbyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgbyAhPT0gbnVsbCAmJiBvLm5vZGVUeXBlID09PSAxICYmIHR5cGVvZiBvLm5vZGVOYW1lID09PSAnc3RyaW5nJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB4IGFuZCB5IHBvc2l0aW9uIGZvciB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRFdmVudFBvc2l0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXZlbnRQb3NpdGlvbihlKSB7XG4gICAgICB2YXIgeCA9IGUuY2xpZW50WDtcbiAgICAgIHZhciB5ID0gZS5jbGllbnRZO1xuICAgICAgaWYgKGUudHlwZS5pbmRleE9mKCd0b3VjaCcpICE9PSAtMSkge1xuICAgICAgICB4ID0gZS50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHkgPSBlLnRvdWNoZXNbMF0uY2xpZW50WTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgX21hdGhWZWN0b3IyMlsnZGVmYXVsdCddKHgsIHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aCBnaXZlbiBldmVudCBpcyBhIHRvdWNoIGV2ZW50XG4gICAgICogQHBhcmFtICB7RXZlbnR9ICBlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2lzVG91Y2hFdmVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzVG91Y2hFdmVudChlKSB7XG4gICAgICByZXR1cm4gZS50eXBlLmluZGV4T2YoJ3RvdWNoJykgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGdpdmVuIHZlY3RvciB0byBmaXQgaW5zaWRlIHRoZSBnaXZlbiBtYXggc2l6ZSB3aGlsZSBtYWludGFpbmluZ1xuICAgICAqIHRoZSBhc3BlY3QgcmF0aW9cbiAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSB2ZWN0b3JcbiAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBtYXhcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzaXplVmVjdG9yVG9GaXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemVWZWN0b3JUb0ZpdCh2ZWN0b3IsIG1heCkge1xuICAgICAgdmFyIHNjYWxlID0gTWF0aC5taW4obWF4LnggLyB2ZWN0b3IueCwgbWF4LnkgLyB2ZWN0b3IueSk7XG4gICAgICB2YXIgbmV3U2l6ZSA9IHZlY3Rvci5jbG9uZSgpLm11bHRpcGx5KHNjYWxlKTtcbiAgICAgIHJldHVybiBuZXdTaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0KHMpIHRvIHRoZSBkZXN0aW5hdGlvblxuICAgICAqIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIHVuZGVmaW5lZC4gT25jZSBhXG4gICAgICogcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICAgICAqIEBwYXJhbSAge09iamVjdH0gLi4uc291cmNlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RlZmF1bHRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVmYXVsdHMob2JqZWN0KSB7XG4gICAgICAvLyBTaGFsbG93IGNsb25lXG4gICAgICB2YXIgbmV3T2JqZWN0ID0ge307XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIG5ld09iamVjdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgICB9XG5cbiAgICAgIC8vIENsb25lIHNvdXJjZXNcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHNvdXJjZXMgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIHNvdXJjZXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld09iamVjdFtrZXldID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld09iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2Ygc291cmNlIG9iamVjdChzKSB0byB0aGUgZGVzdGluYXRpb25cbiAgICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICAgKiBzb3VyY2VzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gLi4uc291cmNlc1xuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2V4dGVuZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZChvYmplY3QpIHtcbiAgICAgIC8vIFNoYWxsb3cgY2xvbmVcbiAgICAgIHZhciBuZXdPYmplY3QgPSB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgbmV3T2JqZWN0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gRXh0ZW5kIHNvdXJjZXNcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBzb3VyY2VzID0gQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBzb3VyY2VzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaV07XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICBuZXdPYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdPYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvcGVydHkgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgXG4gICAgICogQHBhcmFtICB7T2JqZWN0fSBvYmplY3RcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGtleVxuICAgICAqIEBwYXJhbSAgez99IFtkZWZhdWx0VmFsdWVdXG4gICAgICogQHJldHVybiB7P31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2ZldGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2gob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIC8vIFJlcGxhY2UgaW5kZXhlcyB3aXRoIHByb3BlcnR5IGFjY2Vzc29yc1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXFxbKFxcdyspXFxdL2csICcuJDEnKTtcbiAgICAgIC8vIFN0cmlwIGxlYWRpbmcgZG90ICh3aGVuIHBhdGggYmVnaW5zIHdpdGggWzBdIGZvciBleGFtcGxlKVxuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLi8sICcnKTtcblxuICAgICAgdmFyIHBhdGhTZWdtZW50cyA9IHBhdGguc3BsaXQoJy4nKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aFNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gcGF0aFNlZ21lbnRzW2ldO1xuICAgICAgICBvYmplY3QgPSBvYmplY3Rbc2VnbWVudF07XG4gICAgICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9iamVjdCA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgQmxvYiBVUkkgZnJvbSB0aGUgZ2l2ZW4gRGF0YSBVUklcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY3JlYXRlQmxvYlVSSUZyb21EYXRhVVJJJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQmxvYlVSSUZyb21EYXRhVVJJKGRhdGEpIHtcbiAgICAgIGlmICghd2luZG93LkJsb2IgfHwgIXdpbmRvdy5VUkwgfHwgIUFycmF5QnVmZmVyIHx8ICFVaW50OEFycmF5KSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF3RGF0YSA9IF9iYXNlNjQyWydkZWZhdWx0J10uZGVjb2RlKGRhdGEuc3BsaXQoJywnKVsxXSk7XG4gICAgICB2YXIgbWltZVN0cmluZyA9IGRhdGEuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XG5cbiAgICAgIC8vIHdyaXRlIHRoZSBieXRlcyBvZiB0aGUgc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyXG4gICAgICB2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIocmF3RGF0YS5sZW5ndGgpO1xuICAgICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYXdEYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludEFycmF5W2ldID0gcmF3RGF0YVtpXTtcbiAgICAgIH1cblxuICAgICAgLy8gd3JpdGUgdGhlIEFycmF5QnVmZmVyIHRvIGEgYmxvYiwgYW5kIHlvdSdyZSBkb25lXG4gICAgICB2YXIgYmxvYiA9IG5ldyB3aW5kb3cuQmxvYihbYXJyYXlCdWZmZXJdLCB7XG4gICAgICAgIHR5cGU6IG1pbWVTdHJpbmdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgQ2xhc3NMaXN0YCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gIHtET01FbGVtZW50fSBlbFxuICAgICAqIEByZXR1cm4ge0NsYXNzTGlzdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NsYXNzTGlzdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsYXNzTGlzdChlbCkge1xuICAgICAgcmV0dXJuIG5ldyBfY2xhc3NMaXN0MlsnZGVmYXVsdCddKGVsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2IpIHtcbiAgICAgIHZhciBmYWxsYmFjayA9IGZ1bmN0aW9uIGZhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyA2MCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbGxiYWNrKGNiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCBmYWxsYmFjaykoY2IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVdGlscztcbn0pKCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFV0aWxzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDEzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiFcbiAqIEV4dHJhY3RlZCBmcm9tIE1pbmlmeUpwZWcgKENvcHlyaWdodCAoYykgMjAxNCBIaXJvYWtpIE1hdG9iYSwgTUlUIExpY2Vuc2UpOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2hNYXRvYmEvTWluaWZ5SnBlZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgS0VZX1NUUiA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgZW5jb2RlOiBmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICB2YXIgb3V0cHV0ID0gJycsXG4gICAgICAgIGNocjEgPSB1bmRlZmluZWQsXG4gICAgICAgIGNocjIgPSB1bmRlZmluZWQsXG4gICAgICAgIGNocjMgPSAnJyxcbiAgICAgICAgZW5jMSA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jMiA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jMyA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jNCA9ICcnLFxuICAgICAgICBpID0gMDtcblxuICAgIGRvIHtcbiAgICAgIGNocjEgPSBpbnB1dFtpKytdO1xuICAgICAgY2hyMiA9IGlucHV0W2krK107XG4gICAgICBjaHIzID0gaW5wdXRbaSsrXTtcblxuICAgICAgZW5jMSA9IGNocjEgPj4gMjtcbiAgICAgIGVuYzIgPSAoY2hyMSAmIDMpIDw8IDQgfCBjaHIyID4+IDQ7XG4gICAgICBlbmMzID0gKGNocjIgJiAxNSkgPDwgMiB8IGNocjMgPj4gNjtcbiAgICAgIGVuYzQgPSBjaHIzICYgNjM7XG5cbiAgICAgIGlmIChpc05hTihjaHIyKSkge1xuICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xuICAgICAgfSBlbHNlIGlmIChpc05hTihjaHIzKSkge1xuICAgICAgICBlbmM0ID0gNjQ7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCA9IG91dHB1dCArIEtFWV9TVFIuY2hhckF0KGVuYzEpICsgS0VZX1NUUi5jaGFyQXQoZW5jMikgKyBLRVlfU1RSLmNoYXJBdChlbmMzKSArIEtFWV9TVFIuY2hhckF0KGVuYzQpO1xuICAgICAgY2hyMSA9IGNocjIgPSBjaHIzID0gJyc7XG4gICAgICBlbmMxID0gZW5jMiA9IGVuYzMgPSBlbmM0ID0gJyc7XG4gICAgfSB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCk7XG5cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuXG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG4gICAgdmFyIGNocjEgPSB1bmRlZmluZWQsXG4gICAgICAgIGNocjIgPSB1bmRlZmluZWQsXG4gICAgICAgIGNocjMgPSAnJyxcbiAgICAgICAgZW5jMSA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jMiA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jMyA9IHVuZGVmaW5lZCxcbiAgICAgICAgZW5jNCA9ICcnLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgYnVmID0gW107XG5cbiAgICAvLyByZW1vdmUgYWxsIGNoYXJhY3RlcnMgdGhhdCBhcmUgbm90IEEtWiwgYS16LCAwLTksICssIC8sIG9yID1cbiAgICB2YXIgYmFzZTY0dGVzdCA9IC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZztcbiAgICBpZiAoYmFzZTY0dGVzdC5leGVjKGlucHV0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGVyZSB3ZXJlIGludmFsaWQgYmFzZTY0IGNoYXJhY3RlcnMgaW4gdGhlIGlucHV0IHRleHQuXFxuJyArICdWYWxpZCBiYXNlNjQgY2hhcmFjdGVycyBhcmUgQS1aLCBhLXosIDAtOSwgXFwnK1xcJywgXFwnL1xcJyxhbmQgXFwnPVxcJ1xcbicgKyAnRXhwZWN0IGVycm9ycyBpbiBkZWNvZGluZy4nKTtcbiAgICB9XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKC9bXkEtWmEtejAtOVxcK1xcL1xcPV0vZywgJycpO1xuXG4gICAgZG8ge1xuICAgICAgZW5jMSA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG4gICAgICBlbmMyID0gS0VZX1NUUi5pbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcbiAgICAgIGVuYzMgPSBLRVlfU1RSLmluZGV4T2YoaW5wdXQuY2hhckF0KGkrKykpO1xuICAgICAgZW5jNCA9IEtFWV9TVFIuaW5kZXhPZihpbnB1dC5jaGFyQXQoaSsrKSk7XG5cbiAgICAgIGNocjEgPSBlbmMxIDw8IDIgfCBlbmMyID4+IDQ7XG4gICAgICBjaHIyID0gKGVuYzIgJiAxNSkgPDwgNCB8IGVuYzMgPj4gMjtcbiAgICAgIGNocjMgPSAoZW5jMyAmIDMpIDw8IDYgfCBlbmM0O1xuXG4gICAgICBidWYucHVzaChjaHIxKTtcblxuICAgICAgaWYgKGVuYzMgIT09IDY0KSB7XG4gICAgICAgIGJ1Zi5wdXNoKGNocjIpO1xuICAgICAgfVxuICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XG4gICAgICAgIGJ1Zi5wdXNoKGNocjMpO1xuICAgICAgfVxuXG4gICAgICBjaHIxID0gY2hyMiA9IGNocjMgPSAnJztcbiAgICAgIGVuYzEgPSBlbmMyID0gZW5jMyA9IGVuYzQgPSAnJztcbiAgICB9IHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2Jhc2U2NC5qc1xuICoqIG1vZHVsZSBpZCA9IDE0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBDbGFzc0xpc3QgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDbGFzc0xpc3QoZWwpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xhc3NMaXN0KTtcblxuICAgIHRoaXMuX2VsID0gZWw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2xhc3NMaXN0LCBbe1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5fZWwuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBjbGFzc05hbWVzLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgIHRoaXMuX2VsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZXMuam9pbignICcpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZShjbGFzc05hbWUpIHtcbiAgICAgIHZhciBjbGFzc05hbWVzID0gdGhpcy5fZWwuY2xhc3NOYW1lLnNwbGl0KCcgJyk7XG4gICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcy5maWx0ZXIoZnVuY3Rpb24gKGNsKSB7XG4gICAgICAgIHJldHVybiBjbCAhPT0gY2xhc3NOYW1lO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9lbC5jbGFzc05hbWUgPSBjbGFzc05hbWVzLmpvaW4oJyAnKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2xhc3NMaXN0O1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2xhc3NMaXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9jbGFzcy1saXN0LmpzXG4gKiogbW9kdWxlIGlkID0gMTVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgX2NvbnN0YW50cyA9IHJlcXVpcmUoJy4uL2NvbnN0YW50cycpO1xuXG52YXIgX3V0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgX3V0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3V0aWxzKTtcblxudmFyIF92ZW5kb3JQcm9taXNlID0gcmVxdWlyZSgnLi4vdmVuZG9yL3Byb21pc2UnKTtcblxudmFyIF92ZW5kb3JQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlbmRvclByb21pc2UpO1xuXG52YXIgX2V4aWYgPSByZXF1aXJlKCcuL2V4aWYnKTtcblxudmFyIF9leGlmMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2V4aWYpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkltYWdlRXhwb3J0ZXJcbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEltYWdlRXhwb3J0ZXIgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBJbWFnZUV4cG9ydGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbWFnZUV4cG9ydGVyKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbWFnZUV4cG9ydGVyLCBudWxsLCBbe1xuICAgIGtleTogJ3ZhbGlkYXRlU2V0dGluZ3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVNldHRpbmdzKHJlbmRlclR5cGUsIGltYWdlRm9ybWF0KSB7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgIHJlbmRlclR5cGU6IHJlbmRlclR5cGUsXG4gICAgICAgIGltYWdlRm9ybWF0OiBpbWFnZUZvcm1hdFxuICAgICAgfTtcblxuICAgICAgLy8gVmFsaWRhdGUgUmVuZGVyVHlwZVxuICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5yZW5kZXJUeXBlICE9PSAndW5kZWZpbmVkJyAmJiBzZXR0aW5ncy5yZW5kZXJUeXBlICE9PSBudWxsICYmIF91dGlsczJbJ2RlZmF1bHQnXS52YWx1ZXMoX2NvbnN0YW50cy5SZW5kZXJUeXBlKS5pbmRleE9mKHNldHRpbmdzLnJlbmRlclR5cGUpID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmVuZGVyIHR5cGU6ICcgKyBzZXR0aW5ncy5yZW5kZXJUeXBlKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlbmRlclR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNldHRpbmdzLnJlbmRlclR5cGUgPSBfY29uc3RhbnRzLlJlbmRlclR5cGUuREFUQVVSTDtcbiAgICAgIH1cblxuICAgICAgLy8gVmFsaWRhdGUgSW1hZ2VGb3JtYXRcbiAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MuaW1hZ2VGb3JtYXQgIT09ICd1bmRlZmluZWQnICYmIHNldHRpbmdzLmltYWdlRm9ybWF0ICE9PSBudWxsICYmIF91dGlsczJbJ2RlZmF1bHQnXS52YWx1ZXMoX2NvbnN0YW50cy5JbWFnZUZvcm1hdCkuaW5kZXhPZihzZXR0aW5ncy5pbWFnZUZvcm1hdCkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbWFnZSBmb3JtYXQ6ICcgKyBzZXR0aW5ncy5pbWFnZUZvcm1hdCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbWFnZUZvcm1hdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2V0dGluZ3MuaW1hZ2VGb3JtYXQgPSBfY29uc3RhbnRzLkltYWdlRm9ybWF0LlBORztcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIHR5cGUgJ2J1ZmZlcicgb25seSBhdmFpbGFibGUgaW4gbm9kZVxuICAgICAgaWYgKHNldHRpbmdzLnJlbmRlclR5cGUgPT09IF9jb25zdGFudHMuUmVuZGVyVHlwZS5CVUZGRVIgJiYgdHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyIHR5cGUgXFwnYnVmZmVyXFwnIGlzIG9ubHkgYXZhaWxhYmxlIHdoZW4gdXNpbmcgbm9kZS5qcycpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgaW1hZ2UgZnJvbSB0aGUgZ2l2ZW4gY2FudmFzIHdpdGggdGhlIGdpdmVuIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gIHtJbWdseUtpdH0ga2l0XG4gICAgICogQHBhcmFtICB7SW1hZ2V9IGltYWdlXG4gICAgICogQHBhcmFtICB7Q2FudmFzfSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtJbWdseUtpdC5SZW5kZXJUeXBlfSByZW5kZXJUeXBlXG4gICAgICogQHBhcmFtICB7SW1nbHlLaXQuSW1hZ2VGb3JtYXR9IGltYWdlRm9ybWF0XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBxdWFsaXR5ID0gMC44XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2V4cG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9leHBvcnQoa2l0LCBpbWFnZSwgY2FudmFzLCByZW5kZXJUeXBlLCBpbWFnZUZvcm1hdCkge1xuICAgICAgdmFyIHF1YWxpdHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgfHwgYXJndW1lbnRzWzVdID09PSB1bmRlZmluZWQgPyAwLjggOiBhcmd1bWVudHNbNV07XG5cbiAgICAgIHJldHVybiBuZXcgX3ZlbmRvclByb21pc2UyWydkZWZhdWx0J10oZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVuZGVyVHlwZSA9PT0gX2NvbnN0YW50cy5SZW5kZXJUeXBlLklNQUdFIHx8IHJlbmRlclR5cGUgPT09IF9jb25zdGFudHMuUmVuZGVyVHlwZS5EQVRBVVJMKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAvLyBRdWFsaXR5IG5vdCBzdXBwb3J0ZWQgaW4gbm9kZSBlbnZpcm9ubWVudCAvIG5vZGUtY2FudmFzXG4gICAgICAgICAgICByZXN1bHQgPSBjYW52YXMudG9EYXRhVVJMKGltYWdlRm9ybWF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY2FudmFzLnRvRGF0YVVSTChpbWFnZUZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2hlbiBpbWFnZSdzIGBzcmNgIGF0dHJpYnV0ZSBpcyBhIGpwZWcgZGF0YSB1cmwsIHdlIGNhbiByZXN0b3JlXG4gICAgICAgICAgLy8gdGhlIGV4aWYgaW5mb3JtYXRpb25cbiAgICAgICAgICBpZiAoX2V4aWYyWydkZWZhdWx0J10uaXNKUEVHKGltYWdlLnNyYykgJiYgX2V4aWYyWydkZWZhdWx0J10uaXNKUEVHKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHZhciBleGlmID0ga2l0LmV4aWY7XG5cbiAgICAgICAgICAgIGlmIChleGlmKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGV4aWYucmVzdG9yZUV4aWZUYWdzKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlbmRlclR5cGUgPT09IF9jb25zdGFudHMuUmVuZGVyVHlwZS5JTUFHRSkge1xuICAgICAgICAgIHZhciBvdXRwdXRJbWFnZSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gTm90IGEgYnJvd3NlciBlbnZpcm9ubWVudFxuICAgICAgICAgICAgdmFyIENhbnZhc0ltYWdlID0gcmVxdWlyZSgnY2FudmFzJykuSW1hZ2U7XG4gICAgICAgICAgICBvdXRwdXRJbWFnZSA9IG5ldyBDYW52YXNJbWFnZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRJbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG91dHB1dEltYWdlLnNyYyA9IHJlc3VsdDtcbiAgICAgICAgICByZXNvbHZlKG91dHB1dEltYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJUeXBlID09PSBfY29uc3RhbnRzLlJlbmRlclR5cGUuREFUQVVSTCkge1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChyZW5kZXJUeXBlID09PSBfY29uc3RhbnRzLlJlbmRlclR5cGUuQlVGRkVSKSB7XG4gICAgICAgICAgcmVzb2x2ZShjYW52YXMudG9CdWZmZXIoKSk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gX2NvbnN0YW50cy5SZW5kZXJUeXBlLk1TQkxPQikge1xuICAgICAgICAgIHJlc29sdmUoY2FudmFzLm1zVG9CbG9iKCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHJlbmRlclR5cGUgPT09IF9jb25zdGFudHMuUmVuZGVyVHlwZS5CTE9CKSB7XG4gICAgICAgICAgY2FudmFzLnRvQmxvYihmdW5jdGlvbiAoYmxvYikge1xuICAgICAgICAgICAgcmVzb2x2ZShibG9iKTtcbiAgICAgICAgICB9LCBpbWFnZUZvcm1hdCwgcXVhbGl0eSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbWFnZUV4cG9ydGVyO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSW1hZ2VFeHBvcnRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvaW1hZ2UtZXhwb3J0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxNlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbi8qKlxuICogVGhlIGF2YWlsYWJsZSByZW5kZXIgdHlwZXNcbiAqIEBlbnVtIHtzdHJpbmd9XG4gKiBAYWxpYXMgSW1nbHlLaXQuUmVuZGVyVHlwZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xudmFyIFJlbmRlclR5cGUgPSB7XG4gIElNQUdFOiAnaW1hZ2UnLFxuICBEQVRBVVJMOiAnZGF0YS11cmwnLFxuICBCVUZGRVI6ICdidWZmZXInLFxuICBCTE9COiAnYmxvYicsXG4gIE1TQkxPQjogJ21zLWJsb2InXG59O1xuXG5leHBvcnRzLlJlbmRlclR5cGUgPSBSZW5kZXJUeXBlO1xuLyoqXG4gKiBUaGUgYXZhaWxhYmxlIG91dHB1dCBpbWFnZSBmb3JtYXRzXG4gKiBAZW51bSB7c3RyaW5nfVxuICogQGFsaWFzIEltZ2x5S2l0LkltYWdlRm9ybWF0XG4gKi9cbnZhciBJbWFnZUZvcm1hdCA9IHtcbiAgUE5HOiAnaW1hZ2UvcG5nJyxcbiAgSlBFRzogJ2ltYWdlL2pwZWcnXG59O1xuZXhwb3J0cy5JbWFnZUZvcm1hdCA9IEltYWdlRm9ybWF0O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9jb25zdGFudHMuanNcbiAqKiBtb2R1bGUgaWQgPSAxN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyohXG4gKiBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZXhpZi1qcy9leGlmLWpzIGJ5IEphY29iIFNlaWRlbGluXG4gKiBMaWNlbnNlZCB1bmRlciBNSVRcbiAqL1xuXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9zbGljZWRUb0FycmF5ID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gc2xpY2VJdGVyYXRvcihhcnIsIGkpIHsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbJ3JldHVybiddKSBfaVsncmV0dXJuJ10oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZScpOyB9IH07IH0pKCk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBfYmFzZTY0ID0gcmVxdWlyZSgnLi9iYXNlNjQnKTtcblxudmFyIF9iYXNlNjQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZTY0KTtcblxudmFyIF9hcnJheVN0cmVhbSA9IHJlcXVpcmUoJy4vYXJyYXktc3RyZWFtJyk7XG5cbnZhciBfYXJyYXlTdHJlYW0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYXJyYXlTdHJlYW0pO1xuXG52YXIgRVhJRl9UQUdTID0ge1xuICAweDAxMDA6ICdJbWFnZVdpZHRoJyxcbiAgMHgwMTAxOiAnSW1hZ2VIZWlnaHQnLFxuICAweDg3Njk6ICdFeGlmSUZEUG9pbnRlcicsXG4gIDB4ODgyNTogJ0dQU0luZm9JRkRQb2ludGVyJyxcbiAgMHhBMDA1OiAnSW50ZXJvcGVyYWJpbGl0eUlGRFBvaW50ZXInLFxuICAweDAxMDI6ICdCaXRzUGVyU2FtcGxlJyxcbiAgMHgwMTAzOiAnQ29tcHJlc3Npb24nLFxuICAweDAxMDY6ICdQaG90b21ldHJpY0ludGVycHJldGF0aW9uJyxcbiAgMHgwMTEyOiAnT3JpZW50YXRpb24nLFxuICAweDAxMTU6ICdTYW1wbGVzUGVyUGl4ZWwnLFxuICAweDAxMUM6ICdQbGFuYXJDb25maWd1cmF0aW9uJyxcbiAgMHgwMjEyOiAnWUNiQ3JTdWJTYW1wbGluZycsXG4gIDB4MDIxMzogJ1lDYkNyUG9zaXRpb25pbmcnLFxuICAweDAxMUE6ICdYUmVzb2x1dGlvbicsXG4gIDB4MDExQjogJ1lSZXNvbHV0aW9uJyxcbiAgMHgwMTI4OiAnUmVzb2x1dGlvblVuaXQnLFxuICAweDAxMTE6ICdTdHJpcE9mZnNldHMnLFxuICAweDAxMTY6ICdSb3dzUGVyU3RyaXAnLFxuICAweDAxMTc6ICdTdHJpcEJ5dGVDb3VudHMnLFxuICAweDAyMDE6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXQnLFxuICAweDAyMDI6ICdKUEVHSW50ZXJjaGFuZ2VGb3JtYXRMZW5ndGgnLFxuICAweDAxMkQ6ICdUcmFuc2ZlckZ1bmN0aW9uJyxcbiAgMHgwMTNFOiAnV2hpdGVQb2ludCcsXG4gIDB4MDEzRjogJ1ByaW1hcnlDaHJvbWF0aWNpdGllcycsXG4gIDB4MDIxMTogJ1lDYkNyQ29lZmZpY2llbnRzJyxcbiAgMHgwMjE0OiAnUmVmZXJlbmNlQmxhY2tXaGl0ZScsXG4gIDB4MDEzMjogJ0RhdGVUaW1lJyxcbiAgMHgwMTBFOiAnSW1hZ2VEZXNjcmlwdGlvbicsXG4gIDB4MDEwRjogJ01ha2UnLFxuICAweDAxMTA6ICdNb2RlbCcsXG4gIDB4MDEzMTogJ1NvZnR3YXJlJyxcbiAgMHgwMTNCOiAnQXJ0aXN0JyxcbiAgMHg4Mjk4OiAnQ29weXJpZ2h0J1xufTtcblxudmFyIERBVEFfSlBFR19QUkVGSVggPSAnZGF0YTppbWFnZS9qcGVnO2Jhc2U2NCwnO1xudmFyIEpQRUdfUkVHRVggPSBuZXcgUmVnRXhwKCdeJyArIERBVEFfSlBFR19QUkVGSVgsICdpJyk7XG5cbnZhciBFeGlmID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRXhpZihidWYpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXhpZik7XG5cbiAgICB0aGlzLl9idWYgPSBidWY7XG4gICAgdGhpcy5fc3RyZWFtID0gbmV3IF9hcnJheVN0cmVhbTJbJ2RlZmF1bHQnXSh0aGlzLl9idWYpO1xuICAgIHRoaXMuX3N0cmVhbS5zZXRIZWFkKDApO1xuXG4gICAgdGhpcy5fc2VnbWVudHMgPSB0aGlzLl9zbGljZUludG9TZWdtZW50cyh0aGlzLl9idWYpO1xuICAgIHRoaXMuX2V4aWZCdWZmZXIgPSB0aGlzLl9nZXRFeGlmQnVmZmVyKCk7XG4gICAgdGhpcy5fZXhpZlN0cmVhbSA9IG5ldyBfYXJyYXlTdHJlYW0yWydkZWZhdWx0J10odGhpcy5fZXhpZkJ1ZmZlcik7XG4gICAgdGhpcy5fcGFyc2VFeGlmKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXhpZiwgW3tcbiAgICBrZXk6ICdnZXRUYWdzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGFncygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90YWdzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldFRhZ0RhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUYWdEYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RhZ0RhdGE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgdGhlIGV4aWYgdGFncyBpbnRvIHRoZSBnaXZlbiBkYXRhIHVybFxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0U3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXN0b3JlRXhpZlRhZ3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlRXhpZlRhZ3MoYmFzZTY0U3RyaW5nKSB7XG4gICAgICAvLyBGaXJzdCwgbWFrZSB0aGUgZ2l2ZW4gc3RyaW5nIGEgZGF0YSBhcnJheVxuICAgICAgdmFyIHJhdyA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKERBVEFfSlBFR19QUkVGSVgsICcnKTtcbiAgICAgIHZhciBkYXRhID0gX2Jhc2U2NDJbJ2RlZmF1bHQnXS5kZWNvZGUocmF3KTtcblxuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2xpY2VJbnRvU2VnbWVudHMoZGF0YSk7XG5cbiAgICAgIHZhciBfc2VnbWVudHMkMSA9IF9zbGljZWRUb0FycmF5KHNlZ21lbnRzWzFdLCAyKTtcblxuICAgICAgdmFyIHNlZ21lbnRTdGFydCA9IF9zZWdtZW50cyQxWzBdO1xuICAgICAgdmFyIHNlZ21lbnRFbmQgPSBfc2VnbWVudHMkMVsxXTtcblxuICAgICAgdmFyIGRhdGFCZWZvcmUgPSBkYXRhLnNsaWNlKDAsIHNlZ21lbnRTdGFydCk7XG4gICAgICB2YXIgZGF0YUFmdGVyID0gZGF0YS5zbGljZShzZWdtZW50U3RhcnQpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IGRhdGFCZWZvcmUuY29uY2F0KHRoaXMuX2V4aWZCdWZmZXIpO1xuICAgICAgbmV3RGF0YSA9IG5ld0RhdGEuY29uY2F0KGRhdGFBZnRlcik7XG5cbiAgICAgIC8vIE1ha2UgaXQgYSBiYXNlNjQgc3RyaW5nIGFnYWluXG4gICAgICByZXR1cm4gREFUQV9KUEVHX1BSRUZJWCArIF9iYXNlNjQyWydkZWZhdWx0J10uZW5jb2RlKG5ld0RhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJ3cml0ZXMgdGhlIG9yaWVudGF0aW9uIHdpdGggdGhlIGdpdmVuIDE2IGJpdCBpbnRlZ2VyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9yaWVudGF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXRPcmllbnRhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldE9yaWVudGF0aW9uKG9yaWVudGF0aW9uKSB7XG4gICAgICBpZiAodGhpcy5fdGFnRGF0YS5PcmllbnRhdGlvbikge1xuICAgICAgICB2YXIgZW50cnlPZmZzZXQgPSB0aGlzLl90YWdEYXRhLk9yaWVudGF0aW9uLmVudHJ5T2Zmc2V0O1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdmFsdWUgaW4gYnVmZmVyXG4gICAgICAgIHRoaXMuX2V4aWZTdHJlYW0uc2V0SGVhZChlbnRyeU9mZnNldCArIDgpO1xuICAgICAgICB0aGlzLl9leGlmU3RyZWFtLndyaXRlSW50MTYob3JpZW50YXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSB1cmwgaXMgYSBqcGVnIGltYWdlXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSAgYmFzZTY0U3RyaW5nXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19wYXJzZUV4aWYnLFxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRoZSBleGlmIHRhZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlRXhpZigpIHtcbiAgICAgIHRoaXMuX2V4aWZTdHJlYW0uc2V0SGVhZCgwKTtcbiAgICAgIC8vIFNraXAgbWFya2VyXG4gICAgICB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpO1xuICAgICAgLy8gU2tpcCBsZW5ndGhcbiAgICAgIHRoaXMuX2V4aWZTdHJlYW0ucmVhZEludDE2KCk7XG5cbiAgICAgIHZhciBoZWFkZXIgPSB0aGlzLl9leGlmU3RyZWFtLnJlYWRTdHJpbmcoNCk7XG4gICAgICBpZiAoaGVhZGVyICE9PSAnRXhpZicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIDIgYnl0ZXNcbiAgICAgIHRoaXMuX2V4aWZTdHJlYW0ucmVhZEludDE2KCk7XG5cbiAgICAgIHZhciB0aWZmT2Zmc2V0ID0gdGhpcy5fZXhpZlN0cmVhbS5nZXRIZWFkKCk7XG5cbiAgICAgIC8vIEZpbmQgZW5kaWFuIHR5cGVcbiAgICAgIHZhciBiaWdFbmRpYW4gPSBmYWxzZTtcbiAgICAgIHZhciBlbmRpYW4gPSB0aGlzLl9leGlmU3RyZWFtLnJlYWRJbnQxNigpO1xuICAgICAgaWYgKGVuZGlhbiA9PT0gMHg0OTQ5KSB7XG4gICAgICAgIGJpZ0VuZGlhbiA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChlbmRpYW4gPT09IDB4NGQ0ZCkge1xuICAgICAgICBiaWdFbmRpYW4gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFRJRkYgZGF0YTogTm8gZW5kaWFuIHR5cGUgZm91bmQnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2V4aWZTdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pICE9PSAweDAwMkEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFRJRkYgZGF0YTogTm8gMHgwMDJBJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdElGRE9mZnNldCA9IHRoaXMuX2V4aWZTdHJlYW0ucmVhZEludDMyKCFiaWdFbmRpYW4pO1xuICAgICAgaWYgKGZpcnN0SUZET2Zmc2V0IDwgOCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgVElGRiBkYXRhOiBGaXJzdCBJRkQgb2Zmc2V0IDwgOCcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZkT2Zmc2V0ID0gdGlmZk9mZnNldCArIGZpcnN0SUZET2Zmc2V0O1xuICAgICAgdmFyIHRhZ3MgPSB0aGlzLl9yZWFkVGFncyh0aGlzLl9leGlmU3RyZWFtLCB0aWZmT2Zmc2V0LCBpZmRPZmZzZXQsIGJpZ0VuZGlhbik7XG4gICAgICB0aGlzLl90YWdzID0gdGFncy50YWdzO1xuICAgICAgdGhpcy5fdGFnRGF0YSA9IHRhZ3MudGFnRGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkcyB0aGUgVElGRiB0YWdzIGZyb20gdGhlIHN0cmVhbVxuICAgICAqIEBwYXJhbSAge0FycmF5QnVmZmVyfSBzdHJlYW1cbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHRpZmZTdGFydCBUaGUgcG9zaXRpb24gd2hlcmUgdGlmZiBkYXRhIHN0YXJ0c1xuICAgICAqIEBwYXJhbSAge051bWJlcn0gaWZkU3RhcnQgIFRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgSUZEIHN0YXJ0c1xuICAgICAqIEBwYXJhbSAge0Jvb2xlYW59IGJpZ0VuZGlhblxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlYWRUYWdzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlYWRUYWdzKHN0cmVhbSwgdGlmZlN0YXJ0LCBpZmRTdGFydCwgYmlnRW5kaWFuKSB7XG4gICAgICBzdHJlYW0uc2V0SGVhZChpZmRTdGFydCk7XG4gICAgICB2YXIgZW50cmllc0NvdW50ID0gc3RyZWFtLnJlYWRJbnQxNighYmlnRW5kaWFuKTtcbiAgICAgIHZhciB0YWdzID0ge307XG4gICAgICB2YXIgdGFnRGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVudHJpZXNDb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeU9mZnNldCA9IGlmZFN0YXJ0ICsgaSAqIDEyICsgMjtcbiAgICAgICAgc3RyZWFtLnNldEhlYWQoZW50cnlPZmZzZXQpO1xuICAgICAgICB2YXIgdGFnID0gc3RyZWFtLnJlYWRJbnQxNighYmlnRW5kaWFuKTtcbiAgICAgICAgdmFyIHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBudW1WYWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciB2YWx1ZU9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKEVYSUZfVEFHU1t0YWddKSB7XG4gICAgICAgICAgdGFnID0gRVhJRl9UQUdTW3RhZ107XG4gICAgICAgICAgdHlwZSA9IHN0cmVhbS5yZWFkSW50MTYoIWJpZ0VuZGlhbik7XG4gICAgICAgICAgbnVtVmFsdWVzID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKTtcbiAgICAgICAgICB2YWx1ZU9mZnNldCA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbikgKyB0aWZmU3RhcnQ7XG4gICAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcblxuICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAxOiAvLyBieXRlLCA4LWJpdCB1bnNpZ25lZCBpbnRcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgLy8gdW5kZWZpbmVkLCA4LWJpdCBieXRlLCB2YWx1ZSBkZXBlbmRpbmcgb24gZmllbGRcbiAgICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRJbnQ4KCFiaWdFbmRpYW4pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG51bVZhbHVlczsgX2krKykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDgoIWJpZ0VuZGlhbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgLy8gOC1iaXQgYXNjaWkgY2hhclxuICAgICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiA0ID8gdmFsdWVPZmZzZXQgOiBlbnRyeU9mZnNldCArIDgpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmVhbS5yZWFkU3RyaW5nKG51bVZhbHVlcyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAvLyBzaG9ydFxuICAgICAgICAgICAgICBzdHJlYW0uc2V0SGVhZChudW1WYWx1ZXMgPiAyID8gdmFsdWVPZmZzZXQgOiBlbnRyeU9mZnNldCArIDgpO1xuICAgICAgICAgICAgICBpZiAobnVtVmFsdWVzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbnVtVmFsdWVzOyBfaTIrKykge1xuICAgICAgICAgICAgICAgICAgdmFsdWUucHVzaChzdHJlYW0ucmVhZEludDE2KCFiaWdFbmRpYW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDQ6IC8vIGxvbmdcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgLy8gc2xvbmdcbiAgICAgICAgICAgICAgc3RyZWFtLnNldEhlYWQobnVtVmFsdWVzID4gMSA/IHZhbHVlT2Zmc2V0IDogZW50cnlPZmZzZXQgKyA4KTtcbiAgICAgICAgICAgICAgaWYgKG51bVZhbHVlcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IG51bVZhbHVlczsgX2kzKyspIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlLnB1c2goc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA1OiAvLyByYXRpb25hbCAodHdvIGxvbmcgdmFsdWVzLCBmaXJzdCBudW1lcmF0b3IsIHNlY29uZCBkZW5vbWluYXRvcilcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIC8vIHJhdGlvbmFsICh0d28gc2xvbmdzKVxuICAgICAgICAgICAgICBzdHJlYW0uc2V0SGVhZCh2YWx1ZU9mZnNldCk7XG4gICAgICAgICAgICAgIGlmIChudW1WYWx1ZXMgPT09IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKTtcbiAgICAgICAgICAgICAgICB2YXIgZGVub21pbmF0b3IgPSBzdHJlYW0ucmVhZEludDMyKCFiaWdFbmRpYW4pO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwOyBfaTQgPCBudW1WYWx1ZXM7IF9pNCsrKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgbnVtZXJhdG9yID0gc3RyZWFtLnJlYWRJbnQzMighYmlnRW5kaWFuKTtcbiAgICAgICAgICAgICAgICAgIHZhciBkZW5vbWluYXRvciA9IHN0cmVhbS5yZWFkSW50MzIoIWJpZ0VuZGlhbik7XG4gICAgICAgICAgICAgICAgICB2YXIgdmFsID0gbnVtZXJhdG9yIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAgICAgICB2YWx1ZS5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRhZ3NbdGFnXSA9IHZhbHVlO1xuICAgICAgICAgIHRhZ0RhdGFbdGFnXSA9IHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG51bVZhbHVlczogbnVtVmFsdWVzLFxuICAgICAgICAgICAgZW50cnlPZmZzZXQ6IGVudHJ5T2Zmc2V0LFxuICAgICAgICAgICAgdmFsdWVPZmZzZXQ6IHZhbHVlT2Zmc2V0LFxuICAgICAgICAgICAgdHlwZTogdHlwZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgdGFnczogdGFncywgdGFnRGF0YTogdGFnRGF0YSB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgYnVmZmVyIGNvbnRhaW5pbmcgdGhlIEV4aWYgc2VnbWVudFxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0RXhpZkJ1ZmZlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRFeGlmQnVmZmVyKCkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfc2VnbWVudHMkaSA9IF9zbGljZWRUb0FycmF5KHNlZ21lbnRzW2ldLCAyKTtcblxuICAgICAgICB2YXIgb2Zmc2V0ID0gX3NlZ21lbnRzJGlbMF07XG4gICAgICAgIHZhciBlbmQgPSBfc2VnbWVudHMkaVsxXTtcblxuICAgICAgICB0aGlzLl9zdHJlYW0uc2V0SGVhZChvZmZzZXQpO1xuICAgICAgICB2YXIgbWFya2VyID0gdGhpcy5fc3RyZWFtLnBlZWtJbnQxNigpO1xuICAgICAgICBpZiAobWFya2VyID09PSAweGZmZTEpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fYnVmLnNsaWNlKG9mZnNldCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNsaWNlcyB0aGUgYXJyYXkgaW50byBzZWdtZW50c1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxOdW1iZXI+fSBidWZcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NsaWNlSW50b1NlZ21lbnRzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NsaWNlSW50b1NlZ21lbnRzKGJ1Zikge1xuICAgICAgdmFyIHN0cmVhbSA9IG5ldyBfYXJyYXlTdHJlYW0yWydkZWZhdWx0J10oYnVmKTtcbiAgICAgIHZhciBzZWdtZW50cyA9IFtdO1xuICAgICAgd2hpbGUgKHN0cmVhbS5nZXRIZWFkKCkgPCBidWYubGVuZ3RoKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBzdHJlYW0ucmVhZEludDE2KCk7XG4gICAgICAgIGlmIChtYXJrZXIgPT09IDB4ZmZkOCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNPSVxuICAgICAgICBpZiAobWFya2VyID09PSAweGZmZGEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBTT1MgTWFya2VyXG5cbiAgICAgICAgaWYgKG1hcmtlciA+PSAweGZmMDAgJiYgbWFya2VyIDw9IDB4ZmZmZikge1xuICAgICAgICAgIC8vIE1hcmtlciAoRkYtWFgtSEwtTEwpXG4gICAgICAgICAgdmFyIF9sZW5ndGggPSBzdHJlYW0ucmVhZEludDE2KCk7XG4gICAgICAgICAgdmFyIGVuZCA9IHN0cmVhbS5nZXRIZWFkKCkgKyBfbGVuZ3RoIC0gMjtcbiAgICAgICAgICBzZWdtZW50cy5wdXNoKFtzdHJlYW0uZ2V0SGVhZCgpIC0gNCwgZW5kXSk7XG4gICAgICAgICAgc3RyZWFtLnNldEhlYWQoZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbWFya2VyOiAweCcgKyBtYXJrZXIudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdHJlYW0uc2V0SGVhZCgwKTtcblxuICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc3Bvc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwb3NlKCkge1xuICAgICAgdGhpcy5fYnVmID0gW107XG4gICAgICB0aGlzLl9leGlmQnVmZmVyID0gW107XG4gICAgICB0aGlzLl9zZWdtZW50cyA9IFtdO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaXNKUEVHJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNKUEVHKGJhc2U2NFN0cmluZykge1xuICAgICAgcmV0dXJuIEpQRUdfUkVHRVgudGVzdChiYXNlNjRTdHJpbmcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRXhpZiBmcm9tIHRoZSBnaXZlbiBiYXNlNjQtZW5jb2RlZFxuICAgICAqIHN0cmluZ1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gYmFzZTY0U3RyaW5nXG4gICAgICogQHJldHVybiB7RXhpZn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Zyb21CYXNlNjRTdHJpbmcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQmFzZTY0U3RyaW5nKGJhc2U2NFN0cmluZykge1xuICAgICAgdmFyIHJhdyA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKERBVEFfSlBFR19QUkVGSVgsICcnKTtcbiAgICAgIHZhciBkYXRhID0gX2Jhc2U2NDJbJ2RlZmF1bHQnXS5kZWNvZGUocmF3KTtcbiAgICAgIHJldHVybiBuZXcgRXhpZihkYXRhKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRXhpZjtcbn0pKCk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEV4aWY7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2V4aWYuanNcbiAqKiBtb2R1bGUgaWQgPSAxOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgQXJyYXlTdHJlYW0gPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBcnJheVN0cmVhbShidWYpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXJyYXlTdHJlYW0pO1xuXG4gICAgdGhpcy5faGVhZCA9IDA7XG4gICAgdGhpcy5fYnVmID0gYnVmO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFycmF5U3RyZWFtLCBbe1xuICAgIGtleTogJ2dldEhlYWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRIZWFkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0SGVhZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhlYWQoaGVhZCkge1xuICAgICAgdGhpcy5faGVhZCA9IGhlYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGVla0ludDgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrSW50OCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9idWZbdGhpcy5faGVhZF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAncGVla0ludDE2JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGVla0ludDE2KCkge1xuICAgICAgdmFyIGxpdHRsZUVuZGlhbiA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IGZhbHNlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB2YXIgYSA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkXTtcbiAgICAgIHZhciBiID0gdGhpcy5fYnVmW3RoaXMuX2hlYWQgKyAxXTtcbiAgICAgIGlmICghbGl0dGxlRW5kaWFuKSB7XG4gICAgICAgIHJldHVybiAoYSA8PCA4KSArIGI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKGIgPDwgOCkgKyBhO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3BlZWtJbnQyNCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlZWtJbnQyNCgpIHtcbiAgICAgIHZhciBsaXR0bGVFbmRpYW4gPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IGFyZ3VtZW50c1swXTtcblxuICAgICAgdmFyIGEgPSB0aGlzLl9idWZbdGhpcy5faGVhZF07XG4gICAgICB2YXIgYiA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV07XG4gICAgICB2YXIgYyA9IHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMl07XG4gICAgICBpZiAoIWxpdHRsZUVuZGlhbikge1xuICAgICAgICByZXR1cm4gKGEgPDwgMTYpICsgKGIgPDwgOCkgKyBjO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChjIDw8IDE2KSArIChiIDw8IDgpICsgYTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdwZWVrSW50MzInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwZWVrSW50MzIoKSB7XG4gICAgICB2YXIgbGl0dGxlRW5kaWFuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBhID0gdGhpcy5fYnVmW3RoaXMuX2hlYWRdO1xuICAgICAgdmFyIGIgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDFdO1xuICAgICAgdmFyIGMgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDJdO1xuICAgICAgdmFyIGQgPSB0aGlzLl9idWZbdGhpcy5faGVhZCArIDNdO1xuICAgICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgICAgcmV0dXJuIChhIDw8IDMyKSArIChiIDw8IDE2KSArIChjIDw8IDgpICsgZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoZCA8PCAzMikgKyAoYyA8PCAxNikgKyAoYiA8PCA4KSArIGE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnd3JpdGVJbnQxNicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdyaXRlSW50MTYobnVtKSB7XG4gICAgICB0aGlzLl9idWZbdGhpcy5faGVhZF0gPSBudW0gPj4gODsgLy8gdXBwZXJcbiAgICAgIHRoaXMuX2J1Zlt0aGlzLl9oZWFkICsgMV0gPSBudW0gJiAweGZmOyAvLyBsb3dlclxuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3JlYWRJbnQ4JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZEludDgoKSB7XG4gICAgICB2YXIgbnVtID0gdGhpcy5wZWVrSW50OCgpO1xuICAgICAgdGhpcy5faGVhZCArPSAxO1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkSW50MTYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MTYoKSB7XG4gICAgICB2YXIgbGl0dGxlRW5kaWFuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBudW0gPSB0aGlzLnBlZWtJbnQxNihsaXR0bGVFbmRpYW4pO1xuICAgICAgdGhpcy5faGVhZCArPSAyO1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkSW50MjQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MjQoKSB7XG4gICAgICB2YXIgbGl0dGxlRW5kaWFuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBudW0gPSB0aGlzLnBlZWtJbnQyNChsaXR0bGVFbmRpYW4pO1xuICAgICAgdGhpcy5faGVhZCArPSAzO1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkSW50MzInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWFkSW50MzIoKSB7XG4gICAgICB2YXIgbGl0dGxlRW5kaWFuID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBudW0gPSB0aGlzLnBlZWtJbnQzMihsaXR0bGVFbmRpYW4pO1xuICAgICAgdGhpcy5faGVhZCArPSA0O1xuICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdyZWFkU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhZFN0cmluZyhsZW5ndGgpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoYXJhY3RlciA9IHRoaXMucmVhZEludDgoKTtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhcmFjdGVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFycmF5U3RyZWFtO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQXJyYXlTdHJlYW07XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2FycmF5LXN0cmVhbS5qc1xuICoqIG1vZHVsZSBpZCA9IDE5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBWRVJTSU9OX0NIRUNLX0ZOID0gJ2ltZ2x5U0RLVmVyc2lvbkNhbGxiYWNrJztcbnZhciBWRVJTSU9OX0NIRUNLX1VSTCA9ICdodHRwczovL3d3dy5waG90b2VkaXRvcnNkay5jb20vdmVyc2lvbi5qc29uP3Nkaz1odG1sNSZqc29uY2FsbGJhY2s9JyArIFZFUlNJT05fQ0hFQ0tfRk47XG5cbnZhciBWZXJzaW9uQ2hlY2tlciA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlcnNpb25DaGVja2VyKHZlcnNpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVyc2lvbkNoZWNrZXIpO1xuXG4gICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgdGhpcy5fY2hlY2soKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyB2ZXJzaW9uIG9mIHRoZSBTREsgaXMgb3V0ZGF0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFZlcnNpb25DaGVja2VyLCBbe1xuICAgIGtleTogJ19jaGVjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVjaygpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHdpbmRvd1tWRVJTSU9OX0NIRUNLX0ZOXSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAocmVzcG9uc2Uub3V0ZGF0ZWQpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2ltZ2x5LXNkay1odG1sNTogWW91ciB2ZXJzaW9uICcgKyBzZWxmLl92ZXJzaW9uICsgJyBpcyBvdXRkYXRlZC4nKTtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2ltZ2x5LXNkay1odG1sNTogQ3VycmVudCB2ZXJzaW9uIGlzICcgKyByZXNwb25zZS52ZXJzaW9uICsgJy4nKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgc2NyaXB0LnNyYyA9IFZFUlNJT05fQ0hFQ0tfVVJMICsgJyZ2ZXJzaW9uPScgKyB0aGlzLl92ZXJzaW9uO1xuICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVmVyc2lvbkNoZWNrZXI7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBWZXJzaW9uQ2hlY2tlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9saWIvdmVyc2lvbi1jaGVja2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfb3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcblxudmFyIF9vcGVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BlcmF0aW9uKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGNyb3Agb3V0IGEgcGFydCBvZiB0aGUgaW1hZ2UgYW5kIHJvdGF0ZXMgaXRcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlJvdGF0aW9uT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuXG52YXIgUm90YXRpb25PcGVyYXRpb24gPSAoZnVuY3Rpb24gKF9PcGVyYXRpb24pIHtcbiAgX2luaGVyaXRzKFJvdGF0aW9uT3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBSb3RhdGlvbk9wZXJhdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUm90YXRpb25PcGVyYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUm90YXRpb25PcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy52ZXJ0ZXhTaGFkZXIgPSAnXFxuICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uLCAxKSkueHksIDAsIDEpO1xcbiAgICAgICAgdl90ZXhDb29yZCA9IGFfdGV4Q29vcmQ7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICAvKipcbiAgICogUm90YXRlcyB0aGUgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgX2NyZWF0ZUNsYXNzKFJvdGF0aW9uT3BlcmF0aW9uLCBbe1xuICAgIGtleTogJ19yZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgdmFyIGFjdHVhbERlZ3JlZXMgPSB0aGlzLl9vcHRpb25zLmRlZ3JlZXMgJSAzNjA7XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICAgIHZhciByYWRpYW5zID0gYWN0dWFsRGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKTtcbiAgICAgIHZhciBjID0gTWF0aC5jb3MocmFkaWFucyk7XG4gICAgICB2YXIgcyA9IE1hdGguc2luKHJhZGlhbnMpO1xuICAgICAgdmFyIHJvdGF0aW9uTWF0cml4ID0gW2MsIC1zLCAwLCBzLCBjLCAwLCAwLCAwLCAxXTtcblxuICAgICAgLy8gUnVuIHRoZSBzaGFkZXJcbiAgICAgIHJlbmRlcmVyLnJ1blNoYWRlcih0aGlzLnZlcnRleFNoYWRlciwgbnVsbCwge1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVfbWF0cml4OiB7IHR5cGU6ICdtYXQzZnYnLCB2YWx1ZTogcm90YXRpb25NYXRyaXggfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG5cbiAgICAgIHZhciBhY3R1YWxEZWdyZWVzID0gdGhpcy5fb3B0aW9ucy5kZWdyZWVzICUgMzYwO1xuICAgICAgdmFyIG5ld0RpbWVuc2lvbnMgPSB0aGlzLmdldE5ld0RpbWVuc2lvbnMocmVuZGVyZXIpO1xuXG4gICAgICAvLyBDcmVhdGUgYSByb3RhdGVkIGNhbnZhc1xuICAgICAgdmFyIG5ld0NhbnZhcyA9IHJlbmRlcmVyLmNyZWF0ZUNhbnZhcygpO1xuICAgICAgbmV3Q2FudmFzLndpZHRoID0gbmV3RGltZW5zaW9ucy54O1xuICAgICAgbmV3Q2FudmFzLmhlaWdodCA9IG5ld0RpbWVuc2lvbnMueTtcbiAgICAgIHZhciBuZXdDb250ZXh0ID0gbmV3Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIG5ld0NvbnRleHQuc2F2ZSgpO1xuXG4gICAgICAvLyBUcmFuc2xhdGUgdGhlIGNhbnZhc1xuICAgICAgbmV3Q29udGV4dC50cmFuc2xhdGUobmV3Q2FudmFzLndpZHRoIC8gMiwgbmV3Q2FudmFzLmhlaWdodCAvIDIpO1xuXG4gICAgICAvLyBSb3RhdGUgdGhlIGNhbnZhc1xuICAgICAgbmV3Q29udGV4dC5yb3RhdGUoYWN0dWFsRGVncmVlcyAqIChNYXRoLlBJIC8gMTgwKSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBjYW52YXMgc28gdGhhdCB3ZSBjYW4gZHJhdyB0aGUgaW1hZ2VcbiAgICAgIC8vIHdpdGggdGhlIGFwcGxpZWQgdHJhbnNmb3JtYXRpb25cbiAgICAgIHZhciB0ZW1wQ2FudmFzID0gcmVuZGVyZXIuY2xvbmVDYW52YXMoKTtcbiAgICAgIG5ld0NvbnRleHQuZHJhd0ltYWdlKHRlbXBDYW52YXMsIC1jYW52YXMud2lkdGggLyAyLCAtY2FudmFzLmhlaWdodCAvIDIpO1xuXG4gICAgICAvLyBSZXN0b3JlIG9sZCB0cmFuc2Zvcm1hdGlvblxuICAgICAgbmV3Q29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAgIHJlbmRlcmVyLnNldENhbnZhcyhuZXdDYW52YXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5ldyBkaW1lbnNpb25zXG4gICAgICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtkaW1lbnNpb25zXVxuICAgICAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXROZXdEaW1lbnNpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV3RGltZW5zaW9ucyhyZW5kZXJlciwgZGltZW5zaW9ucykge1xuICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgcmVuZGVyZXIuZ2V0U2l6ZSgpO1xuXG4gICAgICB2YXIgYWN0dWFsRGVncmVlcyA9IHRoaXMuX29wdGlvbnMuZGVncmVlcyAlIDM2MDtcbiAgICAgIGlmIChhY3R1YWxEZWdyZWVzICUgMTgwICE9PSAwKSB7XG4gICAgICAgIGRpbWVuc2lvbnMuZmxpcCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUm90YXRpb25PcGVyYXRpb247XG59KShfb3BlcmF0aW9uMlsnZGVmYXVsdCddKTtcblxuUm90YXRpb25PcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXIgPSAncm90YXRpb24nO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5Sb3RhdGlvbk9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgZGVncmVlczogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAwLCB2YWxpZGF0aW9uOiBmdW5jdGlvbiB2YWxpZGF0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJSA5MCAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JvdGF0aW9uT3BlcmF0aW9uOiBgcm90YXRpb25gIGhhcyB0byBiZSBhIG11bHRpcGxlIG9mIDkwLicpO1xuICAgICAgfVxuICAgIH0gfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUm90YXRpb25PcGVyYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9yb3RhdGlvbi1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoganNoaW50IHVudXNlZDpmYWxzZSAqL1xuLyoganNoaW50IC1XMDgzICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gyLCBfeDMsIF94NCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDIsIHByb3BlcnR5ID0gX3gzLCByZWNlaXZlciA9IF94NDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDIgPSBwYXJlbnQ7IF94MyA9IHByb3BlcnR5OyBfeDQgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi9saWIvZXZlbnQtZW1pdHRlcicpO1xuXG52YXIgX2xpYkV2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJFdmVudEVtaXR0ZXIpO1xuXG52YXIgX3ZlbmRvclByb21pc2UgPSByZXF1aXJlKCcuLi92ZW5kb3IvcHJvbWlzZScpO1xuXG52YXIgX3ZlbmRvclByb21pc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdmVuZG9yUHJvbWlzZSk7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgT3BlcmF0aW9ucy4gRXh0ZW5kYWJsZSB2aWEge0BsaW5rIEltZ2x5S2l0Lk9wZXJhdGlvbiNleHRlbmR9LlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cblxuLyoqXG4gKiBUbyBjcmVhdGUgYW4ge0BsaW5rIEltZ2x5S2l0Lk9wZXJhdGlvbn0gY2xhc3Mgb2YgeW91ciBvd24sIGNhbGwgdGhpc1xuICogbWV0aG9kIGFuZCBwcm92aWRlIGluc3RhbmNlIHByb3BlcnRpZXMgYW5kIGZ1bmN0aW9ucy5cbiAqIEBmdW5jdGlvblxuICovXG5cbnZhciBfbGliRXh0ZW5kID0gcmVxdWlyZSgnLi4vbGliL2V4dGVuZCcpO1xuXG52YXIgX2xpYkV4dGVuZDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJFeHRlbmQpO1xuXG52YXIgT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhPcGVyYXRpb24sIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIE9wZXJhdGlvbihraXQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3BlcmF0aW9uKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE9wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fa2l0ID0ga2l0O1xuICAgIHRoaXMuYXZhaWxhYmxlT3B0aW9ucyA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5leHRlbmQodGhpcy5hdmFpbGFibGVPcHRpb25zIHx8IHt9LCB7XG4gICAgICBudW1iZXJGb3JtYXQ6IHsgdHlwZTogJ3N0cmluZycsICdkZWZhdWx0JzogJ3JlbGF0aXZlJywgYXZhaWxhYmxlOiBbJ2Fic29sdXRlJywgJ3JlbGF0aXZlJ10gfVxuICAgIH0pO1xuICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblxuICAgIHRoaXMuX2dsc2xQcm9ncmFtcyA9IHt9O1xuICAgIHRoaXMuX3V1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAxNiB8IDA7XG4gICAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5faW5pdE9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIE9wZXJhdGlvbiBjYW4gYmUgYXBwbGllZCB0aGUgd2F5IGl0IGlzIGNvbmZpZ3VyZWRcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKE9wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICd2YWxpZGF0ZVNldHRpbmdzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGVTZXR0aW5ncygpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gdGhpcy5pZGVudGlmaWVyO1xuICAgICAgcmV0dXJuIG5ldyBfdmVuZG9yUHJvbWlzZTJbJ2RlZmF1bHQnXShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciByZXF1aXJlZCBvcHRpb25zXG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gX3RoaXMuYXZhaWxhYmxlT3B0aW9ucykge1xuICAgICAgICAgIHZhciBvcHRpb25Db25maWcgPSBfdGhpcy5hdmFpbGFibGVPcHRpb25zW29wdGlvbk5hbWVdO1xuICAgICAgICAgIGlmIChvcHRpb25Db25maWcucmVxdWlyZWQgJiYgdHlwZW9mIF90aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgRXJyb3IoJ09wZXJhdGlvbiBgJyArIGlkZW50aWZpZXIgKyAnYDogT3B0aW9uIGAnICsgb3B0aW9uTmFtZSArICdgIGlzIHJlcXVpcmVkLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHJlbmRlckZuID0gdW5kZWZpbmVkO1xuICAgICAgaWYgKHJlbmRlcmVyLmlkZW50aWZpZXIgPT09ICd3ZWJnbCcpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmVuZGVyRm4gPSB0aGlzLl9yZW5kZXJXZWJHTC5iaW5kKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyRm4gPSB0aGlzLl9yZW5kZXJDYW52YXMuYmluZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgLy8gSGFuZGxlIGNhY2hpbmdcbiAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICByZW5kZXJGbihyZW5kZXJlcik7XG4gICAgICAgIHJlbmRlcmVyLmNhY2hlKHRoaXMuX3V1aWQpO1xuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuZHJhd0NhY2hlZCh0aGlzLl91dWlkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHRoaXMgb3BlcmF0aW9uIHVzaW5nIFdlYkdMXG4gICAgICogQHJldHVybiB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0woKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiNfcmVuZGVyV2ViR0wgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGlzIG9wZXJhdGlvbiB1c2luZyBDYW52YXMyRFxuICAgICAqIEByZXR1cm4ge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhcygpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uI19yZW5kZXJDYW52YXMgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR29lcyB0aHJvdWdoIHRoZSBhdmFpbGFibGUgb3B0aW9ucywgc2V0cyBfb3B0aW9ucyBkZWZhdWx0c1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB1c2VyT3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaW5pdE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdE9wdGlvbnModXNlck9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX29wdGlvbnMgPSB7fTtcblxuICAgICAgLy8gU2V0IGRlZmF1bHRzLCBjcmVhdGUgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgICAgdmFyIG9wdGlvbk5hbWUsIG9wdGlvbiwgY2FwaXRhbGl6ZWQ7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gdGhpcy5hdmFpbGFibGVPcHRpb25zKSB7XG4gICAgICAgIGNhcGl0YWxpemVkID0gb3B0aW9uTmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdGlvbk5hbWUuc2xpY2UoMSk7XG4gICAgICAgIG9wdGlvbiA9IHRoaXMuYXZhaWxhYmxlT3B0aW9uc1tvcHRpb25OYW1lXTtcblxuICAgICAgICAvLyBDcmVhdGUgc2V0dGVyIGFuZCBnZXR0ZXJcbiAgICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4ob3B0aW9uTmFtZSwgb3B0aW9uKSB7XG4gICAgICAgICAgc2VsZlsnc2V0JyArIGNhcGl0YWxpemVkXSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgc2VsZi5fc2V0T3B0aW9uKG9wdGlvbk5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gRGVmYXVsdCBnZXR0ZXJcbiAgICAgICAgICBzZWxmWydnZXQnICsgY2FwaXRhbGl6ZWRdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2dldE9wdGlvbihvcHRpb25OYW1lKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBmbihvcHRpb25OYW1lLCBvcHRpb24pO1xuXG4gICAgICAgIC8vIFNldCBkZWZhdWx0IGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvblsnZGVmYXVsdCddICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRoaXNbJ3NldCcgKyBjYXBpdGFsaXplZF0ob3B0aW9uWydkZWZhdWx0J10pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJ3cml0ZSBvcHRpb25zIHdpdGggdGhlIG9uZXMgZ2l2ZW4gYnkgdXNlclxuICAgICAgZm9yIChvcHRpb25OYW1lIGluIHVzZXJPcHRpb25zKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIG9wdGlvbiBpcyBhdmFpbGFibGVcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9wdGlvbjogJyArIG9wdGlvbk5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCBzZXR0ZXJcbiAgICAgICAgY2FwaXRhbGl6ZWQgPSBvcHRpb25OYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgb3B0aW9uTmFtZS5zbGljZSgxKTtcbiAgICAgICAgdGhpc1snc2V0JyArIGNhcGl0YWxpemVkXSh1c2VyT3B0aW9uc1tvcHRpb25OYW1lXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXQob3B0aW9ucykge1xuICAgICAgZm9yICh2YXIgb3B0aW9uTmFtZSBpbiBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX3NldE9wdGlvbihvcHRpb25OYW1lLCBvcHRpb25zW29wdGlvbk5hbWVdLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBvcHRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19nZXRPcHRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0T3B0aW9uKG9wdGlvbk5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gb3B0aW9uLCB2YWxpZGF0ZXMgaXRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9uTmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHVwZGF0ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0T3B0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE9wdGlvbihvcHRpb25OYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIHVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHZhciBvcHRpb25Db25maWcgPSB0aGlzLmF2YWlsYWJsZU9wdGlvbnNbb3B0aW9uTmFtZV07XG4gICAgICB2YXIgaWRlbnRpZmllciA9IHRoaXMuaWRlbnRpZmllcjtcblxuICAgICAgaWYgKHR5cGVvZiBvcHRpb25Db25maWcuc2V0dGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbkNvbmZpZy5zZXR0ZXIuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uQ29uZmlnLnZhbGlkYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIG9wdGlvbkNvbmZpZy52YWxpZGF0aW9uKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChvcHRpb25Db25maWcudHlwZSkge1xuICAgICAgICAvLyBTdHJpbmcgb3B0aW9uc1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBgJyArIGlkZW50aWZpZXIgKyAnYDogT3B0aW9uIGAnICsgb3B0aW9uTmFtZSArICdgIGhhcyB0byBiZSBhIHN0cmluZy4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTdHJpbmcgdmFsdWUgcmVzdHJpY3Rpb25zXG4gICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IG9wdGlvbkNvbmZpZy5hdmFpbGFibGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBhdmFpbGFibGUgIT09ICd1bmRlZmluZWQnICYmIGF2YWlsYWJsZS5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGAnICsgaWRlbnRpZmllciArICdgOiBJbnZhbGlkIHZhbHVlIGZvciBgJyArIG9wdGlvbk5hbWUgKyAnYCAodmFsaWQgdmFsdWVzIGFyZTogJyArIG9wdGlvbkNvbmZpZy5hdmFpbGFibGUuam9pbignLCAnKSArICcpJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIE51bWJlciBvcHRpb25zXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGAnICsgaWRlbnRpZmllciArICdgOiBPcHRpb24gYCcgKyBvcHRpb25OYW1lICsgJ2AgaGFzIHRvIGJlIGEgbnVtYmVyLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBCb29sZWFuIG9wdGlvbnNcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wZXJhdGlvbiBgJyArIGlkZW50aWZpZXIgKyAnYDogT3B0aW9uIGAnICsgb3B0aW9uTmFtZSArICdgIGhhcyB0byBiZSBhIGJvb2xlYW4uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIC8vIFZlY3RvcjIgb3B0aW9uc1xuICAgICAgICBjYXNlICd2ZWN0b3IyJzpcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGAnICsgaWRlbnRpZmllciArICdgOiBPcHRpb24gYCcgKyBvcHRpb25OYW1lICsgJ2AgaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIEltZ2x5S2l0LlZlY3RvcjIuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fb3B0aW9uc1tvcHRpb25OYW1lXSA9IHZhbHVlLmNsb25lKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBDb2xvciBvcHRpb25zXG4gICAgICAgIGNhc2UgJ2NvbG9yJzpcbiAgICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIF9saWJDb2xvcjJbJ2RlZmF1bHQnXSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignT3BlcmF0aW9uIGAnICsgaWRlbnRpZmllciArICdgOiBPcHRpb24gYCcgKyBvcHRpb25OYW1lICsgJ2AgaGFzIHRvIGJlIGFuIGluc3RhbmNlIG9mIEltZ2x5S2l0LkNvbG9yLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBPYmplY3Qgb3B0aW9uc1xuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIHRoaXMuX29wdGlvbnNbb3B0aW9uTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICAvLyBBcnJheSBvcHRpb25zXG4gICAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgICAgICB0aGlzLl9vcHRpb25zW29wdGlvbk5hbWVdID0gdmFsdWUuc2xpY2UoMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmICh1cGRhdGUpIHtcbiAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtWZWN0b3IyfSBbZGltZW5zaW9uc11cbiAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXROZXdEaW1lbnNpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TmV3RGltZW5zaW9ucyhyZW5kZXJlciwgZGltZW5zaW9ucykge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMgfHwgbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICByZXR1cm4gZGltZW5zaW9ucztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgb3BlcmF0aW9uIGhhcyBiZWVuIG1hcmtlZCBhcyBkaXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRpcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGlydHkoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNldCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5fZ2xzbFByb2dyYW1zID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGlzIG9wZXJhdGlvbiB0byBkaXJ0eSwgc28gdGhhdCBpdCB3aWxsIHJlLXJlbmRlciBuZXh0IHRpbWVcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpcnR5ID0gdHJ1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGlydHknLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGRpcnR5KSB7XG4gICAgICB0aGlzLl9kaXJ0eSA9IGRpcnR5O1xuICAgICAgdGhpcy5fb25EaXJ0eSAmJiB0aGlzLl9vbkRpcnR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpcnR5IHN0YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGlydHk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9wZXJhdGlvbjtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5PcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXIgPSBudWxsO1xuT3BlcmF0aW9uLmV4dGVuZCA9IF9saWJFeHRlbmQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE9wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL29wZXJhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDIyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgY29sb3JcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkNvbG9yXG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogQHBhcmFtIHtOdW1iZXJ9IGdcbiAqIEBwYXJhbSB7TnVtYmVyfSBiXG4gKiBAcGFyYW0ge051bWJlcn0gW2FdXG4gKiBAcHJpdmF0ZVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIENvbG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29sb3IociwgZywgYiwgYSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvcik7XG5cbiAgICBpZiAodHlwZW9mIGEgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBhID0gMS4wO1xuICAgIH1cblxuICAgIHRoaXMuciA9IHI7XG4gICAgdGhpcy5nID0gZztcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYSA9IGE7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiByZ2JhKCkgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb2xvclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhDb2xvciwgW3tcbiAgICBrZXk6ICd0b1JHQkEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1JHQkEoKSB7XG4gICAgICB2YXIgY29sb3JzID0gW01hdGgucm91bmQodGhpcy5yICogMjU1KSwgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpLCBNYXRoLnJvdW5kKHRoaXMuYiAqIDI1NSksIHRoaXMuYV07XG4gICAgICByZXR1cm4gJ3JnYmEoJyArIGNvbG9ycy5qb2luKCcsJykgKyAnKSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndG9IZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hleCgpIHtcbiAgICAgIHZhciBjb21wb25lbnRzID0gW3RoaXMuX2NvbXBvbmVudFRvSGV4KE1hdGgucm91bmQodGhpcy5yICogMjU1KSksIHRoaXMuX2NvbXBvbmVudFRvSGV4KE1hdGgucm91bmQodGhpcy5nICogMjU1KSksIHRoaXMuX2NvbXBvbmVudFRvSGV4KE1hdGgucm91bmQodGhpcy5iICogMjU1KSldO1xuICAgICAgcmV0dXJuICcjJyArIGNvbXBvbmVudHMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSB3aXRoIDQgdmFsdWVzICgwLi4uMSlcbiAgICAgKiBAcmV0dXJuIHtBcnJheS48TnVtYmVyPn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3RvR0xDb2xvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvR0xDb2xvcigpIHtcbiAgICAgIHJldHVybiBbdGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IHdpdGggMyB2YWx1ZXMgKDAuLi4xKVxuICAgICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndG9SR0JHTENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9SR0JHTENvbG9yKCkge1xuICAgICAgcmV0dXJuIFt0aGlzLnIsIHRoaXMuZywgdGhpcy5iXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgUkdCIHZhbHVlIHRvIEhTVlxuICAgICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndG9IU1YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0hTVigpIHtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heCh0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbih0aGlzLnIsIHRoaXMuZywgdGhpcy5iKTtcbiAgICAgIHZhciBoID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIHMgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgdiA9IG1heDtcbiAgICAgIHZhciBkID0gbWF4IC0gbWluO1xuICAgICAgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuXG4gICAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgICAgaCA9IDA7IC8vIGFjaHJvbWF0aWNcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICAgIGNhc2UgdGhpcy5yOlxuICAgICAgICAgICAgICBoID0gKHRoaXMuZyAtIHRoaXMuYikgLyBkICsgKHRoaXMuZyA8IHRoaXMuYiA/IDYgOiAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuZzpcbiAgICAgICAgICAgICAgaCA9ICh0aGlzLmIgLSB0aGlzLnIpIC8gZCArIDI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSB0aGlzLmI6XG4gICAgICAgICAgICAgIGggPSAodGhpcy5yIC0gdGhpcy5nKSAvIGQgKyA0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaCAvPSA2O1xuICAgICAgICB9XG5cbiAgICAgIHJldHVybiBbaCwgcywgdl07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgUkdCIHZhbHVlcyBvZiB0aGlzIGNvbG9yIHRvIG1hdGNoIHRoZSBnaXZlbiBIU1YgdmFsdWVzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGhcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gc1xuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdmcm9tSFNWJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJvbUhTVihoLCBzLCB2KSB7XG4gICAgICB2YXIgciA9IHRoaXMucjtcbiAgICAgIHZhciBnID0gdGhpcy5nO1xuICAgICAgdmFyIGIgPSB0aGlzLmI7XG5cbiAgICAgIHZhciBpID0gTWF0aC5mbG9vcihoICogNik7XG4gICAgICB2YXIgZiA9IGggKiA2IC0gaTtcbiAgICAgIHZhciBwID0gdiAqICgxIC0gcyk7XG4gICAgICB2YXIgcSA9IHYgKiAoMSAtIGYgKiBzKTtcbiAgICAgIHZhciB0ID0gdiAqICgxIC0gKDEgLSBmKSAqIHMpO1xuXG4gICAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICByID0gdjtcbiAgICAgICAgICBnID0gdDtcbiAgICAgICAgICBiID0gcDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGcgPSB2O1xuICAgICAgICAgIGIgPSBwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgciA9IHA7XG4gICAgICAgICAgZyA9IHY7XG4gICAgICAgICAgYiA9IHQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByID0gcDtcbiAgICAgICAgICBnID0gcTtcbiAgICAgICAgICBiID0gdjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHIgPSB0O1xuICAgICAgICAgIGcgPSBwO1xuICAgICAgICAgIGIgPSB2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgciA9IHY7XG4gICAgICAgICAgZyA9IHA7XG4gICAgICAgICAgYiA9IHE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuciA9IHI7XG4gICAgICB0aGlzLmcgPSBnO1xuICAgICAgdGhpcy5iID0gYjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3JcbiAgICAgKiBAcmV0dXJuIHtDb2xvcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Nsb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZ2l2ZW4gbnVtYmVyIGFzIGhleFxuICAgICAqIEBwYXJhbSAge051bWJlcn0gY29tcG9uZW50XG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfY29tcG9uZW50VG9IZXgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcG9uZW50VG9IZXgoY29tcG9uZW50KSB7XG4gICAgICB2YXIgaGV4ID0gY29tcG9uZW50LnRvU3RyaW5nKDE2KTtcbiAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGNvbG9yXG4gICAgICogQHJldHVybnMge1N0cmluZ31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3RvU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gJ0NvbG9yKCcgKyB0aGlzLnIgKyAnLCAnICsgdGhpcy5nICsgJywgJyArIHRoaXMuYiArICcsICcgKyB0aGlzLmEgKyAnKSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbG9yO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ29sb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vbGliL2NvbG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMjNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb3JyZWN0bHkgc2V0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW5cbiAqIEJhc2VkIG9uIHRoZSBiYWNrYm9uZS5qcyBleHRlbmQgZnVuY3Rpb246XG4gKiBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL2JhY2tib25lL2Jsb2IvbWFzdGVyL2JhY2tib25lLmpzXG4gKiBAcGFyYW0gIHtPYmplY3R9IHByb3RvdHlwZVByb3BlcnRpZXNcbiAqIEBwYXJhbSAge09iamVjdH0gY2xhc3NQcm9wZXJ0aWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocHJvdG90eXBlUHJvcGVydGllcywgY2xhc3NQcm9wZXJ0aWVzKSB7XG4gIC8qanNoaW50IHZhbGlkdGhpczp0cnVlKi9cbiAgdmFyIHBhcmVudCA9IHRoaXM7XG4gIHZhciBjaGlsZDtcblxuICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gIC8vICh0aGUgJ2NvbnN0cnVjdG9yJyBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcbiAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuICBpZiAocHJvdG90eXBlUHJvcGVydGllcyAmJiBwcm90b3R5cGVQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpKSB7XG4gICAgY2hpbGQgPSBwcm90b3R5cGVQcm9wZXJ0aWVzLmNvbnN0cnVjdG9yO1xuICB9IGVsc2Uge1xuICAgIGNoaWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHBhcmVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICAvLyBBZGQgc3RhdGljIHByb3BlcnRpZXMgdG8gdGhlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCBpZiBzdXBwbGllZC5cbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgY2hpbGRba2V5XSA9IHBhcmVudFtrZXldO1xuICB9XG4gIGlmICh0eXBlb2YgY2xhc3NQcm9wZXJ0aWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGZvciAoa2V5IGluIGNsYXNzUHJvcGVydGllcykge1xuICAgICAgY2hpbGRba2V5XSA9IGNsYXNzUHJvcGVydGllc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG4gIC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gIHZhciBTdXJyb2dhdGUgPSBmdW5jdGlvbiBTdXJyb2dhdGUoKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkO1xuICB9O1xuICBTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xuXG4gIC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuICAvLyBpZiBzdXBwbGllZC5cbiAgaWYgKHByb3RvdHlwZVByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGtleSBpbiBwcm90b3R5cGVQcm9wZXJ0aWVzKSB7XG4gICAgICBjaGlsZC5wcm90b3R5cGVba2V5XSA9IHByb3RvdHlwZVByb3BlcnRpZXNba2V5XTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgYSBjb252ZW5pZW5jZSBwcm9wZXJ0eSBpbiBjYXNlIHRoZSBwYXJlbnQncyBwcm90b3R5cGUgaXMgbmVlZGVkXG4gIC8vIGxhdGVyLlxuICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gIHJldHVybiBjaGlsZDtcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL2xpYi9leHRlbmQuanNcbiAqKiBtb2R1bGUgaWQgPSAyNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9vcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcGVyYXRpb24pO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBmbGlwIHRoZSBjYW52YXNcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLkZsaXBPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBGbGlwT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfT3BlcmF0aW9uKSB7XG4gIF9pbmhlcml0cyhGbGlwT3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBGbGlwT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbGlwT3BlcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZsaXBPcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy5mcmFnbWVudFNoYWRlciA9ICdcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gYm9vbCB1X2ZsaXBWZXJ0aWNhbDtcXG4gICAgICB1bmlmb3JtIGJvb2wgdV9mbGlwSG9yaXpvbnRhbDtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWMyIHRleENvb3JkID0gdmVjMih2X3RleENvb3JkKTtcXG4gICAgICAgIGlmICh1X2ZsaXBWZXJ0aWNhbCkge1xcbiAgICAgICAgICB0ZXhDb29yZC55ID0gMS4wIC0gdGV4Q29vcmQueTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh1X2ZsaXBIb3Jpem9udGFsKSB7XFxuICAgICAgICAgIHRleENvb3JkLnggPSAxLjAgLSB0ZXhDb29yZC54O1xcbiAgICAgICAgfVxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHRleENvb3JkKTtcXG4gICAgICB9XFxuICAgICc7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcm9wcyB0aGlzIGltYWdlIHVzaW5nIFdlYkdMXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhGbGlwT3BlcmF0aW9uLCBbe1xuICAgIGtleTogJ19yZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1X2ZsaXBWZXJ0aWNhbDogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9vcHRpb25zLnZlcnRpY2FsIH0sXG4gICAgICAgICAgdV9mbGlwSG9yaXpvbnRhbDogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmhvcml6b250YWwgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgICAgdmFyIHNjYWxlWCA9IDEsXG4gICAgICAgICAgc2NhbGVZID0gMTtcbiAgICAgIHZhciB0cmFuc2xhdGVYID0gMCxcbiAgICAgICAgICB0cmFuc2xhdGVZID0gMDtcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaG9yaXpvbnRhbCkge1xuICAgICAgICBzY2FsZVggPSAtMTtcbiAgICAgICAgdHJhbnNsYXRlWCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMudmVydGljYWwpIHtcbiAgICAgICAgc2NhbGVZID0gLTE7XG4gICAgICAgIHRyYW5zbGF0ZVkgPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICBjb250ZXh0LnNhdmUoKTtcblxuICAgICAgLy8gQXBwbHkgdGhlIHRyYW5zZm9ybWF0aW9uXG4gICAgICBjb250ZXh0LnRyYW5zbGF0ZSh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgICAgIGNvbnRleHQuc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuXG4gICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgY2FudmFzIHNvIHRoYXQgd2UgY2FuIGRyYXcgdGhlIGltYWdlXG4gICAgICAvLyB3aXRoIHRoZSBhcHBsaWVkIHRyYW5zZm9ybWF0aW9uXG4gICAgICB2YXIgdGVtcENhbnZhcyA9IHJlbmRlcmVyLmNsb25lQ2FudmFzKCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSh0ZW1wQ2FudmFzLCAwLCAwKTtcblxuICAgICAgLy8gUmVzdG9yZSBvbGQgdHJhbnNmb3JtYXRpb25cbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGbGlwT3BlcmF0aW9uO1xufSkoX29wZXJhdGlvbjJbJ2RlZmF1bHQnXSk7XG5cbkZsaXBPcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXIgPSAnZmxpcCc7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZsaXBPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIGhvcml6b250YWw6IHsgdHlwZTogJ2Jvb2xlYW4nLCAnZGVmYXVsdCc6IGZhbHNlIH0sXG4gIHZlcnRpY2FsOiB7IHR5cGU6ICdib29sZWFuJywgJ2RlZmF1bHQnOiBmYWxzZSB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGbGlwT3BlcmF0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmxpcC1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAyNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIHByb2Nlc3MgPSBwcm9jZXNzIHx8IHt9O1xuKGZ1bmN0aW9uICgpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5cbnZhciBpc1dpbmRvd3MgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInO1xudmFyIHV0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5cbmlmIChpc1dpbmRvd3MpIHtcbiAgLy8gUmVnZXggdG8gc3BsaXQgYSB3aW5kb3dzIHBhdGggaW50byB0aHJlZSBwYXJ0czogWyosIGRldmljZSwgc2xhc2gsXG4gIC8vIHRhaWxdIHdpbmRvd3Mtb25seVxuICB2YXIgc3BsaXREZXZpY2VSZSA9XG4gICAgICAvXihbYS16QS1aXTp8W1xcXFxcXC9dezJ9W15cXFxcXFwvXStbXFxcXFxcL10rW15cXFxcXFwvXSspPyhbXFxcXFxcL10pPyhbXFxzXFxTXSo/KSQvO1xuXG4gIC8vIFJlZ2V4IHRvIHNwbGl0IHRoZSB0YWlsIHBhcnQgb2YgdGhlIGFib3ZlIGludG8gWyosIGRpciwgYmFzZW5hbWUsIGV4dF1cbiAgdmFyIHNwbGl0VGFpbFJlID1cbiAgICAgIC9eKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFxcXFxcL10rP3wpKFxcLlteLlxcL1xcXFxdKnwpKSg/OltcXFxcXFwvXSopJC87XG5cbiAgLy8gRnVuY3Rpb24gdG8gc3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdXG4gIC8vIHdpbmRvd3MgdmVyc2lvblxuICB2YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICAvLyBTZXBhcmF0ZSBkZXZpY2Urc2xhc2ggZnJvbSB0YWlsXG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhmaWxlbmFtZSksXG4gICAgICAgIGRldmljZSA9IChyZXN1bHRbMV0gfHwgJycpICsgKHJlc3VsdFsyXSB8fCAnJyksXG4gICAgICAgIHRhaWwgPSByZXN1bHRbM10gfHwgJyc7XG4gICAgLy8gU3BsaXQgdGhlIHRhaWwgaW50byBkaXIsIGJhc2VuYW1lIGFuZCBleHRlbnNpb25cbiAgICB2YXIgcmVzdWx0MiA9IHNwbGl0VGFpbFJlLmV4ZWModGFpbCksXG4gICAgICAgIGRpciA9IHJlc3VsdDJbMV0sXG4gICAgICAgIGJhc2VuYW1lID0gcmVzdWx0MlsyXSxcbiAgICAgICAgZXh0ID0gcmVzdWx0MlszXTtcbiAgICByZXR1cm4gW2RldmljZSwgZGlyLCBiYXNlbmFtZSwgZXh0XTtcbiAgfTtcblxuICB2YXIgbm9ybWFsaXplVU5DUm9vdCA9IGZ1bmN0aW9uKGRldmljZSkge1xuICAgIHJldHVybiAnXFxcXFxcXFwnICsgZGV2aWNlLnJlcGxhY2UoL15bXFxcXFxcL10rLywgJycpLnJlcGxhY2UoL1tcXFxcXFwvXSsvZywgJ1xcXFwnKTtcbiAgfTtcblxuICAvLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4gIC8vIHdpbmRvd3MgdmVyc2lvblxuICBleHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzb2x2ZWREZXZpY2UgPSAnJyxcbiAgICAgICAgcmVzb2x2ZWRUYWlsID0gJycsXG4gICAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMTsgaS0tKSB7XG4gICAgICB2YXIgcGF0aDtcbiAgICAgIGlmIChpID49IDApIHtcbiAgICAgICAgcGF0aCA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlc29sdmVkRGV2aWNlKSB7XG4gICAgICAgIHBhdGggPSBwcm9jZXNzLmN3ZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2luZG93cyBoYXMgdGhlIGNvbmNlcHQgb2YgZHJpdmUtc3BlY2lmaWMgY3VycmVudCB3b3JraW5nXG4gICAgICAgIC8vIGRpcmVjdG9yaWVzLiBJZiB3ZSd2ZSByZXNvbHZlZCBhIGRyaXZlIGxldHRlciBidXQgbm90IHlldCBhblxuICAgICAgICAvLyBhYnNvbHV0ZSBwYXRoLCBnZXQgY3dkIGZvciB0aGF0IGRyaXZlLiBXZSdyZSBzdXJlIHRoZSBkZXZpY2UgaXMgbm90XG4gICAgICAgIC8vIGFuIHVuYyBwYXRoIGF0IHRoaXMgcG9pbnRzLCBiZWNhdXNlIHVuYyBwYXRocyBhcmUgYWx3YXlzIGFic29sdXRlLlxuICAgICAgICBwYXRoID0gcHJvY2Vzcy5lbnZbJz0nICsgcmVzb2x2ZWREZXZpY2VdO1xuICAgICAgICAvLyBWZXJpZnkgdGhhdCBhIGRyaXZlLWxvY2FsIGN3ZCB3YXMgZm91bmQgYW5kIHRoYXQgaXQgYWN0dWFsbHkgcG9pbnRzXG4gICAgICAgIC8vIHRvIG91ciBkcml2ZS4gSWYgbm90LCBkZWZhdWx0IHRvIHRoZSBkcml2ZSdzIHJvb3QuXG4gICAgICAgIGlmICghcGF0aCB8fCBwYXRoLnN1YnN0cigwLCAzKS50b0xvd2VyQ2FzZSgpICE9PVxuICAgICAgICAgICAgcmVzb2x2ZWREZXZpY2UudG9Mb3dlckNhc2UoKSArICdcXFxcJykge1xuICAgICAgICAgIHBhdGggPSByZXNvbHZlZERldmljZSArICdcXFxcJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKSxcbiAgICAgICAgICBkZXZpY2UgPSByZXN1bHRbMV0gfHwgJycsXG4gICAgICAgICAgaXNVbmMgPSBkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonLFxuICAgICAgICAgIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICAgICAgdGFpbCA9IHJlc3VsdFszXTtcblxuICAgICAgaWYgKGRldmljZSAmJlxuICAgICAgICAgIHJlc29sdmVkRGV2aWNlICYmXG4gICAgICAgICAgZGV2aWNlLnRvTG93ZXJDYXNlKCkgIT09IHJlc29sdmVkRGV2aWNlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgLy8gVGhpcyBwYXRoIHBvaW50cyB0byBhbm90aGVyIGRldmljZSBzbyBpdCBpcyBub3QgYXBwbGljYWJsZVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFyZXNvbHZlZERldmljZSkge1xuICAgICAgICByZXNvbHZlZERldmljZSA9IGRldmljZTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzb2x2ZWRBYnNvbHV0ZSkge1xuICAgICAgICByZXNvbHZlZFRhaWwgPSB0YWlsICsgJ1xcXFwnICsgcmVzb2x2ZWRUYWlsO1xuICAgICAgICByZXNvbHZlZEFic29sdXRlID0gaXNBYnNvbHV0ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29sdmVkRGV2aWNlICYmIHJlc29sdmVkQWJzb2x1dGUpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ29udmVydCBzbGFzaGVzIHRvIGJhY2tzbGFzaGVzIHdoZW4gYHJlc29sdmVkRGV2aWNlYCBwb2ludHMgdG8gYW4gVU5DXG4gICAgLy8gcm9vdC4gQWxzbyBzcXVhc2ggbXVsdGlwbGUgc2xhc2hlcyBpbnRvIGEgc2luZ2xlIG9uZSB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICBpZiAoaXNVbmMpIHtcbiAgICAgIHJlc29sdmVkRGV2aWNlID0gbm9ybWFsaXplVU5DUm9vdChyZXNvbHZlZERldmljZSk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsXG4gICAgLy8gYnV0IGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpXG4gICAgLy8gZmFpbHMpXG5cbiAgICAvLyBOb3JtYWxpemUgdGhlIHRhaWwgcGF0aFxuXG4gICAgZnVuY3Rpb24gZihwKSB7XG4gICAgICByZXR1cm4gISFwO1xuICAgIH1cblxuICAgIHJlc29sdmVkVGFpbCA9IG5vcm1hbGl6ZUFycmF5KHJlc29sdmVkVGFpbC5zcGxpdCgvW1xcXFxcXC9dKy8pLmZpbHRlcihmKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignXFxcXCcpO1xuXG4gICAgcmV0dXJuIChyZXNvbHZlZERldmljZSArIChyZXNvbHZlZEFic29sdXRlID8gJ1xcXFwnIDogJycpICsgcmVzb2x2ZWRUYWlsKSB8fFxuICAgICAgICAgICAnLic7XG4gIH07XG5cbiAgLy8gd2luZG93cyB2ZXJzaW9uXG4gIGV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIHZhciByZXN1bHQgPSBzcGxpdERldmljZVJlLmV4ZWMocGF0aCksXG4gICAgICAgIGRldmljZSA9IHJlc3VsdFsxXSB8fCAnJyxcbiAgICAgICAgaXNVbmMgPSBkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSAhPT0gJzonLFxuICAgICAgICBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgICB0YWlsID0gcmVzdWx0WzNdLFxuICAgICAgICB0cmFpbGluZ1NsYXNoID0gL1tcXFxcXFwvXSQvLnRlc3QodGFpbCk7XG5cbiAgICAvLyBJZiBkZXZpY2UgaXMgYSBkcml2ZSBsZXR0ZXIsIHdlJ2xsIG5vcm1hbGl6ZSB0byBsb3dlciBjYXNlLlxuICAgIGlmIChkZXZpY2UgJiYgZGV2aWNlLmNoYXJBdCgxKSA9PT0gJzonKSB7XG4gICAgICBkZXZpY2UgPSBkZXZpY2VbMF0udG9Mb3dlckNhc2UoKSArIGRldmljZS5zdWJzdHIoMSk7XG4gICAgfVxuXG4gICAgLy8gTm9ybWFsaXplIHRoZSB0YWlsIHBhdGhcbiAgICB0YWlsID0gbm9ybWFsaXplQXJyYXkodGFpbC5zcGxpdCgvW1xcXFxcXC9dKy8pLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gISFwO1xuICAgIH0pLCAhaXNBYnNvbHV0ZSkuam9pbignXFxcXCcpO1xuXG4gICAgaWYgKCF0YWlsICYmICFpc0Fic29sdXRlKSB7XG4gICAgICB0YWlsID0gJy4nO1xuICAgIH1cbiAgICBpZiAodGFpbCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgICB0YWlsICs9ICdcXFxcJztcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IHNsYXNoZXMgdG8gYmFja3NsYXNoZXMgd2hlbiBgZGV2aWNlYCBwb2ludHMgdG8gYW4gVU5DIHJvb3QuXG4gICAgLy8gQWxzbyBzcXVhc2ggbXVsdGlwbGUgc2xhc2hlcyBpbnRvIGEgc2luZ2xlIG9uZSB3aGVyZSBhcHByb3ByaWF0ZS5cbiAgICBpZiAoaXNVbmMpIHtcbiAgICAgIGRldmljZSA9IG5vcm1hbGl6ZVVOQ1Jvb3QoZGV2aWNlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGV2aWNlICsgKGlzQWJzb2x1dGUgPyAnXFxcXCcgOiAnJykgKyB0YWlsO1xuICB9O1xuXG4gIC8vIHdpbmRvd3MgdmVyc2lvblxuICBleHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIHJlc3VsdCA9IHNwbGl0RGV2aWNlUmUuZXhlYyhwYXRoKSxcbiAgICAgICAgZGV2aWNlID0gcmVzdWx0WzFdIHx8ICcnLFxuICAgICAgICBpc1VuYyA9ICEhZGV2aWNlICYmIGRldmljZS5jaGFyQXQoMSkgIT09ICc6JztcbiAgICAvLyBVTkMgcGF0aHMgYXJlIGFsd2F5cyBhYnNvbHV0ZVxuICAgIHJldHVybiAhIXJlc3VsdFsyXSB8fCBpc1VuYztcbiAgfTtcblxuICAvLyB3aW5kb3dzIHZlcnNpb25cbiAgZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZihwKSB7XG4gICAgICBpZiAoIXV0aWwuaXNTdHJpbmcocCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cblxuICAgIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChhcmd1bWVudHMsIGYpO1xuICAgIHZhciBqb2luZWQgPSBwYXRocy5qb2luKCdcXFxcJyk7XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgam9pbmVkIHBhdGggZG9lc24ndCBzdGFydCB3aXRoIHR3byBzbGFzaGVzLCBiZWNhdXNlXG4gICAgLy8gbm9ybWFsaXplKCkgd2lsbCBtaXN0YWtlIGl0IGZvciBhbiBVTkMgcGF0aCB0aGVuLlxuICAgIC8vXG4gICAgLy8gVGhpcyBzdGVwIGlzIHNraXBwZWQgd2hlbiBpdCBpcyB2ZXJ5IGNsZWFyIHRoYXQgdGhlIHVzZXIgYWN0dWFsbHlcbiAgICAvLyBpbnRlbmRlZCB0byBwb2ludCBhdCBhbiBVTkMgcGF0aC4gVGhpcyBpcyBhc3N1bWVkIHdoZW4gdGhlIGZpcnN0XG4gICAgLy8gbm9uLWVtcHR5IHN0cmluZyBhcmd1bWVudHMgc3RhcnRzIHdpdGggZXhhY3RseSB0d28gc2xhc2hlcyBmb2xsb3dlZCBieVxuICAgIC8vIGF0IGxlYXN0IG9uZSBtb3JlIG5vbi1zbGFzaCBjaGFyYWN0ZXIuXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgZm9yIG5vcm1hbGl6ZSgpIHRvIHRyZWF0IGEgcGF0aCBhcyBhbiBVTkMgcGF0aCBpdCBuZWVkcyB0b1xuICAgIC8vIGhhdmUgYXQgbGVhc3QgMiBjb21wb25lbnRzLCBzbyB3ZSBkb24ndCBmaWx0ZXIgZm9yIHRoYXQgaGVyZS5cbiAgICAvLyBUaGlzIG1lYW5zIHRoYXQgdGhlIHVzZXIgY2FuIHVzZSBqb2luIHRvIGNvbnN0cnVjdCBVTkMgcGF0aHMgZnJvbVxuICAgIC8vIGEgc2VydmVyIG5hbWUgYW5kIGEgc2hhcmUgbmFtZTsgZm9yIGV4YW1wbGU6XG4gICAgLy8gICBwYXRoLmpvaW4oJy8vc2VydmVyJywgJ3NoYXJlJykgLT4gJ1xcXFxcXFxcc2VydmVyXFxcXHNoYXJlXFwnKVxuICAgIGlmICghL15bXFxcXFxcL117Mn1bXlxcXFxcXC9dLy50ZXN0KHBhdGhzWzBdKSkge1xuICAgICAgam9pbmVkID0gam9pbmVkLnJlcGxhY2UoL15bXFxcXFxcL117Mix9LywgJ1xcXFwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoam9pbmVkKTtcbiAgfTtcblxuICAvLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuICAvLyBpdCB3aWxsIHNvbHZlIHRoZSByZWxhdGl2ZSBwYXRoIGZyb20gJ2Zyb20nIHRvICd0bycsIGZvciBpbnN0YW5jZTpcbiAgLy8gZnJvbSA9ICdDOlxcXFxvcmFuZGVhXFxcXHRlc3RcXFxcYWFhJ1xuICAvLyB0byA9ICdDOlxcXFxvcmFuZGVhXFxcXGltcGxcXFxcYmJiJ1xuICAvLyBUaGUgb3V0cHV0IG9mIHRoZSBmdW5jdGlvbiBzaG91bGQgYmU6ICcuLlxcXFwuLlxcXFxpbXBsXFxcXGJiYidcbiAgLy8gd2luZG93cyB2ZXJzaW9uXG4gIGV4cG9ydHMucmVsYXRpdmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSk7XG4gICAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pO1xuXG4gICAgLy8gd2luZG93cyBpcyBub3QgY2FzZSBzZW5zaXRpdmVcbiAgICB2YXIgbG93ZXJGcm9tID0gZnJvbS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBsb3dlclRvID0gdG8udG9Mb3dlckNhc2UoKTtcblxuICAgIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgIH1cblxuICAgIHZhciB0b1BhcnRzID0gdHJpbSh0by5zcGxpdCgnXFxcXCcpKTtcblxuICAgIHZhciBsb3dlckZyb21QYXJ0cyA9IHRyaW0obG93ZXJGcm9tLnNwbGl0KCdcXFxcJykpO1xuICAgIHZhciBsb3dlclRvUGFydHMgPSB0cmltKGxvd2VyVG8uc3BsaXQoJ1xcXFwnKSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5taW4obG93ZXJGcm9tUGFydHMubGVuZ3RoLCBsb3dlclRvUGFydHMubGVuZ3RoKTtcbiAgICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsb3dlckZyb21QYXJ0c1tpXSAhPT0gbG93ZXJUb1BhcnRzW2ldKSB7XG4gICAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzYW1lUGFydHNMZW5ndGggPT0gMCkge1xuICAgICAgcmV0dXJuIHRvO1xuICAgIH1cblxuICAgIHZhciBvdXRwdXRQYXJ0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBsb3dlckZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICB9XG5cbiAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gICAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJ1xcXFwnKTtcbiAgfTtcblxuICBleHBvcnRzLnNlcCA9ICdcXFxcJztcbiAgZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOyc7XG5cbn0gZWxzZSAvKiBwb3NpeCAqLyB7XG5cbiAgLy8gU3BsaXQgYSBmaWxlbmFtZSBpbnRvIFtyb290LCBkaXIsIGJhc2VuYW1lLCBleHRdLCB1bml4IHZlcnNpb25cbiAgLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbiAgdmFyIHNwbGl0UGF0aFJlID1cbiAgICAgIC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvO1xuICB2YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG4gIH07XG5cbiAgLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuICAvLyBwb3NpeCB2ZXJzaW9uXG4gIGV4cG9ydHMucmVzb2x2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpID49IC0xICYmICFyZXNvbHZlZEFic29sdXRlOyBpLS0pIHtcbiAgICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICAgIGlmICghdXRpbC5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgICAgfSBlbHNlIGlmICghcGF0aCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZWRQYXRoID0gcGF0aCArICcvJyArIHJlc29sdmVkUGF0aDtcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlIHBhdGggc2hvdWxkIGJlIHJlc29sdmVkIHRvIGEgZnVsbCBhYnNvbHV0ZSBwYXRoLCBidXRcbiAgICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIHJlc29sdmVkUGF0aCA9IG5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLmZpbHRlcihmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gISFwO1xuICAgIH0pLCAhcmVzb2x2ZWRBYnNvbHV0ZSkuam9pbignLycpO1xuXG4gICAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xuICB9O1xuXG4gIC8vIHBhdGgubm9ybWFsaXplKHBhdGgpXG4gIC8vIHBvc2l4IHZlcnNpb25cbiAgZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgdmFyIGlzQWJzb2x1dGUgPSBleHBvcnRzLmlzQWJzb2x1dGUocGF0aCksXG4gICAgICAgIHRyYWlsaW5nU2xhc2ggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICcvJyxcbiAgICAgICAgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcvJyksXG4gICAgICAgIG5vbkVtcHR5U2VnbWVudHMgPSBbXTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChzZWdtZW50c1tpXSkge1xuICAgICAgICBub25FbXB0eVNlZ21lbnRzLnB1c2goc2VnbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICBwYXRoID0gbm9ybWFsaXplQXJyYXkobm9uRW1wdHlTZWdtZW50cywgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICAgIGlmICghcGF0aCAmJiAhaXNBYnNvbHV0ZSkge1xuICAgICAgcGF0aCA9ICcuJztcbiAgICB9XG4gICAgaWYgKHBhdGggJiYgdHJhaWxpbmdTbGFzaCkge1xuICAgICAgcGF0aCArPSAnLyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIChpc0Fic29sdXRlID8gJy8nIDogJycpICsgcGF0aDtcbiAgfTtcblxuICAvLyBwb3NpeCB2ZXJzaW9uXG4gIGV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbiAgfTtcblxuICAvLyBwb3NpeCB2ZXJzaW9uXG4gIGV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwYXRoID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWdtZW50ID0gYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKCF1dGlsLmlzU3RyaW5nKHNlZ21lbnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICBwYXRoICs9IHNlZ21lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGF0aCArPSAnLycgKyBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShwYXRoKTtcbiAgfTtcblxuXG4gIC8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4gIC8vIHBvc2l4IHZlcnNpb25cbiAgZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gICAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gICAgdG8gPSBleHBvcnRzLnJlc29sdmUodG8pLnN1YnN0cigxKTtcblxuICAgIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgZm9yICg7IHN0YXJ0IDwgYXJyLmxlbmd0aDsgc3RhcnQrKykge1xuICAgICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgZW5kID0gYXJyLmxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCArIDEpO1xuICAgIH1cblxuICAgIHZhciBmcm9tUGFydHMgPSB0cmltKGZyb20uc3BsaXQoJy8nKSk7XG4gICAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgICB2YXIgc2FtZVBhcnRzTGVuZ3RoID0gbGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgc2FtZVBhcnRzTGVuZ3RoID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgb3V0cHV0UGFydHMucHVzaCgnLi4nKTtcbiAgICB9XG5cbiAgICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gICAgcmV0dXJuIG91dHB1dFBhcnRzLmpvaW4oJy8nKTtcbiAgfTtcblxuICBleHBvcnRzLnNlcCA9ICcvJztcbiAgZXhwb3J0cy5kZWxpbWl0ZXIgPSAnOic7XG59XG5cbmV4cG9ydHMuZGlybmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgdmFyIHJlc3VsdCA9IHNwbGl0UGF0aChwYXRoKSxcbiAgICAgIHJvb3QgPSByZXN1bHRbMF0sXG4gICAgICBkaXIgPSByZXN1bHRbMV07XG5cbiAgaWYgKCFyb290ICYmICFkaXIpIHtcbiAgICAvLyBObyBkaXJuYW1lIHdoYXRzb2V2ZXJcbiAgICByZXR1cm4gJy4nO1xuICB9XG5cbiAgaWYgKGRpcikge1xuICAgIC8vIEl0IGhhcyBhIGRpcm5hbWUsIHN0cmlwIHRyYWlsaW5nIHNsYXNoXG4gICAgZGlyID0gZGlyLnN1YnN0cigwLCBkaXIubGVuZ3RoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gcm9vdCArIGRpcjtcbn07XG5cblxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IHNwbGl0UGF0aChwYXRoKVsyXTtcbiAgLy8gVE9ETzogbWFrZSB0aGlzIGNvbXBhcmlzb24gY2FzZS1pbnNlbnNpdGl2ZSBvbiB3aW5kb3dzP1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuXG5leHBvcnRzLmV4dG5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBzcGxpdFBhdGgocGF0aClbM107XG59O1xuXG5cbmV4cG9ydHMuZXhpc3RzID0gdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24ocGF0aCwgY2FsbGJhY2spIHtcbiAgcmVxdWlyZSgnZnMnKS5leGlzdHMocGF0aCwgY2FsbGJhY2spO1xufSwgJ3BhdGguZXhpc3RzIGlzIG5vdyBjYWxsZWQgYGZzLmV4aXN0c2AuJyk7XG5cblxuZXhwb3J0cy5leGlzdHNTeW5jID0gdXRpbC5kZXByZWNhdGUoZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcmVxdWlyZSgnZnMnKS5leGlzdHNTeW5jKHBhdGgpO1xufSwgJ3BhdGguZXhpc3RzU3luYyBpcyBub3cgY2FsbGVkIGBmcy5leGlzdHNTeW5jYC4nKTtcblxuXG5pZiAoaXNXaW5kb3dzKSB7XG4gIGV4cG9ydHMuX21ha2VMb25nID0gZnVuY3Rpb24ocGF0aCkge1xuICAgIC8vIE5vdGU6IHRoaXMgd2lsbCAqcHJvYmFibHkqIHRocm93IHNvbWV3aGVyZS5cbiAgICBpZiAoIXV0aWwuaXNTdHJpbmcocGF0aCkpXG4gICAgICByZXR1cm4gcGF0aDtcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlZFBhdGggPSBleHBvcnRzLnJlc29sdmUocGF0aCk7XG5cbiAgICBpZiAoL15bYS16QS1aXVxcOlxcXFwvLnRlc3QocmVzb2x2ZWRQYXRoKSkge1xuICAgICAgLy8gcGF0aCBpcyBsb2NhbCBmaWxlc3lzdGVtIHBhdGgsIHdoaWNoIG5lZWRzIHRvIGJlIGNvbnZlcnRlZFxuICAgICAgLy8gdG8gbG9uZyBVTkMgcGF0aC5cbiAgICAgIHJldHVybiAnXFxcXFxcXFw/XFxcXCcgKyByZXNvbHZlZFBhdGg7XG4gICAgfSBlbHNlIGlmICgvXlxcXFxcXFxcW14/Ll0vLnRlc3QocmVzb2x2ZWRQYXRoKSkge1xuICAgICAgLy8gcGF0aCBpcyBuZXR3b3JrIFVOQyBwYXRoLCB3aGljaCBuZWVkcyB0byBiZSBjb252ZXJ0ZWRcbiAgICAgIC8vIHRvIGxvbmcgVU5DIHBhdGguXG4gICAgICByZXR1cm4gJ1xcXFxcXFxcP1xcXFxVTkNcXFxcJyArIHJlc29sdmVkUGF0aC5zdWJzdHJpbmcoMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGg7XG4gIH07XG59IGVsc2Uge1xuICBleHBvcnRzLl9tYWtlTG9uZyA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbn1cbn0oKSk7XG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC9Vc2Vycy9tbmltZXIvRGV2ZWxvcG1lbnQvZ2l0aHViL0ZhbWlseURBTS9hcHAtZGFzaGJvYXJkL34vaW1nbHlraXQtc2RrL34vcGF0aC9wYXRoLmpzXG4gKiogbW9kdWxlIGlkID0gMjZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cbiAgaWYgKGlzVW5kZWZpbmVkKGdsb2JhbC5wcm9jZXNzKSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5ub0RlcHJlY2F0aW9uID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL21uaW1lci9EZXZlbG9wbWVudC9naXRodWIvRmFtaWx5REFNL2FwcC1kYXNoYm9hcmQvfi9pbWdseWtpdC1zZGsvfi91dGlsL3V0aWwuanNcbiAqKiBtb2R1bGUgaWQgPSAyN1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0J1ZmZlcihhcmcpIHtcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xuICAgICYmIHR5cGVvZiBhcmcuY29weSA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcuZmlsbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xufVxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogL1VzZXJzL21uaW1lci9EZXZlbG9wbWVudC9naXRodWIvRmFtaWx5REFNL2FwcC1kYXNoYm9hcmQvfi9pbWdseWtpdC1zZGsvfi91dGlsL3N1cHBvcnQvaXNCdWZmZXJCcm93c2VyLmpzXG4gKiogbW9kdWxlIGlkID0gMjhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAvVXNlcnMvbW5pbWVyL0RldmVsb3BtZW50L2dpdGh1Yi9GYW1pbHlEQU0vYXBwLWRhc2hib2FyZC9+L2ltZ2x5a2l0LXNkay9+L2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAyOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyoganNoaW50IHVudXNlZDogZmFsc2UgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGZpbHRlcnMuIEV4dGVuZGFibGUgdmlhIHtAbGluayBJbWdseUtpdC5GaWx0ZXIjZXh0ZW5kfVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgRmlsdGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWx0ZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvIGNyZWF0ZSBhbiB7QGxpbmsgSW1nbHlLaXQuRmlsdGVyfSBjbGFzcyBvZiB5b3VyIG93biwgY2FsbCB0aGlzXG4gICAqIG1ldGhvZCBhbmQgcHJvdmlkZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXG4gICAqIEBmdW5jdGlvblxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbHRlciNyZW5kZXIgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsdGVyO1xufSkoKTtcblxuRmlsdGVyLmV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uL2xpYi9leHRlbmQnKTtcblxuLy8gRXhwb3NlZCBjbGFzc2VzXG5GaWx0ZXIuUHJpbWl0aXZlc1N0YWNrID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzLXN0YWNrJyk7XG5GaWx0ZXIuUHJpbWl0aXZlcyA9IHt9O1xuRmlsdGVyLlByaW1pdGl2ZXMuU2F0dXJhdGlvbiA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9zYXR1cmF0aW9uJyk7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Mb29rdXBUYWJsZSA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9sb29rdXAtdGFibGUnKTtcbkZpbHRlci5QcmltaXRpdmVzLlRvbmVDdXJ2ZSA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy90b25lLWN1cnZlJyk7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Tb2Z0Q29sb3JPdmVybGF5ID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL3NvZnQtY29sb3Itb3ZlcmxheScpO1xuRmlsdGVyLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL2Rlc2F0dXJhdGlvbicpO1xuRmlsdGVyLlByaW1pdGl2ZXMuWDQwMCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy94NDAwJyk7XG5GaWx0ZXIuUHJpbWl0aXZlcy5HcmF5c2NhbGUgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvZ3JheXNjYWxlJyk7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Db250cmFzdCA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9jb250cmFzdCcpO1xuRmlsdGVyLlByaW1pdGl2ZXMuR2xvdyA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlcy9nbG93Jyk7XG5GaWx0ZXIuUHJpbWl0aXZlcy5Hb2JibGluID0gcmVxdWlyZSgnLi9wcmltaXRpdmVzL2dvYmJsaW4nKTtcbkZpbHRlci5QcmltaXRpdmVzLkJyaWdodG5lc3MgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzcycpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDMxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBBIGhlbHBlciBjbGFzcyB0aGF0IGNhbiBjb2xsZWN0IHtAbGluayBQcmltaXRpdmV9IGluc3RhbmNlcyBhbmQgcmVuZGVyXG4gKiB0aGUgc3RhY2tcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzU3RhY2tcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIFByaW1pdGl2ZXNTdGFjayA9IChmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByaW1pdGl2ZXNTdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpbWl0aXZlc1N0YWNrKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBzdGFjayBvZiB7QGxpbmsgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX0gaW5zdGFuY2VzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBwcmltaXRpdmUgdG8gdGhlIHN0YWNrXG4gICAqIEBwYXJhbSB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX0gcHJpbWl0aXZlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhQcmltaXRpdmVzU3RhY2ssIFt7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQocHJpbWl0aXZlKSB7XG4gICAgICB0aGlzLl9zdGFjay5wdXNoKHByaW1pdGl2ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgc3RhY2sgb2YgcHJpbWl0aXZlcyBvbiB0aGUgcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcmltaXRpdmUgPSB0aGlzLl9zdGFja1tpXTtcbiAgICAgICAgcHJpbWl0aXZlLnJlbmRlcihyZW5kZXJlcik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFByaW1pdGl2ZXNTdGFjaztcbn0pKCk7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUHJpbWl0aXZlc1N0YWNrO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMtc3RhY2suanNcbiAqKiBtb2R1bGUgaWQgPSAzMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9wcmltaXRpdmUgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZScpO1xuXG52YXIgX3ByaW1pdGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmltaXRpdmUpO1xuXG4vKipcbiAqIFNhdHVyYXRpb24gcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5TYXR1cmF0aW9uXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX1cbiAqL1xuXG52YXIgU2F0dXJhdGlvbiA9IChmdW5jdGlvbiAoX1ByaW1pdGl2ZSkge1xuICBfaW5oZXJpdHMoU2F0dXJhdGlvbiwgX1ByaW1pdGl2ZSk7XG5cbiAgZnVuY3Rpb24gU2F0dXJhdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2F0dXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTYXR1cmF0aW9uLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLCB7XG4gICAgICBzYXR1cmF0aW9uOiAwXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdW5pZm9ybSBmbG9hdCB1X3NhdHVyYXRpb247XFxuXFxuICAgICAgY29uc3QgdmVjMyBsdW1pbmFuY2VXZWlnaHRpbmcgPSB2ZWMzKDAuMjEyNSwgMC43MTU0LCAwLjA3MjEpO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgICAgICBmbG9hdCBsdW1pbmFuY2UgPSBkb3QodGV4Q29sb3IucmdiLCBsdW1pbmFuY2VXZWlnaHRpbmcpO1xcblxcbiAgICAgICAgdmVjMyBncmV5U2NhbGVDb2xvciA9IHZlYzMobHVtaW5hbmNlKTtcXG5cXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KGdyZXlTY2FsZUNvbG9yLCB0ZXhDb2xvci5yZ2IsIHVfc2F0dXJhdGlvbikgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG4gICAgICB9XFxuICAgICc7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgX2NyZWF0ZUNsYXNzKFNhdHVyYXRpb24sIFt7XG4gICAga2V5OiAncmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgaWYgKCF0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdKSB7XG4gICAgICAgIHRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0gPSByZW5kZXJlci5zZXR1cEdMU0xQcm9ncmFtKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIucnVuUHJvZ3JhbSh0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdLCB7XG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdV9zYXR1cmF0aW9uOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuc2F0dXJhdGlvbiB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzKVxuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgc2F0dXJhdGlvbiA9IHRoaXMuX29wdGlvbnMuc2F0dXJhdGlvbjtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgICAgdmFyIGx1bWluYW5jZSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMjEyNSArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjcxNTQgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogMC4wNzIxO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiBzYXR1cmF0aW9uO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIHNhdHVyYXRpb24pICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSAqIHNhdHVyYXRpb247XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGx1bWluYW5jZSAqICgxIC0gc2F0dXJhdGlvbikgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogc2F0dXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNhdHVyYXRpb247XG59KShfcHJpbWl0aXZlMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU2F0dXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9zYXR1cmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gMzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGpzaGludCB1bnVzZWQ6IGZhbHNlICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltaXRpdmVzLiBFeHRlbmRhYmxlIHZpYSB7QGxpbmsgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZSNleHRlbmR9XG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG52YXIgUHJpbWl0aXZlID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJpbWl0aXZlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJpbWl0aXZlKTtcblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgdGhpcy5fZ2xzbFByb2dyYW1zID0ge307XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlXG4gICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoUHJpbWl0aXZlLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgaWYgKHJlbmRlcmVyLmlkZW50aWZpZXIgPT09ICd3ZWJnbCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJXZWJHTChyZW5kZXJlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyhyZW5kZXJlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB9LCB7XG4gICAga2V5OiAncmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJpbWl0aXZlI3JlbmRlcldlYkdMIGlzIGFic3RyYWN0IGFuZCBub3QgaW1wbGVtZW50ZWQgaW4gaW5oZXJpdGVkIGNsYXNzLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoQ2FudmFzMkQpXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByaW1pdGl2ZSNyZW5kZXJDYW52YXMgaXMgYWJzdHJhY3QgYW5kIG5vdCBpbXBsZW1lbnRlZCBpbiBpbmhlcml0ZWQgY2xhc3MuJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnb3B0aW9ucycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHJpbWl0aXZlO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUHJpbWl0aXZlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3ByaW1pdGl2ZS5qc1xuICoqIG1vZHVsZSBpZCA9IDM0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX3ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlJyk7XG5cbnZhciBfcHJpbWl0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByaW1pdGl2ZSk7XG5cbi8qKlxuICogU3RvcmVzIGEgMjU2IGJ5dGUgbG9uZyBsb29rdXAgdGFibGUgaW4gYSAyZCB0ZXh0dXJlIHdoaWNoIHdpbGwgYmVcbiAqIHVzZWQgdG8gbG9vayB1cCB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBmb3IgZWFjaCBjaGFubmVsLlxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuTG9va3VwVGFibGVcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlfVxuICovXG5cbnZhciBMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoX1ByaW1pdGl2ZSkge1xuICBfaW5oZXJpdHMoTG9va3VwVGFibGUsIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIExvb2t1cFRhYmxlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb29rdXBUYWJsZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihMb29rdXBUYWJsZS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDM7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9sb29rdXBUYWJsZTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgZmxvYXQgciA9IHRleHR1cmUyRCh1X2xvb2t1cFRhYmxlLCB2ZWMyKHRleENvbG9yLnIsIDAuMCkpLnI7XFxuICAgICAgICBmbG9hdCBnID0gdGV4dHVyZTJEKHVfbG9va3VwVGFibGUsIHZlYzIodGV4Q29sb3IuZywgMC4wKSkuZztcXG4gICAgICAgIGZsb2F0IGIgPSB0ZXh0dXJlMkQodV9sb29rdXBUYWJsZSwgdmVjMih0ZXhDb2xvci5iLCAwLjApKS5iO1xcblxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2ZWMzKHIsIGcsIGIpICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhMb29rdXBUYWJsZSwgW3tcbiAgICBrZXk6ICdyZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLl91cGRhdGVUZXh0dXJlKHJlbmRlcmVyKTtcblxuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdV9sb29rdXBUYWJsZTogeyB0eXBlOiAnaScsIHZhbHVlOiAzIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChDYW52YXMpXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgdGFibGUgPSB0aGlzLl9vcHRpb25zLmRhdGE7XG5cbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICAgIHZhciByID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IHRhYmxlW3IgKiA0XTtcbiAgICAgICAgICB2YXIgZyA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV07XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IHRhYmxlWzEgKyBnICogNF07XG4gICAgICAgICAgdmFyIGIgPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSB0YWJsZVsyICsgYiAqIDRdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb29rdXAgdGFibGUgdGV4dHVyZSAoV2ViR0wgb25seSlcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlVGV4dHVyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVUZXh0dXJlKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5kYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvb2t1cFRhYmxlOiBObyBkYXRhIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGFUeXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fb3B0aW9ucy5kYXRhKTtcblxuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuX3RleHR1cmVJbmRleCk7XG4gICAgICBpZiAoIXRoaXMuX3RleHR1cmUpIHtcbiAgICAgICAgdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRoaXMuX3RleHR1cmUpO1xuXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcblxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCAyNTYsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGFUeXBlZEFycmF5KTtcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb29rdXBUYWJsZTtcbn0pKF9wcmltaXRpdmUyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBMb29rdXBUYWJsZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9sb29rdXAtdGFibGUuanNcbiAqKiBtb2R1bGUgaWQgPSAzNVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9sb29rdXBUYWJsZSA9IHJlcXVpcmUoJy4vbG9va3VwLXRhYmxlJyk7XG5cbnZhciBfbG9va3VwVGFibGUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbG9va3VwVGFibGUpO1xuXG4vKipcbiAqIFRvbmUgY3VydmUgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Ub25lQ3VydmVcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Mb29rdXBUYWJsZX1cbiAqL1xuXG52YXIgVG9uZUN1cnZlID0gKGZ1bmN0aW9uIChfTG9va3VwVGFibGUpIHtcbiAgX2luaGVyaXRzKFRvbmVDdXJ2ZSwgX0xvb2t1cFRhYmxlKTtcblxuICBmdW5jdGlvbiBUb25lQ3VydmUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvbmVDdXJ2ZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUb25lQ3VydmUucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICB0aGlzLl9vcHRpb25zID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmRlZmF1bHRzKHRoaXMuX29wdGlvbnMsIHtcbiAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgcmVkOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHMsXG4gICAgICAgIGdyZWVuOiB0aGlzLl9vcHRpb25zLmNvbnRyb2xQb2ludHMsXG4gICAgICAgIGJsdWU6IHRoaXMuX29wdGlvbnMuY29udHJvbFBvaW50c1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl91cGRhdGVMb29rdXBUYWJsZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsb29rdXAgdGFibGVcbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFRvbmVDdXJ2ZSwgW3tcbiAgICBrZXk6ICdfdXBkYXRlTG9va3VwVGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTG9va3VwVGFibGUoKSB7XG4gICAgICB2YXIgciA9IHRoaXMuX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHRoaXMuX29wdGlvbnMucmdiQ29udHJvbFBvaW50cy5yZWQpO1xuICAgICAgdmFyIGcgPSB0aGlzLl9jYWxjdWxhdGVTcGxpbmVDdXJ2ZSh0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMuZ3JlZW4pO1xuICAgICAgdmFyIGIgPSB0aGlzLl9jYWxjdWxhdGVTcGxpbmVDdXJ2ZSh0aGlzLl9vcHRpb25zLnJnYkNvbnRyb2xQb2ludHMuYmx1ZSk7XG5cbiAgICAgIHRoaXMuX29wdGlvbnMuZGF0YSA9IHRoaXMuX2J1aWxkTG9va3VwVGFibGUociwgZywgYik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBsb29rdXAgdGFibGVcbiAgICAgKiBAcGFyYW0gIHtBcnJheX0gclxuICAgICAqIEBwYXJhbSAge0FycmF5fSBnXG4gICAgICogQHBhcmFtICB7QXJyYXl9IGJcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2J1aWxkTG9va3VwVGFibGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRMb29rdXBUYWJsZShyLCBnLCBiKSB7XG4gICAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIGRhdGEucHVzaChNYXRoLm1pbihNYXRoLm1heChpICsgcltpXSwgMCksIDI1NSkpO1xuICAgICAgICBkYXRhLnB1c2goTWF0aC5taW4oTWF0aC5tYXgoaSArIGdbaV0sIDApLCAyNTUpKTtcbiAgICAgICAgZGF0YS5wdXNoKE1hdGgubWluKE1hdGgubWF4KGkgKyBiW2ldLCAwKSwgMjU1KSk7XG4gICAgICAgIGRhdGEucHVzaCgyNTUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBzcGxpbmUgY3VydmUgZGF0YSBmb3IgdGhlIGdpdmVuIHBvaW50c1xuICAgICAqIEBwYXJhbSAge0FycmF5LjxBcnJheS48TnVtYmVyPj59IHBvaW50c1xuICAgICAqIEByZXR1cm4ge0FycmF5LjxOdW1iZXI+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2NhbGN1bGF0ZVNwbGluZUN1cnZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVNwbGluZUN1cnZlKHBvaW50cykge1xuICAgICAgcG9pbnRzID0gcG9pbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPiBiWzBdO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBzcGxpbmVQb2ludHMgPSB0aGlzLl9nZXRTcGxpbmVDdXJ2ZShwb2ludHMpO1xuICAgICAgdmFyIGZpcnN0U3BsaW5lUG9pbnQgPSBzcGxpbmVQb2ludHNbMF07XG4gICAgICB2YXIgaTtcblxuICAgICAgaWYgKGZpcnN0U3BsaW5lUG9pbnRbMF0gPiAwKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmaXJzdFNwbGluZVBvaW50WzBdOyBpKyspIHtcbiAgICAgICAgICBzcGxpbmVQb2ludHMudW5zaGlmdChbMCwgMF0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmVwYXJlZFBvaW50cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHNwbGluZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSBzcGxpbmVQb2ludHNbaV07XG4gICAgICAgIHZhciBvcmlnUG9pbnQgPSBbbmV3UG9pbnRbMF0sIG5ld1BvaW50WzBdXTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cob3JpZ1BvaW50WzBdIC0gbmV3UG9pbnRbMF0sIDIpICsgTWF0aC5wb3cob3JpZ1BvaW50WzFdIC0gbmV3UG9pbnRbMV0sIDIpKTtcblxuICAgICAgICBpZiAob3JpZ1BvaW50WzFdID4gbmV3UG9pbnRbMV0pIHtcbiAgICAgICAgICBkaXN0YW5jZSA9IC1kaXN0YW5jZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXBhcmVkUG9pbnRzLnB1c2goZGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJlcGFyZWRQb2ludHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2dldFNwbGluZUN1cnZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFNwbGluZUN1cnZlKHBvaW50cykge1xuICAgICAgdmFyIHNkQSA9IHRoaXMuX3NlY29uZERlcml2YXRpdmUocG9pbnRzKTtcblxuICAgICAgdmFyIG4gPSBzZEEubGVuZ3RoO1xuICAgICAgdmFyIHNkID0gW107XG4gICAgICB2YXIgaTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBzZFtpXSA9IHNkQVtpXTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbiAtIDE7IGkrKykge1xuICAgICAgICB2YXIgY3VyID0gcG9pbnRzW2ldO1xuICAgICAgICB2YXIgbmV4dCA9IHBvaW50c1tpICsgMV07XG5cbiAgICAgICAgZm9yICh2YXIgeCA9IGN1clswXTsgeCA8IG5leHRbMF07IHgrKykge1xuICAgICAgICAgIHZhciB0ID0gKHggLSBjdXJbMF0pIC8gKG5leHRbMF0gLSBjdXJbMF0pO1xuXG4gICAgICAgICAgdmFyIGEgPSAxIC0gdDtcbiAgICAgICAgICB2YXIgYiA9IHQ7XG4gICAgICAgICAgdmFyIGggPSBuZXh0WzBdIC0gY3VyWzBdO1xuXG4gICAgICAgICAgdmFyIHkgPSBhICogY3VyWzFdICsgYiAqIG5leHRbMV0gKyBoICogaCAvIDYgKiAoKGEgKiBhICogYSAtIGEpICogc2RbaV0gKyAoYiAqIGIgKiBiIC0gYikgKiBzZFtpICsgMV0pO1xuXG4gICAgICAgICAgaWYgKHkgPiAyNTUpIHtcbiAgICAgICAgICAgIHkgPSAyNTU7XG4gICAgICAgICAgfSBlbHNlIGlmICh5IDwgMCkge1xuICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgb3V0cHV0LnB1c2goW3gsIHldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMjU1KSB7XG4gICAgICAgIG91dHB1dC5wdXNoKHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19zZWNvbmREZXJpdmF0aXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NlY29uZERlcml2YXRpdmUocG9pbnRzKSB7XG4gICAgICB2YXIgbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgICBpZiAobiA8PSAwIHx8IG4gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRyaXggPSBbXTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHZhciBpLCBrO1xuXG4gICAgICBtYXRyaXhbMF0gPSBbMCwgMSwgMF07XG5cbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBQMSA9IHBvaW50c1tpIC0gMV07XG4gICAgICAgIHZhciBQMiA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIFAzID0gcG9pbnRzW2kgKyAxXTtcblxuICAgICAgICBtYXRyaXhbaV0gPSBtYXRyaXhbaV0gfHwgW107XG4gICAgICAgIG1hdHJpeFtpXVswXSA9IChQMlswXSAtIFAxWzBdKSAvIDY7XG4gICAgICAgIG1hdHJpeFtpXVsxXSA9IChQM1swXSAtIFAxWzBdKSAvIDM7XG4gICAgICAgIG1hdHJpeFtpXVsyXSA9IChQM1swXSAtIFAyWzBdKSAvIDY7XG4gICAgICAgIHJlc3VsdFtpXSA9IChQM1sxXSAtIFAyWzFdKSAvIChQM1swXSAtIFAyWzBdKSAtIChQMlsxXSAtIFAxWzFdKSAvIChQMlswXSAtIFAxWzBdKTtcbiAgICAgIH1cblxuICAgICAgcmVzdWx0WzBdID0gMDtcbiAgICAgIHJlc3VsdFtuIC0gMV0gPSAwO1xuXG4gICAgICBtYXRyaXhbbiAtIDFdID0gWzAsIDEsIDBdO1xuXG4gICAgICAvLyBQYXNzIDFcbiAgICAgIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgayA9IG1hdHJpeFsxXVswXSAvIG1hdHJpeFtpIC0gMV1bMV07XG4gICAgICAgIG1hdHJpeFtpXVsxXSAtPSBrICogbWF0cml4W2kgLSAxXVsyXTtcbiAgICAgICAgbWF0cml4W2ldWzBdID0gMDtcbiAgICAgICAgcmVzdWx0W2ldIC09IGsgKiByZXN1bHRbaSAtIDFdO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIDJcbiAgICAgIGZvciAoaSA9IG4gLSAyOyBpID4gMDsgaS0tKSB7XG4gICAgICAgIGsgPSBtYXRyaXhbaV1bMl0gLyBtYXRyaXhbaSArIDFdWzFdO1xuICAgICAgICBtYXRyaXhbaV1bMV0gLT0gayAqIG1hdHJpeFtpICsgMV1bMF07XG4gICAgICAgIG1hdHJpeFtpXVsyXSA9IDA7XG4gICAgICAgIHJlc3VsdFtpXSAtPSBrICogcmVzdWx0W2kgKyAxXTtcbiAgICAgIH1cblxuICAgICAgdmFyIHkyID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHkyW2ldID0gcmVzdWx0W2ldIC8gbWF0cml4W2ldWzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4geTI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFRvbmVDdXJ2ZTtcbn0pKF9sb29rdXBUYWJsZTJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRvbmVDdXJ2ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy90b25lLWN1cnZlLmpzXG4gKiogbW9kdWxlIGlkID0gMzZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfcHJpbWl0aXZlID0gcmVxdWlyZSgnLi9wcmltaXRpdmUnKTtcblxudmFyIF9wcmltaXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJpbWl0aXZlKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxuLyoqXG4gKiBTb2Z0Q29sb3JPdmVybGF5IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuU29mdENvbG9yT3ZlcmxheVxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIFNvZnRDb2xvck92ZXJsYXkgPSAoZnVuY3Rpb24gKF9QcmltaXRpdmUpIHtcbiAgX2luaGVyaXRzKFNvZnRDb2xvck92ZXJsYXksIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIFNvZnRDb2xvck92ZXJsYXkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNvZnRDb2xvck92ZXJsYXkpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoU29mdENvbG9yT3ZlcmxheS5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgY29sb3I6IG5ldyBfbGliQ29sb3IyWydkZWZhdWx0J10oMS4wLCAxLjAsIDEuMClcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG4gICAgICB1bmlmb3JtIHZlYzMgdV9vdmVybGF5O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgICAgICB2ZWM0IG92ZXJsYXlWZWM0ID0gdmVjNCh1X292ZXJsYXksIHRleENvbG9yLmEpO1xcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gbWF4KG92ZXJsYXlWZWM0ICogdGV4Q29sb3IuYSwgdGV4Q29sb3IpO1xcbiAgICAgIH1cXG4gICAgJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKFdlYkdMKVxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoU29mdENvbG9yT3ZlcmxheSwgW3tcbiAgICBrZXk6ICdyZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1X292ZXJsYXk6IHsgdHlwZTogJzNmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuY29sb3IudG9SR0JHTENvbG9yKCkgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gTWF0aC5tYXgodGhpcy5fb3B0aW9ucy5jb2xvci5yLCBpbWFnZURhdGEuZGF0YVtpbmRleF0pO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLmcsIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0pO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBNYXRoLm1heCh0aGlzLl9vcHRpb25zLmNvbG9yLmIsIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU29mdENvbG9yT3ZlcmxheTtcbn0pKF9wcmltaXRpdmUyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTb2Z0Q29sb3JPdmVybGF5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3NvZnQtY29sb3Itb3ZlcmxheS5qc1xuICoqIG1vZHVsZSBpZCA9IDM3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgX3ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlJyk7XG5cbnZhciBfcHJpbWl0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByaW1pdGl2ZSk7XG5cbi8qKlxuICogRGVzYXR1cmF0aW9uIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX1cbiAqL1xuXG52YXIgRGVzYXR1cmF0aW9uID0gKGZ1bmN0aW9uIChfUHJpbWl0aXZlKSB7XG4gIF9pbmhlcml0cyhEZXNhdHVyYXRpb24sIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIERlc2F0dXJhdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVzYXR1cmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKERlc2F0dXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgZGVzYXR1cmF0aW9uOiAxLjBcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG4gICAgICB1bmlmb3JtIGZsb2F0IHVfZGVzYXR1cmF0aW9uO1xcblxcbiAgICAgIGNvbnN0IHZlYzMgbHVtaW5hbmNlV2VpZ2h0aW5nID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgdmVjMyBncmF5WGZlciA9IHZlYzMoMC4zLCAwLjU5LCAwLjExKTtcXG4gICAgICAgIHZlYzMgZ3JheSA9IHZlYzMoZG90KGdyYXlYZmVyLCB0ZXhDb2xvci54eXopKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQobWl4KHRleENvbG9yLnh5eiwgZ3JheSwgdV9kZXNhdHVyYXRpb24pICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhEZXNhdHVyYXRpb24sIFt7XG4gICAga2V5OiAncmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdV9kZXNhdHVyYXRpb246IHsgdHlwZTogJ2YnLCB2YWx1ZTogdGhpcy5fb3B0aW9ucy5kZXNhdHVyYXRpb24gfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBkZXNhdHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLmRlc2F0dXJhdGlvbjtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgICAgdmFyIGx1bWluYW5jZSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMyArIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjU5ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIDAuMTE7XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gbHVtaW5hbmNlICogKDEgLSBkZXNhdHVyYXRpb24pICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdICogZGVzYXR1cmF0aW9uO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICogZGVzYXR1cmF0aW9uO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2UgKiAoMSAtIGRlc2F0dXJhdGlvbikgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICogZGVzYXR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVzYXR1cmF0aW9uO1xufSkoX3ByaW1pdGl2ZTJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IERlc2F0dXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9kZXNhdHVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSAzOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9wcmltaXRpdmUgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZScpO1xuXG52YXIgX3ByaW1pdGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmltaXRpdmUpO1xuXG4vKipcbiAqIFg0MDAgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5YNDAwXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZX1cbiAqL1xuXG52YXIgWDQwMCA9IChmdW5jdGlvbiAoX1ByaW1pdGl2ZSkge1xuICBfaW5oZXJpdHMoWDQwMCwgX1ByaW1pdGl2ZSk7XG5cbiAgZnVuY3Rpb24gWDQwMCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWDQwMCk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihYNDAwLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciBmb3IgdGhpcyBwcmltaXRpdmVcbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9ICdcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgICAgICBmbG9hdCBncmF5ID0gdGV4Q29sb3IuciAqIDAuMyArIHRleENvbG9yLmcgKiAwLjMgKyB0ZXhDb2xvci5iICogMC4zO1xcbiAgICAgICAgZ3JheSAtPSAwLjI7XFxuICAgICAgICBncmF5ID0gY2xhbXAoZ3JheSwgMC4wLCAxLjApO1xcbiAgICAgICAgZ3JheSArPSAwLjE1O1xcbiAgICAgICAgZ3JheSAqPSAxLjQ7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMoZ3JheSkgKiB0ZXhDb2xvci5hLCB0ZXhDb2xvci5hKTtcXG4gICAgICB9XFxuICAgICc7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgX2NyZWF0ZUNsYXNzKFg0MDAsIFt7XG4gICAga2V5OiAncmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgICAgdmFyIGdyYXkgPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gLyAyNTUgKiAwLjMgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdIC8gMjU1ICogMC4zICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAvIDI1NSAqIDAuMztcbiAgICAgICAgICBncmF5IC09IDAuMjtcbiAgICAgICAgICBncmF5ID0gTWF0aC5tYXgoMC4wLCBNYXRoLm1pbigxLjAsIGdyYXkpKTtcbiAgICAgICAgICBncmF5ICs9IDAuMTU7XG4gICAgICAgICAgZ3JheSAqPSAxLjQ7XG5cbiAgICAgICAgICBncmF5ICo9IDI1NTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBncmF5O1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBncmF5O1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBncmF5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLmdldENvbnRleHQoKS5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWDQwMDtcbn0pKF9wcmltaXRpdmUyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBYNDAwO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL3g0MDAuanNcbiAqKiBtb2R1bGUgaWQgPSAzOVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9wcmltaXRpdmUgPSByZXF1aXJlKCcuL3ByaW1pdGl2ZScpO1xuXG52YXIgX3ByaW1pdGl2ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcmltaXRpdmUpO1xuXG4vKipcbiAqIEdyYXlzY2FsZSBwcmltaXRpdmVcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmVzLkdyYXlzY2FsZVxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIEdyYXlzY2FsZSA9IChmdW5jdGlvbiAoX1ByaW1pdGl2ZSkge1xuICBfaW5oZXJpdHMoR3JheXNjYWxlLCBfUHJpbWl0aXZlKTtcblxuICBmdW5jdGlvbiBHcmF5c2NhbGUoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdyYXlzY2FsZSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihHcmF5c2NhbGUucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdmVjMyBXID0gdmVjMygwLjIxMjUsIDAuNzE1NCwgMC4wNzIxKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgZmxvYXQgbHVtaW5hbmNlID0gZG90KHRleENvbG9yLnJnYiwgVyk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobHVtaW5hbmNlKSAqIHRleENvbG9yLmEsIHRleENvbG9yLmEpO1xcbiAgICAgIH1cXG4gICAgJztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKFdlYkdMKVxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoR3JheXNjYWxlLCBbe1xuICAgIGtleTogJ3JlbmRlcldlYkdMJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChDYW52YXMpXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBpbWFnZURhdGEgPSByZW5kZXJlci5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICAgIHZhciBsdW1pbmFuY2UgPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiAwLjIxMjUgKyBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICogMC43MTU0ICsgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIDAuMDcyMTtcblxuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGx1bWluYW5jZTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gbHVtaW5hbmNlO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSBsdW1pbmFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIuZ2V0Q29udGV4dCgpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHcmF5c2NhbGU7XG59KShfcHJpbWl0aXZlMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gR3JheXNjYWxlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2dyYXlzY2FsZS5qc1xuICoqIG1vZHVsZSBpZCA9IDQwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgX3ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4vcHJpbWl0aXZlJyk7XG5cbnZhciBfcHJpbWl0aXZlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ByaW1pdGl2ZSk7XG5cbi8qKlxuICogQ29udHJhc3QgcHJpbWl0aXZlXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXIuUHJpbWl0aXZlcy5Db250cmFzdFxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIENvbnRyYXN0ID0gKGZ1bmN0aW9uIChfUHJpbWl0aXZlKSB7XG4gIF9pbmhlcml0cyhDb250cmFzdCwgX1ByaW1pdGl2ZSk7XG5cbiAgZnVuY3Rpb24gQ29udHJhc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyYXN0KTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENvbnRyYXN0LnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgdGhpcy5fb3B0aW9ucyA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLCB7XG4gICAgICBjb250cmFzdDogMS4wXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdW5pZm9ybSBmbG9hdCB1X2NvbnRyYXN0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgdGV4Q29sb3IgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KCgodGV4Q29sb3IucmdiIC0gdmVjMygwLjUpKSAqIHVfY29udHJhc3QgKyB2ZWMzKDAuNSkgKiB0ZXhDb2xvci5hKSwgdGV4Q29sb3IuYSk7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhDb250cmFzdCwgW3tcbiAgICBrZXk6ICdyZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0pIHtcbiAgICAgICAgdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSA9IHJlbmRlcmVyLnNldHVwR0xTTFByb2dyYW0obnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5ydW5Qcm9ncmFtKHRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0sIHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1X2NvbnRyYXN0OiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuY29udHJhc3QgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBjb250cmFzdCA9IHRoaXMuX29wdGlvbnMuY29udHJhc3Q7XG5cbiAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY2FudmFzLndpZHRoOyB4KyspIHtcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSAoY2FudmFzLndpZHRoICogeSArIHgpICogNDtcblxuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IChpbWFnZURhdGEuZGF0YVtpbmRleF0gLSAxMjcpICogY29udHJhc3QgKyAxMjc7XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IChpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdIC0gMTI3KSAqIGNvbnRyYXN0ICsgMTI3O1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMl0gPSAoaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAtIDEyNykgKiBjb250cmFzdCArIDEyNztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbnRyYXN0O1xufSkoX3ByaW1pdGl2ZTJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbnRyYXN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9wcmltaXRpdmVzL2NvbnRyYXN0LmpzXG4gKiogbW9kdWxlIGlkID0gNDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfcHJpbWl0aXZlID0gcmVxdWlyZSgnLi9wcmltaXRpdmUnKTtcblxudmFyIF9wcmltaXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJpbWl0aXZlKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxuLyoqXG4gKiBHbG93IHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuR2xvd1xuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIEdsb3cgPSAoZnVuY3Rpb24gKF9QcmltaXRpdmUpIHtcbiAgX2luaGVyaXRzKEdsb3csIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIEdsb3coKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdsb3cpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoR2xvdy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgY29sb3I6IG5ldyBfbGliQ29sb3IyWydkZWZhdWx0J10oMSwgMSwgMSlcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG4gICAgICB1bmlmb3JtIHZlYzMgdV9jb2xvcjtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcblxcbiAgICAgICAgdmVjMiB0ZXh0dXJlQ29vcmQgPSB2X3RleENvb3JkIC0gdmVjMigwLjUsIDAuNSk7XFxuICAgICAgICB0ZXh0dXJlQ29vcmQgLz0gMC43NTtcXG5cXG4gICAgICAgIGZsb2F0IGQgPSAxLjAgLSBkb3QodGV4dHVyZUNvb3JkLCB0ZXh0dXJlQ29vcmQpO1xcbiAgICAgICAgZCA9IGNsYW1wKGQsIDAuMiwgMS4wKTtcXG4gICAgICAgIHZlYzMgbmV3Q29sb3IgPSB0ZXhDb2xvci5yZ2IgKiBkICogdV9jb2xvci5yZ2I7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZlYzMobmV3Q29sb3IpICogdGV4Q29sb3IuYSwgdGV4Q29sb3IuYSk7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhHbG93LCBbe1xuICAgIGtleTogJ3JlbmRlcldlYkdMJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHJlbmRlcmVyLnJ1blNoYWRlcihudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlciwge1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVfY29sb3I6IHsgdHlwZTogJzNmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuY29sb3IudG9SR0JHTENvbG9yKCkgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgICB2YXIgaW1hZ2VEYXRhID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YSgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5fb3B0aW9ucy5jb2xvcjtcblxuICAgICAgdmFyIGQ7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDQ7XG5cbiAgICAgICAgICB2YXIgeDAxID0geCAvIGNhbnZhcy53aWR0aDtcbiAgICAgICAgICB2YXIgeTAxID0geSAvIGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgICAgICB2YXIgbnggPSAoeDAxIC0gMC41KSAvIDAuNzU7XG4gICAgICAgICAgdmFyIG55ID0gKHkwMSAtIDAuNSkgLyAwLjc1O1xuXG4gICAgICAgICAgdmFyIHNjYWxhclggPSBueCAqIG54O1xuICAgICAgICAgIHZhciBzY2FsYXJZID0gbnkgKiBueTtcbiAgICAgICAgICBkID0gMSAtIChzY2FsYXJYICsgc2NhbGFyWSk7XG4gICAgICAgICAgZCA9IE1hdGgubWluKE1hdGgubWF4KGQsIDAuMSksIDEuMCk7XG5cbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKiAoZCAqIGNvbG9yLnIpO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICogKGQgKiBjb2xvci5nKTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSAqIChkICogY29sb3IuYik7XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdsb3c7XG59KShfcHJpbWl0aXZlMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gR2xvdztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nbG93LmpzXG4gKiogbW9kdWxlIGlkID0gNDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcHJpbWl0aXZlID0gcmVxdWlyZSgnLi9wcmltaXRpdmUnKTtcblxudmFyIF9wcmltaXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJpbWl0aXZlKTtcblxuLyoqXG4gKiBHb2JibGluIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuR29iYmxpblxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIEdvYmJsaW4gPSAoZnVuY3Rpb24gKF9QcmltaXRpdmUpIHtcbiAgX2luaGVyaXRzKEdvYmJsaW4sIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIEdvYmJsaW4oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEdvYmJsaW4pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoR29iYmxpbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgZm9yIHRoaXMgcHJpbWl0aXZlXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IHRleENvbG9yID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgdGV4Q29sb3IuYiA9IHRleENvbG9yLmcgKiAwLjMzO1xcbiAgICAgICAgdGV4Q29sb3IuciA9IHRleENvbG9yLnIgKiAwLjY7XFxuICAgICAgICB0ZXhDb2xvci5iICs9IHRleENvbG9yLnIgKiAwLjMzO1xcbiAgICAgICAgdGV4Q29sb3IuZyA9IHRleENvbG9yLmcgKiAwLjc7XFxuICAgICAgICBnbF9GcmFnQ29sb3IgPSB0ZXhDb2xvcjtcXG4gICAgICB9XFxuICAgICc7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcHJpbWl0aXZlIChXZWJHTClcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgX2NyZWF0ZUNsYXNzKEdvYmJsaW4sIFt7XG4gICAga2V5OiAncmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBjYW52YXMud2lkdGg7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgIHZhciBpbmRleCA9IChjYW52YXMud2lkdGggKiB5ICsgeCkgKiA0O1xuXG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjMzO1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4XSA9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuNjtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdICs9IGltYWdlRGF0YS5kYXRhW2luZGV4XSAqIDAuMzM7XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAxXSA9IGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gKiAwLjc7XG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5nZXRDb250ZXh0KCkucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEdvYmJsaW47XG59KShfcHJpbWl0aXZlMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gR29iYmxpbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcHJpbWl0aXZlcy9nb2JibGluLmpzXG4gKiogbW9kdWxlIGlkID0gNDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfcHJpbWl0aXZlID0gcmVxdWlyZSgnLi9wcmltaXRpdmUnKTtcblxudmFyIF9wcmltaXRpdmUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJpbWl0aXZlKTtcblxuLyoqXG4gKiBCcmlnaHRuZXNzIHByaW1pdGl2ZVxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVyLlByaW1pdGl2ZXMuQnJpZ2h0bmVzc1xuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlci5QcmltaXRpdmV9XG4gKi9cblxudmFyIEJyaWdodG5lc3MgPSAoZnVuY3Rpb24gKF9QcmltaXRpdmUpIHtcbiAgX2luaGVyaXRzKEJyaWdodG5lc3MsIF9QcmltaXRpdmUpO1xuXG4gIGZ1bmN0aW9uIEJyaWdodG5lc3MoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyaWdodG5lc3MpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJpZ2h0bmVzcy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZGVmYXVsdHModGhpcy5fb3B0aW9ucywge1xuICAgICAgYnJpZ2h0bmVzczogMS4wXG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIGZvciB0aGlzIHByaW1pdGl2ZVxuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdW5pZm9ybSBmbG9hdCB1X2JyaWdodG5lc3M7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCB0ZXhDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoKHRleENvbG9yLnJnYiArIHZlYzModV9icmlnaHRuZXNzKSAqIHRleENvbG9yLmEpLCB0ZXhDb2xvci5hKTs7XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIHByaW1pdGl2ZSAoV2ViR0wpXG4gICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhCcmlnaHRuZXNzLCBbe1xuICAgIGtleTogJ3JlbmRlcldlYkdMJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIGlmICghdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSkge1xuICAgICAgICB0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdID0gcmVuZGVyZXIuc2V0dXBHTFNMUHJvZ3JhbShudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJ1blByb2dyYW0odGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSwge1xuICAgICAgICB1bmlmb3Jtczoge1xuICAgICAgICAgIHVfYnJpZ2h0bmVzczogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmJyaWdodG5lc3MgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBwcmltaXRpdmUgKENhbnZhcylcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGltYWdlRGF0YSA9IHJlbmRlcmVyLmdldENvbnRleHQoKS5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5fb3B0aW9ucy5icmlnaHRuZXNzO1xuXG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgdmFyIGluZGV4ID0gKGNhbnZhcy53aWR0aCAqIHkgKyB4KSAqIDQ7XG5cbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleF0gPSBpbWFnZURhdGEuZGF0YVtpbmRleF0gKyBicmlnaHRuZXNzICogMjU1O1xuICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2luZGV4ICsgMV0gPSBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdICsgYnJpZ2h0bmVzcyAqIDI1NTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gaW1hZ2VEYXRhLmRhdGFbaW5kZXggKyAyXSArIGJyaWdodG5lc3MgKiAyNTU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIuZ2V0Q29udGV4dCgpLnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmlnaHRuZXNzO1xufSkoX3ByaW1pdGl2ZTJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJyaWdodG5lc3M7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzcy5qc1xuICoqIG1vZHVsZSBpZCA9IDQ0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX29wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG5cbnZhciBfb3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbik7XG5cbnZhciBfZmlsdGVyc0lkZW50aXR5RmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXJzL2lkZW50aXR5LWZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcnNJZGVudGl0eUZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXJzSWRlbnRpdHlGaWx0ZXIpO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBhcHBseSBhIHNlbGVjdGVkIGZpbHRlclxuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuRmlsdGVyc09wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cblxudmFyIEZpbHRlcnNPcGVyYXRpb24gPSAoZnVuY3Rpb24gKF9PcGVyYXRpb24pIHtcbiAgX2luaGVyaXRzKEZpbHRlcnNPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIEZpbHRlcnNPcGVyYXRpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbHRlcnNPcGVyYXRpb24pO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmlsdGVyc09wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoRmlsdGVyc09wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyIHVzaW5nIFdlYkdMXG4gICAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlciAoYWxsIHJlbmRlcmVycyBzdXBwb3J0ZWQpXG4gICAgICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3NlbGVjdGVkRmlsdGVyLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbHRlcnNPcGVyYXRpb247XG59KShfb3BlcmF0aW9uMlsnZGVmYXVsdCddKTtcblxuRmlsdGVyc09wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdmaWx0ZXJzJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuRmlsdGVyc09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgZmlsdGVyOiB7IHR5cGU6ICdvYmplY3QnLCAnZGVmYXVsdCc6IF9maWx0ZXJzSWRlbnRpdHlGaWx0ZXIyWydkZWZhdWx0J10sXG4gICAgc2V0dGVyOiBmdW5jdGlvbiBzZXR0ZXIoRmlsdGVyKSB7XG4gICAgICB0aGlzLl9zZWxlY3RlZEZpbHRlciA9IG5ldyBGaWx0ZXIoKTtcbiAgICAgIHJldHVybiBGaWx0ZXI7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGaWx0ZXJzT3BlcmF0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA0NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIElkZW50aXR5IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5JZGVudGl0eUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgSWRlbnRpdHlGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKElkZW50aXR5RmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBJZGVudGl0eUZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWRlbnRpdHlGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoSWRlbnRpdHlGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJZGVudGl0eUZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgaWRlbnRpdHkgZmlsdGVyLCBpdCBkb2Vzbid0IGhhdmUgYW55IGVmZmVjdC5cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ09yaWdpbmFsJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnaWRlbnRpdHknO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJZGVudGl0eUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBJZGVudGl0eUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvaWRlbnRpdHktZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfb3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcblxudmFyIF9vcGVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BlcmF0aW9uKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBfcmVuZGVyZXJzV2ViZ2xSZW5kZXJlckpzID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL3dlYmdsLXJlbmRlcmVyLmpzJyk7XG5cbnZhciBfcmVuZGVyZXJzV2ViZ2xSZW5kZXJlckpzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlbmRlcmVyc1dlYmdsUmVuZGVyZXJKcyk7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGNyb3Agb3V0IGEgcGFydCBvZiB0aGUgaW1hZ2VcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLkNyb3BPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBDcm9wT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfT3BlcmF0aW9uKSB7XG4gIF9pbmhlcml0cyhDcm9wT3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBDcm9wT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDcm9wT3BlcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKENyb3BPcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAqIG9wZXJhdGlvbnMuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIC8qKlxuICAgKiBSb3RhdGVzIGFuZCBjcm9wcyB0aGUgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQG92ZXJyaWRlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG4gIF9jcmVhdGVDbGFzcyhDcm9wT3BlcmF0aW9uLCBbe1xuICAgIGtleTogJ19yZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5fb3B0aW9ucy5zdGFydC5jbG9uZSgpO1xuICAgICAgdmFyIGVuZCA9IHRoaXMuX29wdGlvbnMuZW5kLmNsb25lKCk7XG4gICAgICB2YXIgc2l6ZSA9IGVuZC5jbG9uZSgpLnN1YnRyYWN0KHN0YXJ0KTtcbiAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSkge1xuICAgICAgICB0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdID0gcmVuZGVyZXIuc2V0dXBHTFNMUHJvZ3JhbShudWxsLCBmcmFnbWVudFNoYWRlciwgdGV4dHVyZUNvb3JkaW5hdGVzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRleHR1cmVDb29yZGluYXRlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xuICAgICAgLy8gRmlyc3QgdHJpYW5nbGVcbiAgICAgIHN0YXJ0LngsIDEuMCAtIGVuZC55LCBlbmQueCwgMS4wIC0gZW5kLnksIHN0YXJ0LngsIDEuMCAtIHN0YXJ0LnksXG5cbiAgICAgIC8vIFNlY29uZCB0cmlhbmdsZVxuICAgICAgc3RhcnQueCwgMS4wIC0gc3RhcnQueSwgZW5kLngsIDEuMCAtIGVuZC55LCBlbmQueCwgMS4wIC0gc3RhcnQueV0pO1xuICAgICAgcmVuZGVyZXIucnVuUHJvZ3JhbSh0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdLCB7IHRleHR1cmVDb29yZGluYXRlczogdGV4dHVyZUNvb3JkaW5hdGVzIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3BzIHRoZSBpbWFnZSB1c2luZyBDYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHZhciBuZXdEaW1lbnNpb25zID0gdGhpcy5nZXROZXdEaW1lbnNpb25zKHJlbmRlcmVyKTtcblxuICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IGNhbnZhcyB0byBkcmF3IHRvXG4gICAgICB2YXIgbmV3Q2FudmFzID0gcmVuZGVyZXIuY3JlYXRlQ2FudmFzKCk7XG4gICAgICBuZXdDYW52YXMud2lkdGggPSBuZXdEaW1lbnNpb25zLng7XG4gICAgICBuZXdDYW52YXMuaGVpZ2h0ID0gbmV3RGltZW5zaW9ucy55O1xuICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgLy8gVGhlIHVwcGVyIGxlZnQgY29ybmVyIG9mIHRoZSBjcm9wcGVkIGFyZWEgb24gdGhlIG9yaWdpbmFsIGltYWdlXG4gICAgICB2YXIgc3RhcnRQb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKTtcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgIHN0YXJ0UG9zaXRpb24ubXVsdGlwbHkoZGltZW5zaW9ucyk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIHNvdXJjZSBjYW52YXMgb250byB0aGUgbmV3IG9uZVxuICAgICAgbmV3Q29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCBzdGFydFBvc2l0aW9uLngsIHN0YXJ0UG9zaXRpb24ueSwgLy8gc291cmNlIHgsIHlcbiAgICAgIG5ld0RpbWVuc2lvbnMueCwgbmV3RGltZW5zaW9ucy55LCAvLyBzb3VyY2UgZGltZW5zaW9uc1xuICAgICAgMCwgMCwgLy8gZGVzdGluYXRpb24geCwgeVxuICAgICAgbmV3RGltZW5zaW9ucy54LCBuZXdEaW1lbnNpb25zLnkgLy8gZGVzdGluYXRpb24gZGltZW5zaW9uc1xuICAgICAgKTtcblxuICAgICAgLy8gU2V0IHRoZSBuZXcgY2FudmFzXG4gICAgICByZW5kZXJlci5zZXRDYW52YXMobmV3Q2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgICAqIEBwYXJhbSB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtIHtWZWN0b3IyfSBbZGltZW5zaW9uc11cbiAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0TmV3RGltZW5zaW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5ld0RpbWVuc2lvbnMocmVuZGVyZXIsIGRpbWVuc2lvbnMpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zIHx8IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgdmFyIG5ld0RpbWVuc2lvbnMgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpLnN1YnRyYWN0KHRoaXMuX29wdGlvbnMuc3RhcnQpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgbmV3RGltZW5zaW9ucy5tdWx0aXBseShkaW1lbnNpb25zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0RpbWVuc2lvbnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENyb3BPcGVyYXRpb247XG59KShfb3BlcmF0aW9uMlsnZGVmYXVsdCddKTtcblxuQ3JvcE9wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdjcm9wJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQ3JvcE9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgc3RhcnQ6IHsgdHlwZTogJ3ZlY3RvcjInLCByZXF1aXJlZDogdHJ1ZSwgJ2RlZmF1bHQnOiBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApIH0sXG4gIGVuZDogeyB0eXBlOiAndmVjdG9yMicsIHJlcXVpcmVkOiB0cnVlLCAnZGVmYXVsdCc6IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMSwgMSkgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ3JvcE9wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2Nyb3Atb3BlcmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfb3BlcmF0aW9uID0gcmVxdWlyZSgnLi9vcGVyYXRpb24nKTtcblxudmFyIF9vcGVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfb3BlcmF0aW9uKTtcblxudmFyIF9maWx0ZXJzUHJpbWl0aXZlc1N0YWNrID0gcmVxdWlyZSgnLi9maWx0ZXJzL3ByaW1pdGl2ZXMtc3RhY2snKTtcblxudmFyIF9maWx0ZXJzUHJpbWl0aXZlc1N0YWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcnNQcmltaXRpdmVzU3RhY2spO1xuXG52YXIgX2ZpbHRlcnNQcmltaXRpdmVzU2F0dXJhdGlvbiA9IHJlcXVpcmUoJy4vZmlsdGVycy9wcmltaXRpdmVzL3NhdHVyYXRpb24nKTtcblxudmFyIF9maWx0ZXJzUHJpbWl0aXZlc1NhdHVyYXRpb24yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyc1ByaW1pdGl2ZXNTYXR1cmF0aW9uKTtcblxuLyoqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlNhdHVyYXRpb25PcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBTYXR1cmF0aW9uT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfT3BlcmF0aW9uKSB7XG4gIF9pbmhlcml0cyhTYXR1cmF0aW9uT3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBTYXR1cmF0aW9uT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYXR1cmF0aW9uT3BlcmF0aW9uKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFNhdHVyYXRpb25PcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFNhdHVyYXRpb25PcGVyYXRpb24sIFt7XG4gICAga2V5OiAnX3JlbmRlcldlYkdMJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNhdHVyYXRpb24gdXNpbmcgV2ViR0xcbiAgICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgdGhpcy5fcmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBzYXR1cmF0aW9uIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHNhdHVyYXRpb24gKGFsbCByZW5kZXJlcnMgc3VwcG9ydGVkKVxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgaWYgKCF0aGlzLl9zdGFjaykge1xuICAgICAgICB0aGlzLl9zdGFjayA9IG5ldyBfZmlsdGVyc1ByaW1pdGl2ZXNTdGFjazJbJ2RlZmF1bHQnXSgpO1xuICAgICAgICB0aGlzLl9wcmltaXRpdmUgPSBuZXcgX2ZpbHRlcnNQcmltaXRpdmVzU2F0dXJhdGlvbjJbJ2RlZmF1bHQnXSh7XG4gICAgICAgICAgc2F0dXJhdGlvbjogdGhpcy5fb3B0aW9ucy5zYXR1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGFjay5hZGQodGhpcy5fcHJpbWl0aXZlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQFRPRE9cbiAgICAgIC8vIFByaW1pdGl2ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgb3B0aW9uIGxvZ2ljIGFzIG9wZXJhdGlvbnMgLSB3aGljaFxuICAgICAgLy8gc2hvdWxkIGFsbG93IHVzIHRvIGRvIGB0aGlzLl9wcmltaXRpdmUuc2V0U2F0dXJhdGlvbmBcbiAgICAgIHRoaXMuX3ByaW1pdGl2ZS5vcHRpb25zLnNhdHVyYXRpb24gPSB0aGlzLl9vcHRpb25zLnNhdHVyYXRpb247XG4gICAgICB0aGlzLl9zdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTYXR1cmF0aW9uT3BlcmF0aW9uO1xufSkoX29wZXJhdGlvbjJbJ2RlZmF1bHQnXSk7XG5cblNhdHVyYXRpb25PcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXIgPSAnc2F0dXJhdGlvbic7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cblNhdHVyYXRpb25PcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHNhdHVyYXRpb246IHsgdHlwZTogJ251bWJlcicsICdkZWZhdWx0JzogMS4wIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFNhdHVyYXRpb25PcGVyYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9zYXR1cmF0aW9uLW9wZXJhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDQ4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX29wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG5cbnZhciBfb3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbik7XG5cbnZhciBfZmlsdGVyc1ByaW1pdGl2ZXNTdGFjayA9IHJlcXVpcmUoJy4vZmlsdGVycy9wcmltaXRpdmVzLXN0YWNrJyk7XG5cbnZhciBfZmlsdGVyc1ByaW1pdGl2ZXNTdGFjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXJzUHJpbWl0aXZlc1N0YWNrKTtcblxudmFyIF9maWx0ZXJzUHJpbWl0aXZlc0NvbnRyYXN0ID0gcmVxdWlyZSgnLi9maWx0ZXJzL3ByaW1pdGl2ZXMvY29udHJhc3QnKTtcblxudmFyIF9maWx0ZXJzUHJpbWl0aXZlc0NvbnRyYXN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcnNQcmltaXRpdmVzQ29udHJhc3QpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuQ29udHJhc3RPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBDb250cmFzdE9wZXJhdGlvbiA9IChmdW5jdGlvbiAoX09wZXJhdGlvbikge1xuICBfaW5oZXJpdHMoQ29udHJhc3RPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIENvbnRyYXN0T3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cmFzdE9wZXJhdGlvbik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDb250cmFzdE9wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoQ29udHJhc3RPcGVyYXRpb24sIFt7XG4gICAga2V5OiAnX3JlbmRlcldlYkdMJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNvbnRyYXN0IHVzaW5nIFdlYkdMXG4gICAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udHJhc3QgdXNpbmcgQ2FudmFzMkRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udHJhc3QgKGFsbCByZW5kZXJlcnMgc3VwcG9ydGVkKVxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcihyZW5kZXJlcikge1xuICAgICAgaWYgKCF0aGlzLl9zdGFjaykge1xuICAgICAgICB0aGlzLl9zdGFjayA9IG5ldyBfZmlsdGVyc1ByaW1pdGl2ZXNTdGFjazJbJ2RlZmF1bHQnXSgpO1xuICAgICAgICB0aGlzLl9wcmltaXRpdmUgPSBuZXcgX2ZpbHRlcnNQcmltaXRpdmVzQ29udHJhc3QyWydkZWZhdWx0J10oe1xuICAgICAgICAgIGNvbnRyYXN0OiB0aGlzLl9vcHRpb25zLmNvbnRyYXN0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zdGFjay5hZGQodGhpcy5fcHJpbWl0aXZlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQFRPRE9cbiAgICAgIC8vIFByaW1pdGl2ZXMgc2hvdWxkIGhhdmUgdGhlIHNhbWUgb3B0aW9uIGxvZ2ljIGFzIG9wZXJhdGlvbnMgLSB3aGljaFxuICAgICAgLy8gc2hvdWxkIGFsbG93IHVzIHRvIGRvIGB0aGlzLl9wcmltaXRpdmUuc2V0Q29udHJhc3RgXG4gICAgICB0aGlzLl9wcmltaXRpdmUub3B0aW9ucy5jb250cmFzdCA9IHRoaXMuX29wdGlvbnMuY29udHJhc3Q7XG4gICAgICB0aGlzLl9zdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDb250cmFzdE9wZXJhdGlvbjtcbn0pKF9vcGVyYXRpb24yWydkZWZhdWx0J10pO1xuXG5Db250cmFzdE9wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdjb250cmFzdCc7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkNvbnRyYXN0T3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBjb250cmFzdDogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAxLjAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ29udHJhc3RPcGVyYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9jb250cmFzdC1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA0OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9vcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcGVyYXRpb24pO1xuXG52YXIgX2ZpbHRlcnNQcmltaXRpdmVzU3RhY2sgPSByZXF1aXJlKCcuL2ZpbHRlcnMvcHJpbWl0aXZlcy1zdGFjaycpO1xuXG52YXIgX2ZpbHRlcnNQcmltaXRpdmVzU3RhY2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyc1ByaW1pdGl2ZXNTdGFjayk7XG5cbnZhciBfZmlsdGVyc1ByaW1pdGl2ZXNCcmlnaHRuZXNzID0gcmVxdWlyZSgnLi9maWx0ZXJzL3ByaW1pdGl2ZXMvYnJpZ2h0bmVzcycpO1xuXG52YXIgX2ZpbHRlcnNQcmltaXRpdmVzQnJpZ2h0bmVzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXJzUHJpbWl0aXZlc0JyaWdodG5lc3MpO1xuXG4vKipcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuQnJpZ2h0bmVzc09wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cblxudmFyIEJyaWdodG5lc3NPcGVyYXRpb24gPSAoZnVuY3Rpb24gKF9PcGVyYXRpb24pIHtcbiAgX2luaGVyaXRzKEJyaWdodG5lc3NPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIEJyaWdodG5lc3NPcGVyYXRpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyaWdodG5lc3NPcGVyYXRpb24pO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJpZ2h0bmVzc09wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoQnJpZ2h0bmVzc09wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYnJpZ2h0bmVzcyB1c2luZyBXZWJHTFxuICAgICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLl9yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGJyaWdodG5lc3MgdXNpbmcgQ2FudmFzMkRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMuX3JlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYnJpZ2h0bmVzcyAoYWxsIHJlbmRlcmVycyBzdXBwb3J0ZWQpXG4gICAgICogQHBhcmFtIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIGlmICghdGhpcy5fc3RhY2spIHtcbiAgICAgICAgdGhpcy5fc3RhY2sgPSBuZXcgX2ZpbHRlcnNQcmltaXRpdmVzU3RhY2syWydkZWZhdWx0J10oKTtcbiAgICAgICAgdGhpcy5fcHJpbWl0aXZlID0gbmV3IF9maWx0ZXJzUHJpbWl0aXZlc0JyaWdodG5lc3MyWydkZWZhdWx0J10oe1xuICAgICAgICAgIGJyaWdodG5lc3M6IHRoaXMuX29wdGlvbnMuYnJpZ2h0bmVzc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc3RhY2suYWRkKHRoaXMuX3ByaW1pdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEBUT0RPXG4gICAgICAvLyBQcmltaXRpdmVzIHNob3VsZCBoYXZlIHRoZSBzYW1lIG9wdGlvbiBsb2dpYyBhcyBvcGVyYXRpb25zIC0gd2hpY2hcbiAgICAgIC8vIHNob3VsZCBhbGxvdyB1cyB0byBkbyBgdGhpcy5fcHJpbWl0aXZlLnNldEJyaWdodG5lc3NgXG4gICAgICB0aGlzLl9wcmltaXRpdmUub3B0aW9ucy5icmlnaHRuZXNzID0gdGhpcy5fb3B0aW9ucy5icmlnaHRuZXNzO1xuICAgICAgdGhpcy5fc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnJpZ2h0bmVzc09wZXJhdGlvbjtcbn0pKF9vcGVyYXRpb24yWydkZWZhdWx0J10pO1xuXG5CcmlnaHRuZXNzT3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ2JyaWdodG5lc3MnO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5CcmlnaHRuZXNzT3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBicmlnaHRuZXNzOiB7IHR5cGU6ICdudW1iZXInLCAnZGVmYXVsdCc6IDAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQnJpZ2h0bmVzc09wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2JyaWdodG5lc3Mtb3BlcmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX3NldCA9IGZ1bmN0aW9uIHNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCAhPT0gbnVsbCkgeyBzZXQocGFyZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYyAmJiBkZXNjLndyaXRhYmxlKSB7IGRlc2MudmFsdWUgPSB2YWx1ZTsgfSBlbHNlIHsgdmFyIHNldHRlciA9IGRlc2Muc2V0OyBpZiAoc2V0dGVyICE9PSB1bmRlZmluZWQpIHsgc2V0dGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTsgfSB9IHJldHVybiB2YWx1ZTsgfTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX29wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG5cbnZhciBfb3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX3ZlbmRvclN0YWNrQmx1ciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9zdGFjay1ibHVyJyk7XG5cbnZhciBfdmVuZG9yU3RhY2tCbHVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlbmRvclN0YWNrQmx1cik7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGNyb3Agb3V0IGEgcGFydCBvZiB0aGUgaW1hZ2VcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlRpbHRTaGlmdE9wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cblxudmFyIFRpbHRTaGlmdE9wZXJhdGlvbiA9IChmdW5jdGlvbiAoX09wZXJhdGlvbikge1xuICBfaW5oZXJpdHMoVGlsdFNoaWZ0T3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBUaWx0U2hpZnRPcGVyYXRpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRpbHRTaGlmdE9wZXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUaWx0U2hpZnRPcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQGludGVybmFsIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcbiAgICAgKiAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanNcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9ICdcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgYmx1clJhZGl1cztcXG4gICAgICB1bmlmb3JtIGZsb2F0IGdyYWRpZW50UmFkaXVzO1xcbiAgICAgIHVuaWZvcm0gdmVjMiBzdGFydDtcXG4gICAgICB1bmlmb3JtIHZlYzIgZW5kO1xcbiAgICAgIHVuaWZvcm0gdmVjMiBkZWx0YTtcXG4gICAgICB1bmlmb3JtIHZlYzIgdGV4U2l6ZTtcXG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG5cXG4gICAgICBmbG9hdCByYW5kb20odmVjMyBzY2FsZSwgZmxvYXQgc2VlZCkge1xcbiAgICAgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoZ2xfRnJhZ0Nvb3JkLnh5eiArIHNlZWQsIHNjYWxlKSkgKiA0Mzc1OC41NDUzICsgc2VlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgdmVjNCBjb2xvciA9IHZlYzQoMC4wKTtcXG4gICAgICAgICAgZmxvYXQgdG90YWwgPSAwLjA7XFxuXFxuICAgICAgICAgIGZsb2F0IG9mZnNldCA9IHJhbmRvbSh2ZWMzKDEyLjk4OTgsIDc4LjIzMywgMTUxLjcxODIpLCAwLjApO1xcblxcbiAgICAgICAgICB2ZWMyIG5vcm1hbCA9IG5vcm1hbGl6ZSh2ZWMyKHN0YXJ0LnkgLSBlbmQueSwgZW5kLnggLSBzdGFydC54KSk7XFxuICAgICAgICAgIGZsb2F0IHJhZGl1cyA9IHNtb290aHN0ZXAoMC4wLCAxLjAsIGFicyhkb3Qodl90ZXhDb29yZCAqIHRleFNpemUgLSBzdGFydCwgbm9ybWFsKSkgLyBncmFkaWVudFJhZGl1cykgKiBibHVyUmFkaXVzO1xcbiAgICAgICAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIGRlbHRhICogcGVyY2VudCAqIHJhZGl1cyAvIHRleFNpemUpO1xcblxcbiAgICAgICAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICB0aGlzLl9jYWNoZWRCbHVycmVkQ2FudmFzID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cztcbiAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoVGlsdFNoaWZ0T3BlcmF0aW9uLCBbe1xuICAgIGtleTogJ19yZW5kZXJXZWJHTCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJXZWJHTChyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKTtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgc3RhcnQubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICAgIGVuZC5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIH1cblxuICAgICAgc3RhcnQueSA9IGNhbnZhc1NpemUueSAtIHN0YXJ0Lnk7XG4gICAgICBlbmQueSA9IGNhbnZhc1NpemUueSAtIGVuZC55O1xuXG4gICAgICB2YXIgZGVsdGEgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydCk7XG4gICAgICB2YXIgZCA9IE1hdGguc3FydChkZWx0YS54ICogZGVsdGEueCArIGRlbHRhLnkgKiBkZWx0YS55KTtcblxuICAgICAgdmFyIHVuaWZvcm1zID0ge1xuICAgICAgICBibHVyUmFkaXVzOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyB9LFxuICAgICAgICBncmFkaWVudFJhZGl1czogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzIH0sXG4gICAgICAgIHN0YXJ0OiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbc3RhcnQueCwgc3RhcnQueV0gfSxcbiAgICAgICAgZW5kOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbZW5kLngsIGVuZC55XSB9LFxuICAgICAgICBkZWx0YTogeyB0eXBlOiAnMmYnLCB2YWx1ZTogW2RlbHRhLnggLyBkLCBkZWx0YS55IC8gZF0gfSxcbiAgICAgICAgdGV4U2l6ZTogeyB0eXBlOiAnMmYnLCB2YWx1ZTogW2NhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF0gfVxuICAgICAgfTtcblxuICAgICAgaWYgKCF0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdKSB7XG4gICAgICAgIHRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0gPSByZW5kZXJlci5zZXR1cEdMU0xQcm9ncmFtKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cblxuICAgICAgcmVuZGVyZXIucnVuUHJvZ3JhbSh0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdLCB7IHVuaWZvcm1zOiB1bmlmb3JtcyB9KTtcblxuICAgICAgLy8gVXBkYXRlIGRlbHRhIGZvciBzZWNvbmQgcGFzc1xuICAgICAgdW5pZm9ybXMuZGVsdGEudmFsdWUgPSBbLWRlbHRhLnkgLyBkLCBkZWx0YS54IC8gZF07XG5cbiAgICAgIHJlbmRlcmVyLnJ1blByb2dyYW0odGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSwgeyB1bmlmb3JtczogdW5pZm9ybXMgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuXG4gICAgICB2YXIgb3B0aW9uc0NoYW5nZWQgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMgIT09IHRoaXMuX2xhc3RCbHVyUmFkaXVzIHx8IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXMgIT09IHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cztcbiAgICAgIHZhciBibHVycnlDYW52YXMgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAob3B0aW9uc0NoYW5nZWQgfHwgdGhpcy5fY2FjaGVkQmx1cnJlZENhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBCbHVyIGFuZCBjYWNoZSBjYW52YXNcbiAgICAgICAgYmx1cnJ5Q2FudmFzID0gdGhpcy5fYmx1ckNhbnZhcyhyZW5kZXJlcik7XG4gICAgICAgIHRoaXMuX2NhY2hlZEJsdXJyZWRDYW52YXMgPSBibHVycnlDYW52YXM7XG4gICAgICAgIHRoaXMuX2xhc3RCbHVyUmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ibHVyUmFkaXVzO1xuICAgICAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXNlIGNhY2hlZCBjYW52YXNcbiAgICAgICAgYmx1cnJ5Q2FudmFzID0gdGhpcy5fY2FjaGVkQmx1cnJlZENhbnZhcztcbiAgICAgIH1cblxuICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLl9jcmVhdGVNYXNrKHJlbmRlcmVyKTtcblxuICAgICAgdGhpcy5fYXBwbHlNYXNrKGNhbnZhcywgYmx1cnJ5Q2FudmFzLCBtYXNrQ2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmx1cnJlZCBjb3B5IG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtDYW52YXN9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19ibHVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JsdXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHZhciBuZXdDYW52YXMgPSByZW5kZXJlci5jbG9uZUNhbnZhcygpO1xuICAgICAgdmFyIGJsdXJyeUNvbnRleHQgPSBuZXdDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBibHVycnlJbWFnZURhdGEgPSBibHVycnlDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBuZXdDYW52YXMud2lkdGgsIG5ld0NhbnZhcy5oZWlnaHQpO1xuICAgICAgX3ZlbmRvclN0YWNrQmx1cjJbJ2RlZmF1bHQnXS5zdGFja0JsdXJDYW52YXNSR0JBKGJsdXJyeUltYWdlRGF0YSwgMCwgMCwgbmV3Q2FudmFzLndpZHRoLCBuZXdDYW52YXMuaGVpZ2h0LCB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMpO1xuICAgICAgYmx1cnJ5Q29udGV4dC5wdXRJbWFnZURhdGEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwKTtcblxuICAgICAgcmV0dXJuIG5ld0NhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYXNrIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2NyZWF0ZU1hc2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlTWFzayhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuXG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBncmFkaWVudFJhZGl1cyA9IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXM7XG5cbiAgICAgIHZhciBtYXNrQ2FudmFzID0gcmVuZGVyZXIuY3JlYXRlQ2FudmFzKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29wdGlvbnMuc3RhcnQuY2xvbmUoKTtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vcHRpb25zLmVuZC5jbG9uZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgc3RhcnQubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICAgIGVuZC5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3QgPSBlbmQuY2xvbmUoKS5zdWJ0cmFjdChzdGFydCk7XG4gICAgICB2YXIgbWlkZGxlID0gc3RhcnQuY2xvbmUoKS5hZGQoZGlzdC5jbG9uZSgpLmRpdmlkZSgyKSk7XG5cbiAgICAgIHZhciB0b3RhbERpc3QgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlzdC54LCAyKSArIE1hdGgucG93KGRpc3QueSwgMikpO1xuICAgICAgdmFyIGZhY3RvciA9IGRpc3QuY2xvbmUoKS5kaXZpZGUodG90YWxEaXN0KTtcblxuICAgICAgdmFyIGdyYWRpZW50U3RhcnQgPSBtaWRkbGUuY2xvbmUoKS5hZGQoZ3JhZGllbnRSYWRpdXMgKiBmYWN0b3IueSwgLWdyYWRpZW50UmFkaXVzICogZmFjdG9yLngpO1xuICAgICAgdmFyIGdyYWRpZW50RW5kID0gbWlkZGxlLmNsb25lKCkuYWRkKC1ncmFkaWVudFJhZGl1cyAqIGZhY3Rvci55LCBncmFkaWVudFJhZGl1cyAqIGZhY3Rvci54KTtcblxuICAgICAgLy8gQnVpbGQgZ3JhZGllbnRcbiAgICAgIHZhciBncmFkaWVudCA9IG1hc2tDb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KGdyYWRpZW50U3RhcnQueCwgZ3JhZGllbnRTdGFydC55LCBncmFkaWVudEVuZC54LCBncmFkaWVudEVuZC55KTtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnIzAwMDAwMCcpO1xuICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgJyNGRkZGRkYnKTtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzAwMDAwMCcpO1xuXG4gICAgICAvLyBEcmF3IGdyYWRpZW50XG4gICAgICBtYXNrQ29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIG1hc2tDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHJldHVybiBtYXNrQ2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGJsdXIgYW5kIG1hc2sgdG8gdGhlIGlucHV0IGNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc30gaW5wdXRDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtDYW52YXN9IGJsdXJyeUNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc30gbWFza0NhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfYXBwbHlNYXNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5TWFzayhpbnB1dENhbnZhcywgYmx1cnJ5Q2FudmFzLCBtYXNrQ2FudmFzKSB7XG4gICAgICB2YXIgaW5wdXRDb250ZXh0ID0gaW5wdXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBibHVycnlDb250ZXh0ID0gYmx1cnJ5Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgcGl4ZWxzID0gaW5wdXRJbWFnZURhdGEuZGF0YTtcbiAgICAgIHZhciBibHVycnlQaXhlbHMgPSBibHVycnlDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgdmFyIG1hc2tQaXhlbHMgPSBtYXNrQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCkuZGF0YTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXNrUGl4ZWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBhbHBoYSA9IG1hc2tQaXhlbHNbaV0gLyAyNTU7XG4gICAgICAgIHBpeGVsc1tpXSA9IGFscGhhICogcGl4ZWxzW2ldICsgKDEgLSBhbHBoYSkgKiBibHVycnlQaXhlbHNbaV07XG4gICAgICB9XG5cbiAgICAgIGlucHV0Q29udGV4dC5wdXRJbWFnZURhdGEoaW5wdXRJbWFnZURhdGEsIDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRpcnR5IHN0YXRlIG9mIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkaXJ0eVxuICAgICAqIEBjb21tZW50IFNpbmNlIGJsdXIgb3BlcmF0aW9ucyBkbyBzZXBlcmF0ZSBjYWNoaW5nIG9mIHRoZVxuICAgICAqICAgICAgICAgIGJsdXJyZWQgY2FudmFzLCB3ZSBuZWVkIHRvIGludmFsaWRhdGUgdGhlIGNhY2hlIHdoZW4gdGhlXG4gICAgICogICAgICAgICAgZGlydHkgc3RhdGUgY2hhbmdlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2RpcnR5JyxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChkaXJ0eSkge1xuICAgICAgX3NldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGlsdFNoaWZ0T3BlcmF0aW9uLnByb3RvdHlwZSksICdkaXJ0eScsIGRpcnR5LCB0aGlzKTtcbiAgICAgIHRoaXMuX2NhY2hlZEJsdXJyZWRDYW52YXMgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXJ0eSBzdGF0ZVxuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbHRTaGlmdE9wZXJhdGlvbi5wcm90b3R5cGUpLCAnZGlydHknLCB0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGlsdFNoaWZ0T3BlcmF0aW9uO1xufSkoX29wZXJhdGlvbjJbJ2RlZmF1bHQnXSk7XG5cblRpbHRTaGlmdE9wZXJhdGlvbi5wcm90b3R5cGUuaWRlbnRpZmllciA9ICd0aWx0LXNoaWZ0JztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuVGlsdFNoaWZ0T3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBzdGFydDogeyB0eXBlOiAndmVjdG9yMicsICdkZWZhdWx0JzogbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLjAsIDAuNSkgfSxcbiAgZW5kOiB7IHR5cGU6ICd2ZWN0b3IyJywgJ2RlZmF1bHQnOiBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDEuMCwgMC41KSB9LFxuICBibHVyUmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCAnZGVmYXVsdCc6IDMwIH0sXG4gIGdyYWRpZW50UmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCAnZGVmYXVsdCc6IDUwIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFRpbHRTaGlmdE9wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL3RpbHQtc2hpZnQtb3BlcmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIlwidXNlIHN0cmljdFwiO1xuLyohXG5cblN0YWNrQmx1ciAtIGEgZmFzdCBhbG1vc3QgR2F1c3NpYW4gQmx1ciBGb3IgQ2FudmFzXG5cblZlcnNpb246ICAwLjVcbkF1dGhvcjogICBNYXJpbyBLbGluZ2VtYW5uXG5Db250YWN0OiAgbWFyaW9AcXVhc2ltb25kby5jb21cbldlYnNpdGU6ICBodHRwOi8vd3d3LnF1YXNpbW9uZG8uY29tL1N0YWNrQmx1ckZvckNhbnZhc1xuVHdpdHRlcjogIEBxdWFzaW1vbmRvXG5cbkluIGNhc2UgeW91IGZpbmQgdGhpcyBjbGFzcyB1c2VmdWwgLSBlc3BlY2lhbGx5IGluIGNvbW1lcmNpYWwgcHJvamVjdHMgLVxuSSBhbSBub3QgdG90YWxseSB1bmhhcHB5IGZvciBhIHNtYWxsIGRvbmF0aW9uIHRvIG15IFBheVBhbCBhY2NvdW50XG5tYXJpb0BxdWFzaW1vbmRvLmRlXG5cbk9yIHN1cHBvcnQgbWUgb24gZmxhdHRyOlxuaHR0cHM6Ly9mbGF0dHIuY29tL3RoaW5nLzcyNzkxL1N0YWNrQmx1ci1hLWZhc3QtYWxtb3N0LUdhdXNzaWFuLUJsdXItRWZmZWN0LWZvci1DYW52YXNKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoYykgMjAxMCBNYXJpbyBLbGluZ2VtYW5uXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG5vYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG5yZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbmNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcblNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG5jb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcbk9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG5OT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxuSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXG5XSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbkZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1Jcbk9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbiovXG5cbnZhciBtdWxfdGFibGUgPSBbNTEyLCA1MTIsIDQ1NiwgNTEyLCAzMjgsIDQ1NiwgMzM1LCA1MTIsIDQwNSwgMzI4LCAyNzEsIDQ1NiwgMzg4LCAzMzUsIDI5MiwgNTEyLCA0NTQsIDQwNSwgMzY0LCAzMjgsIDI5OCwgMjcxLCA0OTYsIDQ1NiwgNDIwLCAzODgsIDM2MCwgMzM1LCAzMTIsIDI5MiwgMjczLCA1MTIsIDQ4MiwgNDU0LCA0MjgsIDQwNSwgMzgzLCAzNjQsIDM0NSwgMzI4LCAzMTIsIDI5OCwgMjg0LCAyNzEsIDI1OSwgNDk2LCA0NzUsIDQ1NiwgNDM3LCA0MjAsIDQwNCwgMzg4LCAzNzQsIDM2MCwgMzQ3LCAzMzUsIDMyMywgMzEyLCAzMDIsIDI5MiwgMjgyLCAyNzMsIDI2NSwgNTEyLCA0OTcsIDQ4MiwgNDY4LCA0NTQsIDQ0MSwgNDI4LCA0MTcsIDQwNSwgMzk0LCAzODMsIDM3MywgMzY0LCAzNTQsIDM0NSwgMzM3LCAzMjgsIDMyMCwgMzEyLCAzMDUsIDI5OCwgMjkxLCAyODQsIDI3OCwgMjcxLCAyNjUsIDI1OSwgNTA3LCA0OTYsIDQ4NSwgNDc1LCA0NjUsIDQ1NiwgNDQ2LCA0MzcsIDQyOCwgNDIwLCA0MTIsIDQwNCwgMzk2LCAzODgsIDM4MSwgMzc0LCAzNjcsIDM2MCwgMzU0LCAzNDcsIDM0MSwgMzM1LCAzMjksIDMyMywgMzE4LCAzMTIsIDMwNywgMzAyLCAyOTcsIDI5MiwgMjg3LCAyODIsIDI3OCwgMjczLCAyNjksIDI2NSwgMjYxLCA1MTIsIDUwNSwgNDk3LCA0ODksIDQ4MiwgNDc1LCA0NjgsIDQ2MSwgNDU0LCA0NDcsIDQ0MSwgNDM1LCA0MjgsIDQyMiwgNDE3LCA0MTEsIDQwNSwgMzk5LCAzOTQsIDM4OSwgMzgzLCAzNzgsIDM3MywgMzY4LCAzNjQsIDM1OSwgMzU0LCAzNTAsIDM0NSwgMzQxLCAzMzcsIDMzMiwgMzI4LCAzMjQsIDMyMCwgMzE2LCAzMTIsIDMwOSwgMzA1LCAzMDEsIDI5OCwgMjk0LCAyOTEsIDI4NywgMjg0LCAyODEsIDI3OCwgMjc0LCAyNzEsIDI2OCwgMjY1LCAyNjIsIDI1OSwgMjU3LCA1MDcsIDUwMSwgNDk2LCA0OTEsIDQ4NSwgNDgwLCA0NzUsIDQ3MCwgNDY1LCA0NjAsIDQ1NiwgNDUxLCA0NDYsIDQ0MiwgNDM3LCA0MzMsIDQyOCwgNDI0LCA0MjAsIDQxNiwgNDEyLCA0MDgsIDQwNCwgNDAwLCAzOTYsIDM5MiwgMzg4LCAzODUsIDM4MSwgMzc3LCAzNzQsIDM3MCwgMzY3LCAzNjMsIDM2MCwgMzU3LCAzNTQsIDM1MCwgMzQ3LCAzNDQsIDM0MSwgMzM4LCAzMzUsIDMzMiwgMzI5LCAzMjYsIDMyMywgMzIwLCAzMTgsIDMxNSwgMzEyLCAzMTAsIDMwNywgMzA0LCAzMDIsIDI5OSwgMjk3LCAyOTQsIDI5MiwgMjg5LCAyODcsIDI4NSwgMjgyLCAyODAsIDI3OCwgMjc1LCAyNzMsIDI3MSwgMjY5LCAyNjcsIDI2NSwgMjYzLCAyNjEsIDI1OV07XG5cbnZhciBzaGdfdGFibGUgPSBbOSwgMTEsIDEyLCAxMywgMTMsIDE0LCAxNCwgMTUsIDE1LCAxNSwgMTUsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTgsIDE4LCAxOCwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMCwgMjAsIDIwLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMSwgMjEsIDIxLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjIsIDIyLCAyMiwgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjMsIDIzLCAyMywgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0LCAyNCwgMjQsIDI0XTtcblxuZnVuY3Rpb24gc3RhY2tCbHVyQ2FudmFzUkdCQShpbWFnZURhdGEsIHRvcF94LCB0b3BfeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzKSB7XG4gIGlmIChpc05hTihyYWRpdXMpIHx8IHJhZGl1cyA8IDEpIHJldHVybjtcbiAgcmFkaXVzIHw9IDA7XG5cbiAgdmFyIHBpeGVscyA9IGltYWdlRGF0YS5kYXRhO1xuXG4gIHZhciB4LCB5LCBpLCBwLCB5cCwgeWksIHl3LCByX3N1bSwgZ19zdW0sIGJfc3VtLCBhX3N1bSwgcl9vdXRfc3VtLCBnX291dF9zdW0sIGJfb3V0X3N1bSwgYV9vdXRfc3VtLCByX2luX3N1bSwgZ19pbl9zdW0sIGJfaW5fc3VtLCBhX2luX3N1bSwgcHIsIHBnLCBwYiwgcGEsIHJicztcblxuICB2YXIgZGl2ID0gcmFkaXVzICsgcmFkaXVzICsgMTtcbiAgdmFyIHdpZHRoTWludXMxID0gd2lkdGggLSAxO1xuICB2YXIgaGVpZ2h0TWludXMxID0gaGVpZ2h0IC0gMTtcbiAgdmFyIHJhZGl1c1BsdXMxID0gcmFkaXVzICsgMTtcbiAgdmFyIHN1bUZhY3RvciA9IHJhZGl1c1BsdXMxICogKHJhZGl1c1BsdXMxICsgMSkgLyAyO1xuXG4gIHZhciBzdGFja1N0YXJ0ID0gbmV3IEJsdXJTdGFjaygpO1xuICB2YXIgc3RhY2tFbmQ7XG4gIHZhciBzdGFjayA9IHN0YWNrU3RhcnQ7XG4gIGZvciAoaSA9IDE7IGkgPCBkaXY7IGkrKykge1xuICAgIHN0YWNrID0gc3RhY2submV4dCA9IG5ldyBCbHVyU3RhY2soKTtcbiAgICBpZiAoaSA9PSByYWRpdXNQbHVzMSkgc3RhY2tFbmQgPSBzdGFjaztcbiAgfVxuICBzdGFjay5uZXh0ID0gc3RhY2tTdGFydDtcbiAgdmFyIHN0YWNrSW4gPSBudWxsO1xuICB2YXIgc3RhY2tPdXQgPSBudWxsO1xuXG4gIHl3ID0geWkgPSAwO1xuXG4gIHZhciBtdWxfc3VtID0gbXVsX3RhYmxlW3JhZGl1c107XG4gIHZhciBzaGdfc3VtID0gc2hnX3RhYmxlW3JhZGl1c107XG5cbiAgZm9yICh5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgcl9pbl9zdW0gPSBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IDA7XG5cbiAgICByX291dF9zdW0gPSByYWRpdXNQbHVzMSAqIChwciA9IHBpeGVsc1t5aV0pO1xuICAgIGdfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBnID0gcGl4ZWxzW3lpICsgMV0pO1xuICAgIGJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBiID0gcGl4ZWxzW3lpICsgMl0pO1xuICAgIGFfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHBhID0gcGl4ZWxzW3lpICsgM10pO1xuXG4gICAgcl9zdW0gKz0gc3VtRmFjdG9yICogcHI7XG4gICAgZ19zdW0gKz0gc3VtRmFjdG9yICogcGc7XG4gICAgYl9zdW0gKz0gc3VtRmFjdG9yICogcGI7XG4gICAgYV9zdW0gKz0gc3VtRmFjdG9yICogcGE7XG5cbiAgICBzdGFjayA9IHN0YWNrU3RhcnQ7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcmFkaXVzUGx1czE7IGkrKykge1xuICAgICAgc3RhY2suciA9IHByO1xuICAgICAgc3RhY2suZyA9IHBnO1xuICAgICAgc3RhY2suYiA9IHBiO1xuICAgICAgc3RhY2suYSA9IHBhO1xuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIGZvciAoaSA9IDE7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG4gICAgICBwID0geWkgKyAoKHdpZHRoTWludXMxIDwgaSA/IHdpZHRoTWludXMxIDogaSkgPDwgMik7XG4gICAgICByX3N1bSArPSAoc3RhY2suciA9IHByID0gcGl4ZWxzW3BdKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSBwZyA9IHBpeGVsc1twICsgMV0pICogcmJzO1xuICAgICAgYl9zdW0gKz0gKHN0YWNrLmIgPSBwYiA9IHBpeGVsc1twICsgMl0pICogcmJzO1xuICAgICAgYV9zdW0gKz0gKHN0YWNrLmEgPSBwYSA9IHBpeGVsc1twICsgM10pICogcmJzO1xuXG4gICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuICAgIH1cblxuICAgIHN0YWNrSW4gPSBzdGFja1N0YXJ0O1xuICAgIHN0YWNrT3V0ID0gc3RhY2tFbmQ7XG4gICAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgIHBpeGVsc1t5aSArIDNdID0gcGEgPSBhX3N1bSAqIG11bF9zdW0gPj4gc2hnX3N1bTtcbiAgICAgIGlmIChwYSAhPT0gMCkge1xuICAgICAgICBwYSA9IDI1NSAvIHBhO1xuICAgICAgICBwaXhlbHNbeWldID0gKHJfc3VtICogbXVsX3N1bSA+PiBzaGdfc3VtKSAqIHBhO1xuICAgICAgICBwaXhlbHNbeWkgKyAxXSA9IChnX3N1bSAqIG11bF9zdW0gPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3lpICsgMl0gPSAoYl9zdW0gKiBtdWxfc3VtID4+IHNoZ19zdW0pICogcGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwaXhlbHNbeWldID0gcGl4ZWxzW3lpICsgMV0gPSBwaXhlbHNbeWkgKyAyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJfc3VtIC09IHJfb3V0X3N1bTtcbiAgICAgIGdfc3VtIC09IGdfb3V0X3N1bTtcbiAgICAgIGJfc3VtIC09IGJfb3V0X3N1bTtcbiAgICAgIGFfc3VtIC09IGFfb3V0X3N1bTtcblxuICAgICAgcl9vdXRfc3VtIC09IHN0YWNrSW4ucjtcbiAgICAgIGdfb3V0X3N1bSAtPSBzdGFja0luLmc7XG4gICAgICBiX291dF9zdW0gLT0gc3RhY2tJbi5iO1xuICAgICAgYV9vdXRfc3VtIC09IHN0YWNrSW4uYTtcblxuICAgICAgcCA9IHl3ICsgKChwID0geCArIHJhZGl1cyArIDEpIDwgd2lkdGhNaW51czEgPyBwIDogd2lkdGhNaW51czEpIDw8IDI7XG5cbiAgICAgIHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgIGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcblxuICAgICAgcl9zdW0gKz0gcl9pbl9zdW07XG4gICAgICBnX3N1bSArPSBnX2luX3N1bTtcbiAgICAgIGJfc3VtICs9IGJfaW5fc3VtO1xuICAgICAgYV9zdW0gKz0gYV9pbl9zdW07XG5cbiAgICAgIHN0YWNrSW4gPSBzdGFja0luLm5leHQ7XG5cbiAgICAgIHJfb3V0X3N1bSArPSBwciA9IHN0YWNrT3V0LnI7XG4gICAgICBnX291dF9zdW0gKz0gcGcgPSBzdGFja091dC5nO1xuICAgICAgYl9vdXRfc3VtICs9IHBiID0gc3RhY2tPdXQuYjtcbiAgICAgIGFfb3V0X3N1bSArPSBwYSA9IHN0YWNrT3V0LmE7XG5cbiAgICAgIHJfaW5fc3VtIC09IHByO1xuICAgICAgZ19pbl9zdW0gLT0gcGc7XG4gICAgICBiX2luX3N1bSAtPSBwYjtcbiAgICAgIGFfaW5fc3VtIC09IHBhO1xuXG4gICAgICBzdGFja091dCA9IHN0YWNrT3V0Lm5leHQ7XG5cbiAgICAgIHlpICs9IDQ7XG4gICAgfVxuICAgIHl3ICs9IHdpZHRoO1xuICB9XG5cbiAgZm9yICh4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICBnX2luX3N1bSA9IGJfaW5fc3VtID0gYV9pbl9zdW0gPSByX2luX3N1bSA9IGdfc3VtID0gYl9zdW0gPSBhX3N1bSA9IHJfc3VtID0gMDtcblxuICAgIHlpID0geCA8PCAyO1xuICAgIHJfb3V0X3N1bSA9IHJhZGl1c1BsdXMxICogKHByID0gcGl4ZWxzW3lpXSk7XG4gICAgZ19vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGcgPSBwaXhlbHNbeWkgKyAxXSk7XG4gICAgYl9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGIgPSBwaXhlbHNbeWkgKyAyXSk7XG4gICAgYV9vdXRfc3VtID0gcmFkaXVzUGx1czEgKiAocGEgPSBwaXhlbHNbeWkgKyAzXSk7XG5cbiAgICByX3N1bSArPSBzdW1GYWN0b3IgKiBwcjtcbiAgICBnX3N1bSArPSBzdW1GYWN0b3IgKiBwZztcbiAgICBiX3N1bSArPSBzdW1GYWN0b3IgKiBwYjtcbiAgICBhX3N1bSArPSBzdW1GYWN0b3IgKiBwYTtcblxuICAgIHN0YWNrID0gc3RhY2tTdGFydDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCByYWRpdXNQbHVzMTsgaSsrKSB7XG4gICAgICBzdGFjay5yID0gcHI7XG4gICAgICBzdGFjay5nID0gcGc7XG4gICAgICBzdGFjay5iID0gcGI7XG4gICAgICBzdGFjay5hID0gcGE7XG4gICAgICBzdGFjayA9IHN0YWNrLm5leHQ7XG4gICAgfVxuXG4gICAgeXAgPSB3aWR0aDtcblxuICAgIGZvciAoaSA9IDE7IGkgPD0gcmFkaXVzOyBpKyspIHtcbiAgICAgIHlpID0geXAgKyB4IDw8IDI7XG5cbiAgICAgIHJfc3VtICs9IChzdGFjay5yID0gcHIgPSBwaXhlbHNbeWldKSAqIChyYnMgPSByYWRpdXNQbHVzMSAtIGkpO1xuICAgICAgZ19zdW0gKz0gKHN0YWNrLmcgPSBwZyA9IHBpeGVsc1t5aSArIDFdKSAqIHJicztcbiAgICAgIGJfc3VtICs9IChzdGFjay5iID0gcGIgPSBwaXhlbHNbeWkgKyAyXSkgKiByYnM7XG4gICAgICBhX3N1bSArPSAoc3RhY2suYSA9IHBhID0gcGl4ZWxzW3lpICsgM10pICogcmJzO1xuXG4gICAgICByX2luX3N1bSArPSBwcjtcbiAgICAgIGdfaW5fc3VtICs9IHBnO1xuICAgICAgYl9pbl9zdW0gKz0gcGI7XG4gICAgICBhX2luX3N1bSArPSBwYTtcblxuICAgICAgc3RhY2sgPSBzdGFjay5uZXh0O1xuXG4gICAgICBpZiAoaSA8IGhlaWdodE1pbnVzMSkge1xuICAgICAgICB5cCArPSB3aWR0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB5aSA9IHg7XG4gICAgc3RhY2tJbiA9IHN0YWNrU3RhcnQ7XG4gICAgc3RhY2tPdXQgPSBzdGFja0VuZDtcbiAgICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgIHAgPSB5aSA8PCAyO1xuICAgICAgcGl4ZWxzW3AgKyAzXSA9IHBhID0gYV9zdW0gKiBtdWxfc3VtID4+IHNoZ19zdW07XG4gICAgICBpZiAocGEgPiAwKSB7XG4gICAgICAgIHBhID0gMjU1IC8gcGE7XG4gICAgICAgIHBpeGVsc1twXSA9IChyX3N1bSAqIG11bF9zdW0gPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3AgKyAxXSA9IChnX3N1bSAqIG11bF9zdW0gPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgICAgcGl4ZWxzW3AgKyAyXSA9IChiX3N1bSAqIG11bF9zdW0gPj4gc2hnX3N1bSkgKiBwYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBpeGVsc1twXSA9IHBpeGVsc1twICsgMV0gPSBwaXhlbHNbcCArIDJdID0gMDtcbiAgICAgIH1cblxuICAgICAgcl9zdW0gLT0gcl9vdXRfc3VtO1xuICAgICAgZ19zdW0gLT0gZ19vdXRfc3VtO1xuICAgICAgYl9zdW0gLT0gYl9vdXRfc3VtO1xuICAgICAgYV9zdW0gLT0gYV9vdXRfc3VtO1xuXG4gICAgICByX291dF9zdW0gLT0gc3RhY2tJbi5yO1xuICAgICAgZ19vdXRfc3VtIC09IHN0YWNrSW4uZztcbiAgICAgIGJfb3V0X3N1bSAtPSBzdGFja0luLmI7XG4gICAgICBhX291dF9zdW0gLT0gc3RhY2tJbi5hO1xuXG4gICAgICBwID0geCArICgocCA9IHkgKyByYWRpdXNQbHVzMSkgPCBoZWlnaHRNaW51czEgPyBwIDogaGVpZ2h0TWludXMxKSAqIHdpZHRoIDw8IDI7XG5cbiAgICAgIHJfc3VtICs9IHJfaW5fc3VtICs9IHN0YWNrSW4uciA9IHBpeGVsc1twXTtcbiAgICAgIGdfc3VtICs9IGdfaW5fc3VtICs9IHN0YWNrSW4uZyA9IHBpeGVsc1twICsgMV07XG4gICAgICBiX3N1bSArPSBiX2luX3N1bSArPSBzdGFja0luLmIgPSBwaXhlbHNbcCArIDJdO1xuICAgICAgYV9zdW0gKz0gYV9pbl9zdW0gKz0gc3RhY2tJbi5hID0gcGl4ZWxzW3AgKyAzXTtcblxuICAgICAgc3RhY2tJbiA9IHN0YWNrSW4ubmV4dDtcblxuICAgICAgcl9vdXRfc3VtICs9IHByID0gc3RhY2tPdXQucjtcbiAgICAgIGdfb3V0X3N1bSArPSBwZyA9IHN0YWNrT3V0Lmc7XG4gICAgICBiX291dF9zdW0gKz0gcGIgPSBzdGFja091dC5iO1xuICAgICAgYV9vdXRfc3VtICs9IHBhID0gc3RhY2tPdXQuYTtcblxuICAgICAgcl9pbl9zdW0gLT0gcHI7XG4gICAgICBnX2luX3N1bSAtPSBwZztcbiAgICAgIGJfaW5fc3VtIC09IHBiO1xuICAgICAgYV9pbl9zdW0gLT0gcGE7XG5cbiAgICAgIHN0YWNrT3V0ID0gc3RhY2tPdXQubmV4dDtcblxuICAgICAgeWkgKz0gd2lkdGg7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIEJsdXJTdGFjaygpIHtcbiAgdGhpcy5yID0gMDtcbiAgdGhpcy5nID0gMDtcbiAgdGhpcy5iID0gMDtcbiAgdGhpcy5hID0gMDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0YWNrQmx1ckNhbnZhc1JHQkE6IHN0YWNrQmx1ckNhbnZhc1JHQkFcbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3ZlbmRvci9zdGFjay1ibHVyLmpzXG4gKiogbW9kdWxlIGlkID0gNTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX3NldCA9IGZ1bmN0aW9uIHNldChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSwgcmVjZWl2ZXIpIHsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCAhPT0gbnVsbCkgeyBzZXQocGFyZW50LCBwcm9wZXJ0eSwgdmFsdWUsIHJlY2VpdmVyKTsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYyAmJiBkZXNjLndyaXRhYmxlKSB7IGRlc2MudmFsdWUgPSB2YWx1ZTsgfSBlbHNlIHsgdmFyIHNldHRlciA9IGRlc2Muc2V0OyBpZiAoc2V0dGVyICE9PSB1bmRlZmluZWQpIHsgc2V0dGVyLmNhbGwocmVjZWl2ZXIsIHZhbHVlKTsgfSB9IHJldHVybiB2YWx1ZTsgfTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX29wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG5cbnZhciBfb3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX3ZlbmRvclN0YWNrQmx1ciA9IHJlcXVpcmUoJy4uL3ZlbmRvci9zdGFjay1ibHVyJyk7XG5cbnZhciBfdmVuZG9yU3RhY2tCbHVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlbmRvclN0YWNrQmx1cik7XG5cbi8qKlxuICogQW4gb3BlcmF0aW9uIHRoYXQgY2FuIGNyb3Agb3V0IGEgcGFydCBvZiB0aGUgaW1hZ2VcbiAqXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5PcGVyYXRpb25zLlJhZGlhbEJsdXJPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBSYWRpYWxCbHVyT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfT3BlcmF0aW9uKSB7XG4gIF9pbmhlcml0cyhSYWRpYWxCbHVyT3BlcmF0aW9uLCBfT3BlcmF0aW9uKTtcblxuICBmdW5jdGlvbiBSYWRpYWxCbHVyT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpYWxCbHVyT3BlcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJhZGlhbEJsdXJPcGVyYXRpb24ucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICogQGludGVybmFsIEJhc2VkIG9uIGV2YW53J3MgZ2xmeC5qcyB0aWx0IHNoaWZ0IHNoYWRlcjpcbiAgICAgKiAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2V2YW53L2dsZnguanMvYmxvYi9tYXN0ZXIvc3JjL2ZpbHRlcnMvYmx1ci90aWx0c2hpZnQuanNcbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9ICdcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgYmx1clJhZGl1cztcXG4gICAgICB1bmlmb3JtIGZsb2F0IGdyYWRpZW50UmFkaXVzO1xcbiAgICAgIHVuaWZvcm0gdmVjMiBwb3NpdGlvbjtcXG4gICAgICB1bmlmb3JtIHZlYzIgZGVsdGE7XFxuICAgICAgdW5pZm9ybSB2ZWMyIHRleFNpemU7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuXFxuICAgICAgZmxvYXQgcmFuZG9tKHZlYzMgc2NhbGUsIGZsb2F0IHNlZWQpIHtcXG4gICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KGdsX0ZyYWdDb29yZC54eXogKyBzZWVkLCBzY2FsZSkpICogNDM3NTguNTQ1MyArIHNlZWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIHZlYzQgY29sb3IgPSB2ZWM0KDAuMCk7XFxuICAgICAgICAgIGZsb2F0IHRvdGFsID0gMC4wO1xcblxcbiAgICAgICAgICBmbG9hdCBvZmZzZXQgPSByYW5kb20odmVjMygxMi45ODk4LCA3OC4yMzMsIDE1MS43MTgyKSwgMC4wKTtcXG4gICAgICAgICAgZmxvYXQgcmFkaXVzID0gc21vb3Roc3RlcCgwLjAsIDEuMCwgYWJzKGRpc3RhbmNlKHZfdGV4Q29vcmQgKiB0ZXhTaXplLCBwb3NpdGlvbikpIC8gKGdyYWRpZW50UmFkaXVzICogMi4wKSkgKiBibHVyUmFkaXVzO1xcbiAgICAgICAgICBmb3IgKGZsb2F0IHQgPSAtMzAuMDsgdCA8PSAzMC4wOyB0KyspIHtcXG4gICAgICAgICAgICAgIGZsb2F0IHBlcmNlbnQgPSAodCArIG9mZnNldCAtIDAuNSkgLyAzMC4wO1xcbiAgICAgICAgICAgICAgZmxvYXQgd2VpZ2h0ID0gMS4wIC0gYWJzKHBlcmNlbnQpO1xcbiAgICAgICAgICAgICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCArIGRlbHRhICogcGVyY2VudCAqIHJhZGl1cyAvIHRleFNpemUpO1xcblxcbiAgICAgICAgICAgICAgc2FtcGxlLnJnYiAqPSBzYW1wbGUuYTtcXG5cXG4gICAgICAgICAgICAgIGNvbG9yICs9IHNhbXBsZSAqIHdlaWdodDtcXG4gICAgICAgICAgICAgIHRvdGFsICs9IHdlaWdodDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvciAvIHRvdGFsO1xcbiAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiIC89IGdsX0ZyYWdDb2xvci5hICsgMC4wMDAwMTtcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICB0aGlzLl9jYWNoZWRCbHVycmVkQ2FudmFzID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0Qmx1clJhZGl1cyA9IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cztcbiAgICB0aGlzLl9sYXN0R3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoUmFkaWFsQmx1ck9wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCk7XG4gICAgICBwb3NpdGlvbi55ID0gMSAtIHBvc2l0aW9uLnk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICBwb3NpdGlvbi5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHVuaWZvcm1zID0ge1xuICAgICAgICBibHVyUmFkaXVzOiB7IHR5cGU6ICdmJywgdmFsdWU6IHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyB9LFxuICAgICAgICBncmFkaWVudFJhZGl1czogeyB0eXBlOiAnZicsIHZhbHVlOiB0aGlzLl9vcHRpb25zLmdyYWRpZW50UmFkaXVzIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbcG9zaXRpb24ueCwgcG9zaXRpb24ueV0gfSxcbiAgICAgICAgdGV4U2l6ZTogeyB0eXBlOiAnMmYnLCB2YWx1ZTogW2NhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodF0gfSxcbiAgICAgICAgZGVsdGE6IHsgdHlwZTogJzJmJywgdmFsdWU6IFsxLCAxXSB9XG4gICAgICB9O1xuXG4gICAgICAvLyBTZXR1cCBwcm9ncmFtXG4gICAgICBpZiAoIXRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0pIHtcbiAgICAgICAgdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSA9IHJlbmRlcmVyLnNldHVwR0xTTFByb2dyYW0obnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIpO1xuICAgICAgfVxuXG4gICAgICByZW5kZXJlci5ydW5Qcm9ncmFtKHRoaXMuX2dsc2xQcm9ncmFtc1tyZW5kZXJlci5pZF0sIHsgdW5pZm9ybXM6IHVuaWZvcm1zIH0pO1xuXG4gICAgICAvLyBVcGRhdGUgZGVsdGEgZm9yIHNlY29uZCBwYXNzXG4gICAgICB1bmlmb3Jtcy5kZWx0YS52YWx1ZSA9IFstMSwgMV07XG5cbiAgICAgIHJlbmRlcmVyLnJ1blByb2dyYW0odGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSwgeyB1bmlmb3JtczogdW5pZm9ybXMgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuXG4gICAgICB2YXIgYmx1clJhZGl1c0NoYW5nZWQgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXMgIT09IHRoaXMuX2xhc3RCbHVyUmFkaXVzO1xuICAgICAgdmFyIGJsdXJyeUNhbnZhcyA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChibHVyUmFkaXVzQ2hhbmdlZCB8fCB0aGlzLl9jYWNoZWRCbHVycmVkQ2FudmFzID09PSBudWxsKSB7XG4gICAgICAgIC8vIEJsdXIgYW5kIGNhY2hlIGNhbnZhc1xuICAgICAgICBibHVycnlDYW52YXMgPSB0aGlzLl9ibHVyQ2FudmFzKHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkQmx1cnJlZENhbnZhcyA9IGJsdXJyeUNhbnZhcztcbiAgICAgICAgdGhpcy5fbGFzdEJsdXJSYWRpdXMgPSB0aGlzLl9vcHRpb25zLmJsdXJSYWRpdXM7XG4gICAgICAgIHRoaXMuX2xhc3RHcmFkaWVudFJhZGl1cyA9IHRoaXMuX29wdGlvbnMuZ3JhZGllbnRSYWRpdXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2UgY2FjaGVkIGNhbnZhc1xuICAgICAgICBibHVycnlDYW52YXMgPSB0aGlzLl9jYWNoZWRCbHVycmVkQ2FudmFzO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWFza0NhbnZhcyA9IHRoaXMuX2NyZWF0ZU1hc2socmVuZGVyZXIpO1xuXG4gICAgICB0aGlzLl9hcHBseU1hc2soY2FudmFzLCBibHVycnlDYW52YXMsIG1hc2tDYW52YXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBibHVycmVkIGNvcHkgb2YgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2JsdXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmx1ckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIG5ld0NhbnZhcyA9IHJlbmRlcmVyLmNsb25lQ2FudmFzKCk7XG4gICAgICB2YXIgYmx1cnJ5Q29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGJsdXJyeUltYWdlRGF0YSA9IGJsdXJyeUNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIG5ld0NhbnZhcy53aWR0aCwgbmV3Q2FudmFzLmhlaWdodCk7XG4gICAgICBfdmVuZG9yU3RhY2tCbHVyMlsnZGVmYXVsdCddLnN0YWNrQmx1ckNhbnZhc1JHQkEoYmx1cnJ5SW1hZ2VEYXRhLCAwLCAwLCBuZXdDYW52YXMud2lkdGgsIG5ld0NhbnZhcy5oZWlnaHQsIHRoaXMuX29wdGlvbnMuYmx1clJhZGl1cyk7XG4gICAgICBibHVycnlDb250ZXh0LnB1dEltYWdlRGF0YShibHVycnlJbWFnZURhdGEsIDAsIDApO1xuXG4gICAgICByZXR1cm4gbmV3Q2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1hc2sgY2FudmFzXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7Q2FudmFzfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfY3JlYXRlTWFzaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jcmVhdGVNYXNrKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG5cbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIGdyYWRpZW50UmFkaXVzID0gdGhpcy5fb3B0aW9ucy5ncmFkaWVudFJhZGl1cztcblxuICAgICAgdmFyIG1hc2tDYW52YXMgPSByZW5kZXJlci5jcmVhdGVDYW52YXMoY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBtYXNrQ29udGV4dCA9IG1hc2tDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgcG9zaXRpb24ubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIGdyYWRpZW50XG4gICAgICB2YXIgZ3JhZGllbnQgPSBtYXNrQ29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChwb3NpdGlvbi54LCBwb3NpdGlvbi55LCAwLCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBncmFkaWVudFJhZGl1cyk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNGRkZGRkYnKTtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzAwMDAwMCcpO1xuXG4gICAgICAvLyBEcmF3IGdyYWRpZW50XG4gICAgICBtYXNrQ29udGV4dC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIG1hc2tDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHJldHVybiBtYXNrQ2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgdGhlIGJsdXIgYW5kIG1hc2sgdG8gdGhlIGlucHV0IGNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc30gaW5wdXRDYW52YXNcbiAgICAgKiBAcGFyYW0gIHtDYW52YXN9IGJsdXJyeUNhbnZhc1xuICAgICAqIEBwYXJhbSAge0NhbnZhc30gbWFza0NhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfYXBwbHlNYXNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5TWFzayhpbnB1dENhbnZhcywgYmx1cnJ5Q2FudmFzLCBtYXNrQ2FudmFzKSB7XG4gICAgICB2YXIgaW5wdXRDb250ZXh0ID0gaW5wdXRDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIHZhciBibHVycnlDb250ZXh0ID0gYmx1cnJ5Q2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgbWFza0NvbnRleHQgPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBpbnB1dEltYWdlRGF0YSA9IGlucHV0Q29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgcGl4ZWxzID0gaW5wdXRJbWFnZURhdGEuZGF0YTtcbiAgICAgIHZhciBibHVycnlQaXhlbHMgPSBibHVycnlDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbnB1dENhbnZhcy53aWR0aCwgaW5wdXRDYW52YXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgdmFyIG1hc2tQaXhlbHMgPSBtYXNrQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgaW5wdXRDYW52YXMud2lkdGgsIGlucHV0Q2FudmFzLmhlaWdodCkuZGF0YTtcblxuICAgICAgdmFyIGluZGV4LCBhbHBoYTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaW5wdXRDYW52YXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbnB1dENhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgaW5kZXggPSAoeSAqIGlucHV0Q2FudmFzLndpZHRoICsgeCkgKiA0O1xuICAgICAgICAgIGFscGhhID0gbWFza1BpeGVsc1tpbmRleF0gLyAyNTU7XG5cbiAgICAgICAgICBwaXhlbHNbaW5kZXhdID0gYWxwaGEgKiBwaXhlbHNbaW5kZXhdICsgKDEgLSBhbHBoYSkgKiBibHVycnlQaXhlbHNbaW5kZXhdO1xuICAgICAgICAgIHBpeGVsc1tpbmRleCArIDFdID0gYWxwaGEgKiBwaXhlbHNbaW5kZXggKyAxXSArICgxIC0gYWxwaGEpICogYmx1cnJ5UGl4ZWxzW2luZGV4ICsgMV07XG4gICAgICAgICAgcGl4ZWxzW2luZGV4ICsgMl0gPSBhbHBoYSAqIHBpeGVsc1tpbmRleCArIDJdICsgKDEgLSBhbHBoYSkgKiBibHVycnlQaXhlbHNbaW5kZXggKyAyXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpbnB1dENvbnRleHQucHV0SW1hZ2VEYXRhKGlucHV0SW1hZ2VEYXRhLCAwLCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBkaXJ0eSBzdGF0ZSBvZiB0aGlzIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlydHlcbiAgICAgKiBAY29tbWVudCBTaW5jZSBibHVyIG9wZXJhdGlvbnMgZG8gc2VwZXJhdGUgY2FjaGluZyBvZiB0aGVcbiAgICAgKiAgICAgICAgICBibHVycmVkIGNhbnZhcywgd2UgbmVlZCB0byBpbnZhbGlkYXRlIHRoZSBjYWNoZSB3aGVuIHRoZVxuICAgICAqICAgICAgICAgIGRpcnR5IHN0YXRlIGNoYW5nZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkaXJ0eScsXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQoZGlydHkpIHtcbiAgICAgIF9zZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJhZGlhbEJsdXJPcGVyYXRpb24ucHJvdG90eXBlKSwgJ2RpcnR5JywgZGlydHksIHRoaXMpO1xuICAgICAgdGhpcy5fY2FjaGVkQmx1cnJlZENhbnZhcyA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpcnR5IHN0YXRlXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUmFkaWFsQmx1ck9wZXJhdGlvbi5wcm90b3R5cGUpLCAnZGlydHknLCB0aGlzKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaWFsQmx1ck9wZXJhdGlvbjtcbn0pKF9vcGVyYXRpb24yWydkZWZhdWx0J10pO1xuXG5SYWRpYWxCbHVyT3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3JhZGlhbC1ibHVyJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuUmFkaWFsQmx1ck9wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgcG9zaXRpb246IHsgdHlwZTogJ3ZlY3RvcjInLCAnZGVmYXVsdCc6IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMC41LCAwLjUpIH0sXG4gIGdyYWRpZW50UmFkaXVzOiB7IHR5cGU6ICdudW1iZXInLCAnZGVmYXVsdCc6IDUwIH0sXG4gIGJsdXJSYWRpdXM6IHsgdHlwZTogJ251bWJlcicsICdkZWZhdWx0JzogMjAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUmFkaWFsQmx1ck9wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL3JhZGlhbC1ibHVyLW9wZXJhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDUzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX29wZXJhdGlvbiA9IHJlcXVpcmUoJy4vb3BlcmF0aW9uJyk7XG5cbnZhciBfb3BlcmF0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX29wZXJhdGlvbik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX2xpYkNvbG9yID0gcmVxdWlyZSgnLi4vbGliL2NvbG9yJyk7XG5cbnZhciBfbGliQ29sb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliQ29sb3IpO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IHRleHQgb24gdGhlIGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuVGV4dE9wZXJhdGlvblxuICogQGV4dGVuZHMgSW1nbHlLaXQuT3BlcmF0aW9uXG4gKi9cblxudmFyIFRleHRPcGVyYXRpb24gPSAoZnVuY3Rpb24gKF9PcGVyYXRpb24pIHtcbiAgX2luaGVyaXRzKFRleHRPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFRleHRPcGVyYXRpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRPcGVyYXRpb24pO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4dE9wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGluZGV4IHVzZWQgZm9yIHRoZSB0ZXh0XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3RleHRJbWFnZTtcXG4gICAgICB1bmlmb3JtIHZlYzIgdV9wb3NpdGlvbjtcXG4gICAgICB1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgdmVjMiByZWxhdGl2ZSA9ICh2X3RleENvb3JkIC0gdV9wb3NpdGlvbikgLyB1X3NpemU7XFxuXFxuICAgICAgICBpZiAocmVsYXRpdmUueCA+PSAwLjAgJiYgcmVsYXRpdmUueCA8PSAxLjAgJiZcXG4gICAgICAgICAgcmVsYXRpdmUueSA+PSAwLjAgJiYgcmVsYXRpdmUueSA8PSAxLjApIHtcXG5cXG4gICAgICAgICAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X3RleHRJbWFnZSwgcmVsYXRpdmUpO1xcblxcbiAgICAgICAgICAgIC8vIEdMX1NPVVJDRV9BTFBIQSwgR0xfT05FX01JTlVTX1NPVVJDRV9BTFBIQVxcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yMSArIGNvbG9yMCAqICgxLjAgLSBjb2xvcjEuYSk7XFxuXFxuICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjA7XFxuXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAnO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoVGV4dE9wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHZhciB0ZXh0Q2FudmFzID0gdGhpcy5fcmVuZGVyVGV4dENhbnZhcyhyZW5kZXJlcik7XG5cbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGV4dENhbnZhcy53aWR0aCwgdGV4dENhbnZhcy5oZWlnaHQpLmRpdmlkZShjYW52YXNTaXplKTtcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIHBvc2l0aW9uLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24ueSA9IDEgLSBwb3NpdGlvbi55OyAvLyBJbnZlcnQgeVxuICAgICAgcG9zaXRpb24ueSAtPSBzaXplLnk7IC8vIEZpeCB5XG5cbiAgICAgIC8vIEFkanVzdCB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnZlcnRpY2FsQWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBwb3NpdGlvbi55ICs9IHNpemUueSAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMudmVydGljYWxBbGlnbm1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgICAgIHBvc2l0aW9uLnkgKz0gc2l6ZS55O1xuICAgICAgfVxuXG4gICAgICAvLyBBZGp1c3QgaG9yaXpvbnRhbCBhbGlnbm1lbnRcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmFsaWdubWVudCA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgcG9zaXRpb24ueCAtPSBzaXplLnggLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmFsaWdubWVudCA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBwb3NpdGlvbi54IC09IHNpemUueDtcbiAgICAgIH1cblxuICAgICAgLy8gVXBsb2FkIHRoZSB0ZXh0dXJlXG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGhpcy5fdGV4dHVyZUluZGV4KTtcbiAgICAgIHRoaXMuX3RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLl90ZXh0dXJlKTtcblxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTElORUFSKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG5cbiAgICAgIC8vIFNldCBwcmVtdWx0aXBsaWVkIGFscGhhXG4gICAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfUFJFTVVMVElQTFlfQUxQSEFfV0VCR0wsIHRydWUpO1xuXG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRleHRDYW52YXMpO1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG5cbiAgICAgIC8vIEV4ZWN1dGUgdGhlIHNoYWRlclxuICAgICAgcmVuZGVyZXIucnVuU2hhZGVyKG51bGwsIHRoaXMuX2ZyYWdtZW50U2hhZGVyLCB7XG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgdV90ZXh0SW1hZ2U6IHsgdHlwZTogJ2knLCB2YWx1ZTogdGhpcy5fdGV4dHVyZUluZGV4IH0sXG4gICAgICAgICAgdV9wb3NpdGlvbjogeyB0eXBlOiAnMmYnLCB2YWx1ZTogW3Bvc2l0aW9uLngsIHBvc2l0aW9uLnldIH0sXG4gICAgICAgICAgdV9zaXplOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbc2l6ZS54LCBzaXplLnldIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIHRleHRDYW52YXMgPSB0aGlzLl9yZW5kZXJUZXh0Q2FudmFzKHJlbmRlcmVyKTtcblxuICAgICAgdmFyIGNhbnZhcyA9IHJlbmRlcmVyLmdldENhbnZhcygpO1xuICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIHNjYWxlZFBvc2l0aW9uID0gdGhpcy5fb3B0aW9ucy5wb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdyZWxhdGl2ZScpIHtcbiAgICAgICAgc2NhbGVkUG9zaXRpb24ubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkanVzdCB2ZXJ0aWNhbCBhbGlnbm1lbnRcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLnZlcnRpY2FsQWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBzY2FsZWRQb3NpdGlvbi55IC09IHRleHRDYW52YXMuaGVpZ2h0IC8gMjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy52ZXJ0aWNhbEFsaWdubWVudCA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgc2NhbGVkUG9zaXRpb24ueSAtPSB0ZXh0Q2FudmFzLmhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRqdXN0IGhvcml6b250YWwgYWxpZ25tZW50XG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5hbGlnbm1lbnQgPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHNjYWxlZFBvc2l0aW9uLnggLT0gdGV4dENhbnZhcy53aWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XG4gICAgICAgIHNjYWxlZFBvc2l0aW9uLnggLT0gdGV4dENhbnZhcy53aWR0aDtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UodGV4dENhbnZhcywgc2NhbGVkUG9zaXRpb24ueCwgc2NhbGVkUG9zaXRpb24ueSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdGV4dCBjYW52YXMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYSB0ZXh0dXJlIGluIFdlYkdMXG4gICAgICogYW5kIGFzIGFuIGltYWdlIGluIGNhbnZhc1xuICAgICAqIEByZXR1cm4ge0NhbnZhc31cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlclRleHRDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyVGV4dENhbnZhcyhyZW5kZXJlcikge1xuICAgICAgdmFyIGxpbmUgPSB1bmRlZmluZWQsXG4gICAgICAgICAgbGluZU51bSA9IHVuZGVmaW5lZDtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5jcmVhdGVDYW52YXMoKTtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBvdXRwdXRDYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShvdXRwdXRDYW52YXMud2lkdGgsIG91dHB1dENhbnZhcy5oZWlnaHQpO1xuXG4gICAgICB2YXIgbWF4V2lkdGggPSB0aGlzLl9vcHRpb25zLm1heFdpZHRoO1xuICAgICAgdmFyIGFjdHVhbEZvbnRTaXplID0gdGhpcy5fb3B0aW9ucy5mb250U2l6ZSAqIGNhbnZhc1NpemUueTtcbiAgICAgIHZhciBhY3R1YWxMaW5lSGVpZ2h0ID0gdGhpcy5fb3B0aW9ucy5saW5lSGVpZ2h0ICogYWN0dWFsRm9udFNpemU7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICBtYXhXaWR0aCAqPSByZW5kZXJlci5nZXRDYW52YXMoKS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgdGV4dCBvcHRpb25zXG4gICAgICB0aGlzLl9hcHBseVRleHRPcHRpb25zKHJlbmRlcmVyLCBjb250ZXh0KTtcblxuICAgICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgpO1xuXG4gICAgICB2YXIgbGluZXMgPSB0aGlzLl9vcHRpb25zLnRleHQuc3BsaXQoJ1xcbicpO1xuICAgICAgaWYgKHR5cGVvZiBtYXhXaWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBib3VuZGluZyBib3hcbiAgICAgICAgYm91bmRpbmdCb3gueCA9IG1heFdpZHRoO1xuICAgICAgICBsaW5lcyA9IHRoaXMuX2J1aWxkT3V0cHV0TGluZXMoY29udGV4dCwgbWF4V2lkdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChsaW5lTnVtID0gMDsgbGluZU51bSA8IGxpbmVzLmxlbmd0aDsgbGluZU51bSsrKSB7XG4gICAgICAgICAgbGluZSA9IGxpbmVzW2xpbmVOdW1dO1xuICAgICAgICAgIGJvdW5kaW5nQm94LnggPSBNYXRoLm1heChib3VuZGluZ0JveC54LCBjb250ZXh0Lm1lYXN1cmVUZXh0KGxpbmUpLndpZHRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgYm91bmRpbmdib3ggaGVpZ2h0XG4gICAgICBib3VuZGluZ0JveC55ID0gYWN0dWFsTGluZUhlaWdodCAqIGxpbmVzLmxlbmd0aDtcblxuICAgICAgLy8gUmVzaXplIHRoZSBjYW52YXNcbiAgICAgIGNhbnZhcy53aWR0aCA9IGJvdW5kaW5nQm94Lng7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gYm91bmRpbmdCb3gueTtcblxuICAgICAgLy8gR2V0IHRoZSBjb250ZXh0IGFnYWluXG4gICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIC8vIFJlbmRlciBiYWNrZ3JvdW5kIGNvbG9yXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX29wdGlvbnMuYmFja2dyb3VuZENvbG9yLnRvUkdCQSgpO1xuICAgICAgY29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBBcHBseSB0ZXh0IG9wdGlvbnNcbiAgICAgIHRoaXMuX2FwcGx5VGV4dE9wdGlvbnMocmVuZGVyZXIsIGNvbnRleHQpO1xuXG4gICAgICAvLyBEcmF3IGxpbmVzXG4gICAgICBmb3IgKGxpbmVOdW0gPSAwOyBsaW5lTnVtIDwgbGluZXMubGVuZ3RoOyBsaW5lTnVtKyspIHtcbiAgICAgICAgbGluZSA9IGxpbmVzW2xpbmVOdW1dO1xuICAgICAgICB0aGlzLl9kcmF3VGV4dChjb250ZXh0LCBsaW5lLCBhY3R1YWxMaW5lSGVpZ2h0ICogbGluZU51bSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgdGV4dCBvcHRpb25zIG9uIHRoZSBnaXZlbiBjb250ZXh0XG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyaW5nQ29udGV4dDJEfSBjb250ZXh0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hcHBseVRleHRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5VGV4dE9wdGlvbnMocmVuZGVyZXIsIGNvbnRleHQpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIGFjdHVhbEZvbnRTaXplID0gdGhpcy5fb3B0aW9ucy5mb250U2l6ZSAqIGNhbnZhc1NpemUueTtcblxuICAgICAgY29udGV4dC5mb250ID0gdGhpcy5fb3B0aW9ucy5mb250V2VpZ2h0ICsgJyAnICsgYWN0dWFsRm9udFNpemUgKyAncHggJyArIHRoaXMuX29wdGlvbnMuZm9udEZhbWlseTtcbiAgICAgIGNvbnRleHQudGV4dEJhc2VsaW5lID0gJ3RvcCc7XG4gICAgICBjb250ZXh0LnRleHRBbGlnbiA9IHRoaXMuX29wdGlvbnMuYWxpZ25tZW50O1xuICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLl9vcHRpb25zLmNvbG9yLnRvUkdCQSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgb3ZlciBhbGwgbGluZXMgYW5kIHNwbGl0IHRoZW0gaW50byBtdWx0aXBsZSBsaW5lcywgZGVwZW5kaW5nXG4gICAgICogb24gdGhlIHdpZHRoIHRoZXkgbmVlZFxuICAgICAqIEBwYXJhbSB7UmVuZGVyaW5nQ29udGV4dDJkfSBjb250ZXh0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG1heFdpZHRoXG4gICAgICogQHJldHVybiB7QXJyYXkuPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19idWlsZE91dHB1dExpbmVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2J1aWxkT3V0cHV0TGluZXMoY29udGV4dCwgbWF4V2lkdGgpIHtcbiAgICAgIHZhciBpbnB1dExpbmVzID0gdGhpcy5fb3B0aW9ucy50ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBvdXRwdXRMaW5lcyA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRDaGFycyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBsaW5lTnVtID0gMDsgbGluZU51bSA8IGlucHV0TGluZXMubGVuZ3RoOyBsaW5lTnVtKyspIHtcbiAgICAgICAgdmFyIGlucHV0TGluZSA9IGlucHV0TGluZXNbbGluZU51bV07XG4gICAgICAgIHZhciBsaW5lQ2hhcnMgPSBpbnB1dExpbmUuc3BsaXQoJycpO1xuXG4gICAgICAgIGlmIChsaW5lQ2hhcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgb3V0cHV0TGluZXMucHVzaCgnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBjaGFyTnVtID0gMDsgY2hhck51bSA8IGxpbmVDaGFycy5sZW5ndGg7IGNoYXJOdW0rKykge1xuICAgICAgICAgIHZhciBjdXJyZW50Q2hhciA9IGxpbmVDaGFyc1tjaGFyTnVtXTtcbiAgICAgICAgICBjdXJyZW50Q2hhcnMucHVzaChjdXJyZW50Q2hhcik7XG4gICAgICAgICAgdmFyIGN1cnJlbnRMaW5lID0gY3VycmVudENoYXJzLmpvaW4oJycpO1xuICAgICAgICAgIHZhciBsaW5lV2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGN1cnJlbnRMaW5lKS53aWR0aDtcblxuICAgICAgICAgIGlmIChsaW5lV2lkdGggPiBtYXhXaWR0aCAmJiBjdXJyZW50Q2hhcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvdXRwdXRMaW5lcy5wdXNoKGN1cnJlbnRDaGFyc1swXSk7XG4gICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSBbXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA+IG1heFdpZHRoKSB7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3Qgd29yZFxuICAgICAgICAgICAgdmFyIGxhc3RXb3JkID0gY3VycmVudENoYXJzLnBvcCgpO1xuXG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxpbmUsIGNsZWFyIHRoZSB3b3Jkc1xuICAgICAgICAgICAgb3V0cHV0TGluZXMucHVzaChjdXJyZW50Q2hhcnMuam9pbignJykpO1xuICAgICAgICAgICAgY3VycmVudENoYXJzID0gW107XG5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0byB1c2UgdGhlIGxhc3Qgd29yZCBmb3IgdGhlIG5leHQgbGluZVxuICAgICAgICAgICAgY3VycmVudENoYXJzID0gW2xhc3RXb3JkXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJOdW0gPT09IGxpbmVDaGFycy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGxpbmUsIGNsZWFyIHRoZSB3b3Jkc1xuICAgICAgICAgICAgb3V0cHV0TGluZXMucHVzaChjdXJyZW50Q2hhcnMuam9pbignJykpO1xuICAgICAgICAgICAgY3VycmVudENoYXJzID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGluZSBlbmRlZCwgYnV0IHRoZXJlJ3Mgd29yZHMgbGVmdFxuICAgICAgICBpZiAoY3VycmVudENoYXJzLmxlbmd0aCkge1xuICAgICAgICAgIG91dHB1dExpbmVzLnB1c2goY3VycmVudENoYXJzLmpvaW4oJycpKTtcbiAgICAgICAgICBjdXJyZW50Q2hhcnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0TGluZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRHJhd3MgdGhlIGdpdmVuIGxpbmUgb250byB0aGUgZ2l2ZW4gY29udGV4dCBhdCB0aGUgZ2l2ZW4gWSBwb3NpdGlvblxuICAgICAqIEBwYXJhbSAge1JlbmRlcmluZ0NvbnRleHQyRH0gY29udGV4dFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSAge051bWJlcn0geVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhd1RleHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhd1RleHQoY29udGV4dCwgdGV4dCwgeSkge1xuICAgICAgdmFyIGNhbnZhcyA9IGNvbnRleHQuY2FudmFzO1xuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuYWxpZ25tZW50ID09PSAnY2VudGVyJykge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHRleHQsIGNhbnZhcy53aWR0aCAvIDIsIHkpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgMCwgeSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuYWxpZ25tZW50ID09PSAncmlnaHQnKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbFRleHQodGV4dCwgY2FudmFzLndpZHRoLCB5KTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dE9wZXJhdGlvbjtcbn0pKF9vcGVyYXRpb24yWydkZWZhdWx0J10pO1xuXG5UZXh0T3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3RleHQnO1xuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYXZhaWxhYmxlIG9wdGlvbnMgZm9yIHRoaXMgb3BlcmF0aW9uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5UZXh0T3BlcmF0aW9uLnByb3RvdHlwZS5hdmFpbGFibGVPcHRpb25zID0ge1xuICBmb250U2l6ZTogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAwLjEgfSxcbiAgbGluZUhlaWdodDogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAxLjEgfSxcbiAgZm9udEZhbWlseTogeyB0eXBlOiAnc3RyaW5nJywgJ2RlZmF1bHQnOiAnVGltZXMgTmV3IFJvbWFuJyB9LFxuICBmb250V2VpZ2h0OiB7IHR5cGU6ICdzdHJpbmcnLCAnZGVmYXVsdCc6ICdub3JtYWwnIH0sXG4gIGFsaWdubWVudDogeyB0eXBlOiAnc3RyaW5nJywgJ2RlZmF1bHQnOiAnbGVmdCcsIGF2YWlsYWJsZTogWydsZWZ0JywgJ2NlbnRlcicsICdyaWdodCddIH0sXG4gIHZlcnRpY2FsQWxpZ25tZW50OiB7IHR5cGU6ICdzdHJpbmcnLCAnZGVmYXVsdCc6ICd0b3AnLCBhdmFpbGFibGU6IFsndG9wJywgJ2NlbnRlcicsICdib3R0b20nXSB9LFxuICBjb2xvcjogeyB0eXBlOiAnY29sb3InLCAnZGVmYXVsdCc6IG5ldyBfbGliQ29sb3IyWydkZWZhdWx0J10oMSwgMSwgMSwgMSkgfSxcbiAgYmFja2dyb3VuZENvbG9yOiB7IHR5cGU6ICdjb2xvcicsICdkZWZhdWx0JzogbmV3IF9saWJDb2xvcjJbJ2RlZmF1bHQnXSgwLCAwLCAwLCAwKSB9LFxuICBwb3NpdGlvbjogeyB0eXBlOiAndmVjdG9yMicsICdkZWZhdWx0JzogbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLCAwKSB9LFxuICB0ZXh0OiB7IHR5cGU6ICdzdHJpbmcnLCByZXF1aXJlZDogdHJ1ZSB9LFxuICBtYXhXaWR0aDogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAxLjAgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVGV4dE9wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL3RleHQtb3BlcmF0aW9uLmpzXG4gKiogbW9kdWxlIGlkID0gNTRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9vcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcGVyYXRpb24pO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF92ZW5kb3JQcm9taXNlID0gcmVxdWlyZSgnLi4vdmVuZG9yL3Byb21pc2UnKTtcblxudmFyIF92ZW5kb3JQcm9taXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlbmRvclByb21pc2UpO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IHRleHQgb24gdGhlIGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuU3RpY2tlcnNPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBTdGlja2Vyc09wZXJhdGlvbiA9IChmdW5jdGlvbiAoX09wZXJhdGlvbikge1xuICBfaW5oZXJpdHMoU3RpY2tlcnNPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIFN0aWNrZXJzT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGlja2Vyc09wZXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTdGlja2Vyc09wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGluZGV4IHVzZWQgZm9yIHRoZSBzdGlja2VyXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDE7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnJhZ21lbnQgc2hhZGVyIHVzZWQgZm9yIHRoaXMgb3BlcmF0aW9uXG4gICAgICovXG4gICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAnXFxuICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuICAgICAgdmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X3N0aWNrZXJJbWFnZTtcXG4gICAgICB1bmlmb3JtIHZlYzIgdV9wb3NpdGlvbjtcXG4gICAgICB1bmlmb3JtIHZlYzIgdV9zaXplO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIHZlYzQgY29sb3IwID0gdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpO1xcbiAgICAgICAgdmVjMiByZWxhdGl2ZSA9ICh2X3RleENvb3JkIC0gdV9wb3NpdGlvbikgLyB1X3NpemU7XFxuXFxuICAgICAgICBpZiAocmVsYXRpdmUueCA+PSAwLjAgJiYgcmVsYXRpdmUueCA8PSAxLjAgJiZcXG4gICAgICAgICAgcmVsYXRpdmUueSA+PSAwLjAgJiYgcmVsYXRpdmUueSA8PSAxLjApIHtcXG5cXG4gICAgICAgICAgICB2ZWM0IGNvbG9yMSA9IHRleHR1cmUyRCh1X3N0aWNrZXJJbWFnZSwgcmVsYXRpdmUpO1xcblxcbiAgICAgICAgICAgIC8vIEdMX1NPVVJDRV9BTFBIQSwgR0xfT05FX01JTlVTX1NPVVJDRV9BTFBIQVxcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yMSArIGNvbG9yMCAqICgxLjAgLSBjb2xvcjEuYSk7XFxuXFxuICAgICAgICB9IGVsc2Uge1xcblxcbiAgICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjA7XFxuXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAnO1xuXG4gICAgdGhpcy5fbG9hZGVkU3RpY2tlcnMgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgdGhpcyBvcGVyYXRpb25cbiAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoU3RpY2tlcnNPcGVyYXRpb24sIFt7XG4gICAga2V5OiAncmVuZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZFN0aWNrZXIoKS50aGVuKGZ1bmN0aW9uIChpbWFnZSkge1xuICAgICAgICBpZiAocmVuZGVyZXIuaWRlbnRpZmllciA9PT0gJ3dlYmdsJykge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbmRlcldlYkdMKHJlbmRlcmVyLCBpbWFnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3JlbmRlckNhbnZhcyhyZW5kZXJlciwgaW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9wcyB0aGlzIGltYWdlIHVzaW5nIFdlYkdMXG4gICAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIsIGltYWdlKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgICB2YXIgZ2wgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wdGlvbnMucG9zaXRpb24uY2xvbmUoKTtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5udW1iZXJGb3JtYXQgPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgcG9zaXRpb24uZGl2aWRlKGNhbnZhc1NpemUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2l6ZS5jb3B5KHRoaXMuX29wdGlvbnMuc2l6ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubnVtYmVyRm9ybWF0ID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgc2l6ZS5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBpbWFnZSByYXRpbywgc2NhbGUgYnkgd2lkdGhcbiAgICAgICAgdmFyIHJhdGlvID0gaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGg7XG4gICAgICAgIHNpemUueSA9IHNpemUueCAqIHJhdGlvO1xuICAgICAgfVxuICAgICAgc2l6ZS5kaXZpZGUoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHBvc2l0aW9uLnkgPSAxIC0gcG9zaXRpb24ueTsgLy8gSW52ZXJ0IHlcbiAgICAgIHBvc2l0aW9uLnkgLT0gc2l6ZS55OyAvLyBGaXggeVxuXG4gICAgICAvLyBVcGxvYWQgdGhlIHRleHR1cmVcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0aGlzLl90ZXh0dXJlSW5kZXgpO1xuICAgICAgdGhpcy5fdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAvLyBTZXQgcHJlbXVsdGlwbGllZCBhbHBoYVxuICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcblxuICAgICAgLy8gRXhlY3V0ZSB0aGUgc2hhZGVyXG4gICAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1X3N0aWNrZXJJbWFnZTogeyB0eXBlOiAnaScsIHZhbHVlOiB0aGlzLl90ZXh0dXJlSW5kZXggfSxcbiAgICAgICAgICB1X3Bvc2l0aW9uOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbcG9zaXRpb24ueCwgcG9zaXRpb24ueV0gfSxcbiAgICAgICAgICB1X3NpemU6IHsgdHlwZTogJzJmJywgdmFsdWU6IFtzaXplLngsIHNpemUueV0gfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9wcyB0aGUgaW1hZ2UgdXNpbmcgQ2FudmFzMkRcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcGFyYW0gIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIsIGltYWdlKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgc2NhbGVkUG9zaXRpb24gPSB0aGlzLl9vcHRpb25zLnBvc2l0aW9uLmNsb25lKCk7XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICBzY2FsZWRQb3NpdGlvbi5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLnNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNpemUuY29weSh0aGlzLl9vcHRpb25zLnNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLm51bWJlckZvcm1hdCA9PT0gJ3JlbGF0aXZlJykge1xuICAgICAgICAgIHNpemUubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGV4dC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHNjYWxlZFBvc2l0aW9uLngsIHNjYWxlZFBvc2l0aW9uLnksIHNpemUueCwgc2l6ZS55KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgc3RpY2tlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19sb2FkU3RpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkU3RpY2tlcigpIHtcbiAgICAgIHZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbiAgICAgIGlmIChpc0Jyb3dzZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRJbWFnZUJyb3dzZXIodGhpcy5fb3B0aW9ucy5zdGlja2VyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkSW1hZ2VOb2RlKHRoaXMuX29wdGlvbnMuc3RpY2tlcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgdGhlIGdpdmVuIGltYWdlIHVzaW5nIHRoZSBicm93c2VyJ3MgYEltYWdlYCBjbGFzc1xuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfbG9hZEltYWdlQnJvd3NlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkSW1hZ2VCcm93c2VyKGZpbGVOYW1lKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gbmV3IF92ZW5kb3JQcm9taXNlMlsnZGVmYXVsdCddKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gUmV0dXJuIHByZWxvYWRlZCBzdGlja2VyIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZiAoc2VsZi5fbG9hZGVkU3RpY2tlcnNbZmlsZU5hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoc2VsZi5fbG9hZGVkU3RpY2tlcnNbZmlsZU5hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc2VsZi5fbG9hZGVkU3RpY2tlcnNbZmlsZU5hbWVdID0gaW1hZ2U7XG4gICAgICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbWFnZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCBzdGlja2VyOiAnICsgZmlsZU5hbWUpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW1hZ2UuY3Jvc3NPcmlnaW4gPSAnQW5vbnltb3VzJztcbiAgICAgICAgaW1hZ2Uuc3JjID0gc2VsZi5fa2l0LmdldEFzc2V0UGF0aChmaWxlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMb2FkcyB0aGUgZ2l2ZW4gaW1hZ2UgdXNpbmcgbm9kZS5qcycgYGZzYCBhbmQgbm9kZS1jYW52YXMgYEltYWdlYFxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZmlsZU5hbWVcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfbG9hZEltYWdlTm9kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkSW1hZ2VOb2RlKGZpbGVOYW1lKSB7XG4gICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZSgnY2FudmFzJyk7XG4gICAgICB2YXIgZnMgPSByZXF1aXJlKCdmcycpO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaW1hZ2UgPSBuZXcgQ2FudmFzLkltYWdlKCk7XG4gICAgICB2YXIgcGF0aCA9IHNlbGYuX2tpdC5nZXRBc3NldFBhdGgoZmlsZU5hbWUpO1xuXG4gICAgICByZXR1cm4gbmV3IF92ZW5kb3JQcm9taXNlMlsnZGVmYXVsdCddKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnMucmVhZEZpbGUocGF0aCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyKSB7XG4gICAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuXG4gICAgICAgICAgaW1hZ2Uuc3JjID0gYnVmZmVyO1xuICAgICAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSByZWdpc3RlcmVkIHN0aWNrZXJzXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLFN0cmluZz59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzdGlja2VycycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RpY2tlcnM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0aWNrZXJzT3BlcmF0aW9uO1xufSkoX29wZXJhdGlvbjJbJ2RlZmF1bHQnXSk7XG5cblN0aWNrZXJzT3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3N0aWNrZXJzJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuU3RpY2tlcnNPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHN0aWNrZXI6IHsgdHlwZTogJ3N0cmluZycsIHJlcXVpcmVkOiB0cnVlIH0sXG4gIHBvc2l0aW9uOiB7IHR5cGU6ICd2ZWN0b3IyJywgJ2RlZmF1bHQnOiBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApIH0sXG4gIHNpemU6IHsgdHlwZTogJ3ZlY3RvcjInLCAnZGVmYXVsdCc6IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMCwgMCkgfVxufTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3RpY2tlcnNPcGVyYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9zdGlja2Vycy1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9vcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcGVyYXRpb24pO1xuXG52YXIgX2xpYkNvbG9yID0gcmVxdWlyZSgnLi4vbGliL2NvbG9yJyk7XG5cbnZhciBfbGliQ29sb3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliQ29sb3IpO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBmcmFtZXMgb24gdGhlIGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuRnJhbWVzT3BlcmF0aW9uXG4gKiBAZXh0ZW5kcyBJbWdseUtpdC5PcGVyYXRpb25cbiAqL1xuXG52YXIgRnJhbWVzT3BlcmF0aW9uID0gKGZ1bmN0aW9uIChfT3BlcmF0aW9uKSB7XG4gIF9pbmhlcml0cyhGcmFtZXNPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIEZyYW1lc09wZXJhdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRnJhbWVzT3BlcmF0aW9uKTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZyYW1lc09wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0dXJlIGluZGV4IHVzZWQgZm9yIHRoZSBmcmFtZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl90ZXh0dXJlSW5kZXggPSAxO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGZyYWdtZW50IHNoYWRlciB1c2VkIGZvciB0aGlzIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ1xcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfaW1hZ2U7XFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdV9mcmFtZUltYWdlO1xcbiAgICAgIHVuaWZvcm0gdmVjNCB1X2NvbG9yO1xcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3RoaWNrbmVzcztcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICB2ZWM0IGZyYWdDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTtcXG4gICAgICAgIGlmICh2X3RleENvb3JkLnggPCB1X3RoaWNrbmVzcy54IHx8IHZfdGV4Q29vcmQueCA+IDEuMCAtIHVfdGhpY2tuZXNzLnggfHxcXG4gICAgICAgICAgdl90ZXhDb29yZC55IDwgdV90aGlja25lc3MueSB8fCB2X3RleENvb3JkLnkgPiAxLjAgLSB1X3RoaWNrbmVzcy55KSB7XFxuICAgICAgICAgICAgZnJhZ0NvbG9yID0gbWl4KGZyYWdDb2xvciwgdV9jb2xvciwgdV9jb2xvci5hKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgZ2xfRnJhZ0NvbG9yID0gZnJhZ0NvbG9yO1xcbiAgICAgIH1cXG4gICAgJztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICogb3BlcmF0aW9ucy5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgLyoqXG4gICAqIENyb3BzIHRoaXMgaW1hZ2UgdXNpbmcgV2ViR0xcbiAgICogQHBhcmFtICB7V2ViR0xSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICogQHByaXZhdGVcbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgX2NyZWF0ZUNsYXNzKEZyYW1lc09wZXJhdGlvbiwgW3tcbiAgICBrZXk6ICdfcmVuZGVyV2ViR0wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyV2ViR0wocmVuZGVyZXIpIHtcbiAgICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5nZXRDYW52YXMoKTtcblxuICAgICAgdmFyIGNvbG9yID0gdGhpcy5fb3B0aW9ucy5jb2xvcjtcbiAgICAgIHZhciB0aGlja25lc3MgPSB0aGlzLl9vcHRpb25zLnRoaWNrbmVzcyAqIGNhbnZhcy5oZWlnaHQ7XG4gICAgICB2YXIgdGhpY2tuZXNzVmVjMiA9IFt0aGlja25lc3MgLyBjYW52YXMud2lkdGgsIHRoaWNrbmVzcyAvIGNhbnZhcy5oZWlnaHRdO1xuXG4gICAgICB2YXIgdW5pZm9ybXMgPSB7XG4gICAgICAgIHVfY29sb3I6IHsgdHlwZTogJzRmJywgdmFsdWU6IGNvbG9yLnRvR0xDb2xvcigpIH0sXG4gICAgICAgIHVfdGhpY2tuZXNzOiB7IHR5cGU6ICcyZicsIHZhbHVlOiB0aGlja25lc3NWZWMyIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSkge1xuICAgICAgICB0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdID0gcmVuZGVyZXIuc2V0dXBHTFNMUHJvZ3JhbShudWxsLCB0aGlzLl9mcmFnbWVudFNoYWRlcik7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVyLnJ1blByb2dyYW0odGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSwgeyB1bmlmb3JtczogdW5pZm9ybXMgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JvcHMgdGhlIGltYWdlIHVzaW5nIENhbnZhczJEXG4gICAgICogQHBhcmFtICB7Q2FudmFzUmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ2FudmFzKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuZ2V0Q2FudmFzKCk7XG4gICAgICB2YXIgY29udGV4dCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcblxuICAgICAgdmFyIGNvbG9yID0gdGhpcy5fb3B0aW9ucy5jb2xvcjtcbiAgICAgIHZhciB0aGlja25lc3MgPSB0aGlzLl9vcHRpb25zLnRoaWNrbmVzcyAqIGNhbnZhcy5oZWlnaHQ7XG5cbiAgICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gdGhpY2tuZXNzICogMjtcbiAgICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvci50b1JHQkEoKTtcbiAgICAgIGNvbnRleHQucmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmFtZXNPcGVyYXRpb247XG59KShfb3BlcmF0aW9uMlsnZGVmYXVsdCddKTtcblxuRnJhbWVzT3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ2ZyYW1lcyc7XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBhdmFpbGFibGUgb3B0aW9ucyBmb3IgdGhpcyBvcGVyYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbkZyYW1lc09wZXJhdGlvbi5wcm90b3R5cGUuYXZhaWxhYmxlT3B0aW9ucyA9IHtcbiAgY29sb3I6IHsgdHlwZTogJ2NvbG9yJywgJ2RlZmF1bHQnOiBuZXcgX2xpYkNvbG9yMlsnZGVmYXVsdCddKDAsIDAsIDAsIDEpIH0sXG4gIHRoaWNrbmVzczogeyB0eXBlOiAnbnVtYmVyJywgJ2RlZmF1bHQnOiAwLjAyIH1cbn07XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEZyYW1lc09wZXJhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZyYW1lcy1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94MiwgX3gzLCBfeDQpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gyLCBwcm9wZXJ0eSA9IF94MywgcmVjZWl2ZXIgPSBfeDQ7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3gyID0gcGFyZW50OyBfeDMgPSBwcm9wZXJ0eTsgX3g0ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9vcGVyYXRpb24gPSByZXF1aXJlKCcuL29wZXJhdGlvbicpO1xuXG52YXIgX29wZXJhdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9vcGVyYXRpb24pO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxudmFyIERFRkFVTFRfVEhJQ0tORVNTID0gMC4wMjtcbnZhciBERUZBVUxUX0NPTE9SID0gbmV3IF9saWJDb2xvcjJbJ2RlZmF1bHQnXSgxLjAsIDAuMCwgMC4wLCAxLjApO1xuXG4vKipcbiAqIEFuIG9wZXJhdGlvbiB0aGF0IGNhbiBkcmF3IGJydXNoZXMgb24gdGhlIGNhbnZhc1xuICpcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0Lk9wZXJhdGlvbnMuQnJ1c2hPcGVyYXRpb25cbiAqIEBleHRlbmRzIEltZ2x5S2l0Lk9wZXJhdGlvblxuICovXG5cbnZhciBCcnVzaE9wZXJhdGlvbiA9IChmdW5jdGlvbiAoX09wZXJhdGlvbikge1xuICBfaW5oZXJpdHMoQnJ1c2hPcGVyYXRpb24sIF9PcGVyYXRpb24pO1xuXG4gIGZ1bmN0aW9uIEJydXNoT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCcnVzaE9wZXJhdGlvbik7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihCcnVzaE9wZXJhdGlvbi5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHRoaXMuX3RleHR1cmVJbmRleCA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIHZlcnRleCBzaGFkZXIgdXNlZCBmb3IgdGhpcyBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLl92ZXJ0ZXhTaGFkZXIgPSAnXFxuICAgICAgYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG4gICAgICBhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkO1xcbiAgICAgIHZhcnlpbmcgdmVjMiB2X3RleENvb3JkO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGdsX1Bvc2l0aW9uID0gdmVjNChhX3Bvc2l0aW9uLCAwLCAxKTtcXG4gICAgICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkO1xcbiAgICAgIH1cXG4gICAgJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBmcmFnbWVudCBzaGFkZXIgdXNlZCBmb3IgdGhpcyBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9ICdcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4gICAgICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDtcXG4gICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlO1xcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVfdGV4dEltYWdlO1xcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3Bvc2l0aW9uO1xcbiAgICAgIHVuaWZvcm0gdmVjMiB1X3NpemU7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgdmVjNCBjb2xvcjAgPSB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7XFxuICAgICAgICB2ZWMyIHJlbGF0aXZlID0gKHZfdGV4Q29vcmQgLSB1X3Bvc2l0aW9uKSAvIHVfc2l6ZTtcXG5cXG4gICAgICAgIGlmIChyZWxhdGl2ZS54ID49IDAuMCAmJiByZWxhdGl2ZS54IDw9IDEuMCAmJlxcbiAgICAgICAgICByZWxhdGl2ZS55ID49IDAuMCAmJiByZWxhdGl2ZS55IDw9IDEuMCkge1xcblxcbiAgICAgICAgICAgIHZlYzQgY29sb3IxID0gdGV4dHVyZTJEKHVfdGV4dEltYWdlLCByZWxhdGl2ZSk7XFxuXFxuICAgICAgICAgICAgLy8gR0xfU09VUkNFX0FMUEhBLCBHTF9PTkVfTUlOVVNfU09VUkNFX0FMUEhBXFxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gY29sb3IxICsgY29sb3IwICogKDEuMCAtIGNvbG9yMS5hKTtcXG5cXG4gICAgICAgIH0gZWxzZSB7XFxuXFxuICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yMDtcXG5cXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICc7XG5cbiAgICB0aGlzLl9icnVzaENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgKiBvcGVyYXRpb25zLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICAvKipcbiAgICogQ3JvcHMgdGhpcyBpbWFnZSB1c2luZyBXZWJHTFxuICAgKiBAcGFyYW0gIHtXZWJHTFJlbmRlcmVyfSByZW5kZXJlclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBfY3JlYXRlQ2xhc3MoQnJ1c2hPcGVyYXRpb24sIFt7XG4gICAga2V5OiAnX3JlbmRlcldlYkdMJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlcldlYkdMKHJlbmRlcmVyKSB7XG4gICAgICB0aGlzLnJlbmRlckJydXNoQ2FudmFzKHJlbmRlcmVyLmdldENhbnZhcygpKTtcbiAgICAgIHZhciBnbCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICAgIHRoaXMuX3NldHVwUHJvZ3JhbShyZW5kZXJlcik7XG4gICAgICB0aGlzLl91cGxvYWRDYW52YXNUb1RleHR1cmUoZ2wsIHRoaXMuX2JydXNoQ2FudmFzKTtcblxuICAgICAgLy8gdXNlIHRoZSBjb21wbGV0ZSBhcmVhIGF2YWlsYWJsZVxuICAgICAgdmFyIHBvc2l0aW9uID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLCAwKTtcbiAgICAgIHZhciBzaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgxLCAxKTtcblxuICAgICAgLy8gRXhlY3V0ZSB0aGUgc2hhZGVyXG4gICAgICByZW5kZXJlci5ydW5TaGFkZXIobnVsbCwgdGhpcy5fZnJhZ21lbnRTaGFkZXIsIHtcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICB1X3RleHRJbWFnZTogeyB0eXBlOiAnaScsIHZhbHVlOiB0aGlzLl90ZXh0dXJlSW5kZXggfSxcbiAgICAgICAgICB1X3Bvc2l0aW9uOiB7IHR5cGU6ICcyZicsIHZhbHVlOiBbcG9zaXRpb24ueCwgcG9zaXRpb24ueV0gfSxcbiAgICAgICAgICB1X3NpemU6IHsgdHlwZTogJzJmJywgdmFsdWU6IFtzaXplLngsIHNpemUueV0gfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGxvYWRzIHBpeGVsLWRhdGEgY29udGFpbmVkIGluIGEgY2FudmFzIG9udG8gYSB0ZXh0dXJlXG4gICAgICogQHBhcmFtICB7Q29udGV4dH0gZ2wgICAgZ2wtY29udGV4dCAodXNlIHJlbmRlcmVyLmdldENvbnRleHQoKSlcbiAgICAgKiBAcGFyYW0gIHtDYW52YXN9IGNhbnZhcyBBIGNhbnZhcyB0aGF0IGNvbnRhaW5zIHRoZSBwaXhlbCBkYXRhIGZvciB0aGUgdGV4dHVyZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwbG9hZENhbnZhc1RvVGV4dHVyZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGxvYWRDYW52YXNUb1RleHR1cmUoZ2wsIGNhbnZhcykge1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIHRoaXMuX3RleHR1cmVJbmRleCk7XG4gICAgICB0aGlzLl90ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5fdGV4dHVyZSk7XG5cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5MSU5FQVIpO1xuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUik7XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuXG4gICAgICAvLyBTZXQgcHJlbXVsdGlwbGllZCBhbHBoYVxuICAgICAgZ2wucGl4ZWxTdG9yZWkoZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0cnVlKTtcblxuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBjYW52YXMpO1xuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW5pdGlhbGl6ZXMgdGhlIHNoYWRlcnMgb25jZVxuICAgICAqIEBwYXJhbSAge1dlYkdMUmVuZGVyZXJ9IHJlbmRlcmVyIFdlYkdMUmVuZGVyZXIgdGhhdCBpcyB1c2VkIHRvIGNvbXBpbGUgdGhlXG4gICAgICogc2hhZmVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NldHVwUHJvZ3JhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cFByb2dyYW0ocmVuZGVyZXIpIHtcbiAgICAgIGlmICghdGhpcy5fZ2xzbFByb2dyYW1zW3JlbmRlcmVyLmlkXSkge1xuICAgICAgICB0aGlzLl9nbHNsUHJvZ3JhbXNbcmVuZGVyZXIuaWRdID0gcmVuZGVyZXIuc2V0dXBHTFNMUHJvZ3JhbSh0aGlzLl92ZXJ0ZXhTaGFkZXIsIHRoaXMuX2ZyYWdtZW50U2hhZGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBicnVzaCBvcGVyYXRpb24gdG8gYSBjYW52YXNcbiAgICAgKiBAcGFyYW0gIHtDYW52YXNSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJDYW52YXMocmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQnJ1c2hDYW52YXMocmVuZGVyZXIuZ2V0Q2FudmFzKCkpO1xuICAgICAgdmFyIGNvbnRleHQgPSByZW5kZXJlci5nZXRDb250ZXh0KCk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLl9icnVzaENhbnZhcywgMCwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgYnJ1c2ggY2FudmFzIHRoYXQgd2lsbCBiZSB1c2VkIGFzIGEgdGV4dHVyZSBpbiBXZWJHTFxuICAgICAqIGFuZCBhcyBhbiBpbWFnZSBpbiBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0NhbnZhc30gY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlckJydXNoQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyQnJ1c2hDYW52YXMob3V0cHV0Q2FudmFzKSB7XG4gICAgICB2YXIgY2FudmFzID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fYnJ1c2hDYW52YXMgOiBhcmd1bWVudHNbMV07XG5cbiAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FudmFzLndpZHRoICE9PSBvdXRwdXRDYW52YXMud2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gb3V0cHV0Q2FudmFzLmhlaWdodCkge1xuICAgICAgICBjYW52YXMud2lkdGggPSBvdXRwdXRDYW52YXMud2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBvdXRwdXRDYW52YXMuaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGF0aHMgPSB0aGlzLl9vcHRpb25zLnBhdGhzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhzW2ldO1xuICAgICAgICBwYXRoLnJlbmRlclRvQ2FudmFzKGNhbnZhcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbmQgYWRkcyBhIG5ldyBwYXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRoaWNrbmVzc1xuICAgICAqIEBwYXJhbSB7Q29sb3J9IGNvbG9yXG4gICAgICogQHJldHVybiB7QnJ1c2hPcGVyYXRpb24uUGF0aH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NyZWF0ZVBhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVQYXRoKHRoaWNrbmVzcywgY29sb3IpIHtcbiAgICAgIHZhciBwYXRoID0gbmV3IEJydXNoT3BlcmF0aW9uLlBhdGgodGhpcywgdGhpY2tuZXNzLCBjb2xvcik7XG4gICAgICB0aGlzLl9vcHRpb25zLnBhdGhzLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBsb25nZXIgc2l6ZSBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtDYW52YXN9XG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2dldExvbmdlclNpZGVTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldExvbmdlclNpZGVTaXplKGNhbnZhcykge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgbGFzdCBjb2xvclxuICAgICAqIEByZXR1cm4ge0NvbG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZ2V0TGFzdENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TGFzdENvbG9yKCkge1xuICAgICAgdmFyIGxhc3RQYXRoID0gdGhpcy5fb3B0aW9ucy5wYXRoc1t0aGlzLl9vcHRpb25zLnBhdGhzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFsYXN0UGF0aCkgcmV0dXJuIERFRkFVTFRfQ09MT1I7XG4gICAgICByZXR1cm4gbGFzdFBhdGguZ2V0Q29sb3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXR1cm5zIHRoZSBsYXN0IHRoaWNrbmVzc1xuICAgICAqIEByZXR1cm4ge1RoaWNrbmVzc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2dldExhc3RUaGlja25lc3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0VGhpY2tuZXNzKCkge1xuICAgICAgdmFyIGxhc3RQYXRoID0gdGhpcy5fb3B0aW9ucy5wYXRoc1t0aGlzLl9vcHRpb25zLnBhdGhzLmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKCFsYXN0UGF0aCkgcmV0dXJuIERFRkFVTFRfVEhJQ0tORVNTO1xuICAgICAgcmV0dXJuIGxhc3RQYXRoLmdldFRoaWNrbmVzcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBvcGVyYXRpb24gaGFzIGJlZW4gc2V0IHRvIGRpcnR5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRpcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRGlydHkoKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgcGF0aC5zZXREaXJ0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJydXNoT3BlcmF0aW9uO1xufSkoX29wZXJhdGlvbjJbJ2RlZmF1bHQnXSk7XG5cbkJydXNoT3BlcmF0aW9uLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ2JydXNoJztcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGF2YWlsYWJsZSBvcHRpb25zIGZvciB0aGlzIG9wZXJhdGlvblxuICogQHR5cGUge09iamVjdH1cbiAqL1xuQnJ1c2hPcGVyYXRpb24ucHJvdG90eXBlLmF2YWlsYWJsZU9wdGlvbnMgPSB7XG4gIHBhdGhzOiB7IHR5cGU6ICdhcnJheScsICdkZWZhdWx0JzogW10gfVxufTtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgcGF0aCB0aGF0IGNhbiBiZSBkcmF3biBvbiBhIGNhbnZhc1xuICovXG5CcnVzaE9wZXJhdGlvbi5QYXRoID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGF0aChvcGVyYXRpb24sIHRoaWNrbmVzcywgY29sb3IpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGF0aCk7XG5cbiAgICB0aGlzLl90aGlja25lc3MgPSB0aGlja25lc3M7XG4gICAgdGhpcy5fY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLl9jb250cm9sUG9pbnRzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUGF0aCwgW3tcbiAgICBrZXk6ICdyZW5kZXJUb0NhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRvQ2FudmFzKGNhbnZhcykge1xuICAgICAgaWYgKHRoaXMuX2NvbnRyb2xQb2ludHMubGVuZ3RoIDwgMikgcmV0dXJuO1xuXG4gICAgICB2YXIgbGFzdENvbnRyb2xQb2ludCA9IHRoaXMuX2NvbnRyb2xQb2ludHNbMF07XG4gICAgICB2YXIgY29udHJvbFBvaW50ID0gbGFzdENvbnRyb2xQb2ludDtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5fY29udHJvbFBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb250cm9sUG9pbnQgPSB0aGlzLl9jb250cm9sUG9pbnRzW2ldO1xuICAgICAgICBjb250cm9sUG9pbnQucmVuZGVyVG9DYW52YXMoY2FudmFzLCBsYXN0Q29udHJvbFBvaW50KTtcbiAgICAgICAgbGFzdENvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdhZGRDb250cm9sUG9pbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRDb250cm9sUG9pbnQocG9zaXRpb24pIHtcbiAgICAgIHZhciBjb250cm9sUG9pbnQgPSBuZXcgQnJ1c2hPcGVyYXRpb24uQ29udHJvbFBvaW50KHRoaXMsIHBvc2l0aW9uKTtcbiAgICAgIHRoaXMuX2NvbnRyb2xQb2ludHMucHVzaChjb250cm9sUG9pbnQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2dldENvbG9yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29sb3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29sb3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0VGhpY2tuZXNzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VGhpY2tuZXNzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RoaWNrbmVzcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzZXREaXJ0eScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERpcnR5KCkge1xuICAgICAgdGhpcy5fY29udHJvbFBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICBwb2ludC5zZXREaXJ0eSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBhdGg7XG59KSgpO1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjb250cm9sIHBvaW50IG9mIGEgcGF0aFxuICovXG5CcnVzaE9wZXJhdGlvbi5Db250cm9sUG9pbnQgPSAoZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb250cm9sUG9pbnQocGF0aCwgcG9zaXRpb24pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udHJvbFBvaW50KTtcblxuICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgIHRoaXMuX2RyYXduQ2FudmFzZXMgPSBbXTtcbiAgICB0aGlzLl9wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKENvbnRyb2xQb2ludCwgW3tcbiAgICBrZXk6ICdyZW5kZXJUb0NhbnZhcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclRvQ2FudmFzKGNhbnZhcywgbGFzdENvbnRyb2xQb2ludCkge1xuICAgICAgaWYgKHRoaXMuX2RyYXduQ2FudmFzZXMuaW5kZXhPZihjYW52YXMpICE9PSAtMSkge1xuICAgICAgICAvLyBUaGlzIGNvbnRyb2wgcG9pbnQgaGFzIGFscmVhZHkgYmVlbiBkcmF3biBvbiB0aGlzIGNhbnZhcy4gSWdub3JlLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIHZhciBsb25nZXJTaWRlID0gTWF0aC5tYXgoY2FudmFzU2l6ZS54LCBjYW52YXNTaXplLnkpO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbi5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgdmFyIGxhc3RQb3NpdGlvbiA9IGxhc3RDb250cm9sUG9pbnQuZ2V0UG9zaXRpb24oKS5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuXG4gICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgY29udGV4dC5saW5lSm9pbiA9ICdyb3VuZCc7XG4gICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gdGhpcy5fcGF0aC5nZXRDb2xvcigpLnRvSGV4KCk7XG4gICAgICBjb250ZXh0LmxpbmVXaWR0aCA9IHRoaXMuX3BhdGguZ2V0VGhpY2tuZXNzKCkgKiBsb25nZXJTaWRlO1xuICAgICAgY29udGV4dC5tb3ZlVG8obGFzdFBvc2l0aW9uLngsIGxhc3RQb3NpdGlvbi55KTtcbiAgICAgIGNvbnRleHQubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB0aGlzLl9kcmF3bkNhbnZhc2VzLnB1c2goY2FudmFzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRQb3NpdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uLmNsb25lKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2V0RGlydHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREaXJ0eSgpIHtcbiAgICAgIHRoaXMuX2RyYXduQ2FudmFzZXMgPSBbXTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udHJvbFBvaW50O1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQnJ1c2hPcGVyYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9icnVzaC1vcGVyYXRpb24uanNcbiAqKiBtb2R1bGUgaWQgPSA1N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIEExNSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuQTE1RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBBMTVGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKEExNUZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gQTE1RmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBMTVGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQTE1RmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQTE1RmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICAgIGNvbnRyYXN0OiAwLjYzXG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLkJyaWdodG5lc3Moe1xuICAgICAgICBicmlnaHRuZXNzOiAwLjEyXG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgICByZWQ6IFtbMCwgMzhdLCBbOTQsIDk0XSwgWzE0OCwgMTQyXSwgWzE3NSwgMTg3XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMF0sIFs3NywgNTNdLCBbMTcxLCAxOTBdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBibHVlOiBbWzAsIDEwXSwgWzQ4LCA4NV0sIFsxNzQsIDIyOF0sIFsyNTUsIDI1NV1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJzE1JztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnYTE1JztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQTE1RmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEExNUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvYTE1LWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDU4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogQnJlZXplIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5CcmVlemVGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIEJyZWV6ZUZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoQnJlZXplRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBCcmVlemVGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyZWV6ZUZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihCcmVlemVGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCcmVlemVGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIC8vIERlc2F0dXJhdGlvblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgICAgZGVzYXR1cmF0aW9uOiAwLjVcbiAgICAgIH0pKTtcblxuICAgICAgLy8gVG9uZSBjdXJ2ZVxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAwXSwgWzE3MCwgMTcwXSwgWzIxMiwgMjE5XSwgWzIzNCwgMjQyXSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMF0sIFsxNzAsIDE2OF0sIFsyMzQsIDIzMV0sIFsyNTUsIDI1NV1dLFxuICAgICAgICAgIGJsdWU6IFtbMCwgMF0sIFsxNzAsIDE3MF0sIFsyMTIsIDIwOF0sIFsyNTUsIDI1NV1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0JyZWV6ZSc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2JyZWV6ZSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJyZWV6ZUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCcmVlemVGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2JyZWV6ZS1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA1OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIEJXIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5CV0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgQldGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKEJXRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBCV0ZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQldGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQldGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCV0ZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuR3JheXNjYWxlKCkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnQiZXJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnYncnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCV0ZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCV0ZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnctZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNjBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBCV0hhcmQgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkJXSGFyZEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgQldIYXJkRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhCV0hhcmRGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIEJXSGFyZEZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQldIYXJkRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEJXSGFyZEZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJXSGFyZEZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuR3JheXNjYWxlKCkpO1xuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgICBjb250cmFzdDogMS41XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICcxOTIwJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnYndoYXJkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQldIYXJkRmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJXSGFyZEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvYndoYXJkLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDYxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogQ2Vsc2l1cyBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuQ2Vsc2l1c0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgQ2Vsc2l1c0ZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoQ2Vsc2l1c0ZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gQ2Vsc2l1c0ZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2Vsc2l1c0ZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDZWxzaXVzRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2Vsc2l1c0ZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCA2OV0sIFs1NSwgMTEwXSwgWzIwMiwgMjMwXSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgNDRdLCBbODksIDkzXSwgWzE4NSwgMTQxXSwgWzI1NSwgMTg5XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA3Nl0sIFszOSwgODJdLCBbMjE4LCAxMzhdLCBbMjU1LCAxNzFdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdDZWxzaXVzJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnY2Vsc2l1cyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENlbHNpdXNGaWx0ZXI7XG59KShfZmlsdGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ2Vsc2l1c0ZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2Vsc2l1cy1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIENoZXN0IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5DaGVzdEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgQ2hlc3RGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKENoZXN0RmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBDaGVzdEZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlc3RGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2hlc3RGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaGVzdEZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgLy8gVG9uZSBjdXJ2ZVxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAwXSwgWzQ0LCA0NF0sIFsxMjQsIDE0M10sIFsyMjEsIDIwNF0sIFsyNTUsIDI1NV1dLFxuICAgICAgICAgIGdyZWVuOiBbWzAsIDBdLCBbMTMwLCAxMjddLCBbMjEzLCAxOTldLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBibHVlOiBbWzAsIDBdLCBbNTEsIDUyXSwgWzIxOSwgMjA0XSwgWzI1NSwgMjU1XV1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnQ2hlc3QnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdjaGVzdCc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoZXN0RmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENoZXN0RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9jaGVzdC1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA2M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIEZpeGllIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5GaXhpZUZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgRml4aWVGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKEZpeGllRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBGaXhpZUZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRml4aWVGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRml4aWVGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaXhpZUZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgLy8gVG9uZSBjdXJ2ZVxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAwXSwgWzQ0LCAyOF0sIFs2MywgNDhdLCBbMTI4LCAxMzJdLCBbMjM1LCAyNDhdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBncmVlbjogW1swLCAwXSwgWzIwLCAxMF0sIFs2MCwgNDVdLCBbMTkwLCAyMDldLCBbMjExLCAyMzFdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBibHVlOiBbWzAsIDMxXSwgWzQxLCA2Ml0sIFsxNTAsIDE0Ml0sIFsyMzQsIDIxMl0sIFsyNTUsIDIyNF1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0ZpeGllJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnZml4aWUnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaXhpZUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGaXhpZUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZml4aWUtZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNjRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBGb29kIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Gb29kRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBGb29kRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhGb29kRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBGb29kRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb29kRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZvb2RGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb29kRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5TYXR1cmF0aW9uKHtcbiAgICAgICAgc2F0dXJhdGlvbjogMS4zNVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICAgIGNvbnRyYXN0OiAxLjFcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0Zvb2QnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdmb29kJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRm9vZEZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGb29kRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9mb29kLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogRnJpZGdlIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5GcmlkZ2VGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIEZyaWRnZUZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoRnJpZGdlRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBGcmlkZ2VGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyaWRnZUZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGcmlkZ2VGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGcmlkZ2VGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIC8vIFRvbmUgY3VydmVcbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgICByZWQ6IFtbMCwgOV0sIFsyMSwgMTFdLCBbNDUsIDI0XSwgWzI1NSwgMjIwXV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMTJdLCBbMjEsIDIxXSwgWzQyLCA0Ml0sIFsxNTAsIDE1MF0sIFsxNzAsIDE3M10sIFsyNTUsIDIxMF1dLFxuICAgICAgICAgIGJsdWU6IFtbMCwgMjhdLCBbNDMsIDcyXSwgWzEyOCwgMTg1XSwgWzI1NSwgMjIwXV1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnRnJpZGdlJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnZnJpZGdlJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJpZGdlRmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEZyaWRnZUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZnJpZGdlLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogRnJvbnQgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkZyb250RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBGcm9udEZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoRnJvbnRGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIEZyb250RmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcm9udEZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGcm9udEZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyb250RmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICAvLyBUb25lIGN1cnZlXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgICAgcmVkOiBbWzAsIDY1XSwgWzI4LCA2N10sIFs2NywgMTEzXSwgWzEyNSwgMTgzXSwgWzE4NywgMjE3XSwgWzI1NSwgMjI5XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgNTJdLCBbNDIsIDU5XSwgWzEwNCwgMTM0XSwgWzE2OSwgMjA5XSwgWzI1NSwgMjQwXV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA1Ml0sIFs2NSwgNjhdLCBbOTMsIDEwNF0sIFsxNTAsIDE1M10sIFsyNTUsIDE5OF1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0Zyb250JztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnZnJvbnQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcm9udEZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGcm9udEZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvZnJvbnQtZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNjdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBHbGFtIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5HbGFtRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBHbGFtRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhHbGFtRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBHbGFtRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHbGFtRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEdsYW1GaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhHbGFtRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Db250cmFzdCh7XG4gICAgICAgIGNvbnRyYXN0OiAxLjFcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAwXSwgWzk0LCA3NF0sIFsxODEsIDIwNV0sIFsyNTUsIDI1NV1dLFxuICAgICAgICAgIGdyZWVuOiBbWzAsIDBdLCBbMTI3LCAxMjddLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBibHVlOiBbWzAsIDBdLCBbMTAyLCA3M10sIFsyMjcsIDIxM10sIFsyNTUsIDI1NV1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0dsYW0nO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdnbGFtJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR2xhbUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBHbGFtRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9nbGFtLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY4XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogR29iYmxpbiBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuR29iYmxpbkZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgR29iYmxpbkZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoR29iYmxpbkZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gR29iYmxpbkZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR29iYmxpbkZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihHb2JibGluRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoR29iYmxpbkZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuR29iYmxpbigpKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0dvYmJsaW4nO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdnb2JibGluJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gR29iYmxpbkZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBHb2JibGluRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9nb2JibGluLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDY5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogSzEgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLksxRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBLMUZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoSzFGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIEsxRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLMUZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihLMUZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEsxRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICAvLyBUb25lIGN1cnZlXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICBjb250cm9sUG9pbnRzOiBbWzAsIDBdLCBbNTMsIDMyXSwgWzkxLCA4MF0sIFsxNzYsIDIwNV0sIFsyNTUsIDI1NV1dXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNhdHVyYXRpb25cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgICBzYXR1cmF0aW9uOiAwLjlcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0sxJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnazEnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLMUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBLMUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvazEtZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNzBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uLy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxuLyoqXG4gKiBLMiBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuSzJGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIEsyRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhLMkZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gSzJGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEsyRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEsyRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSzJGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIC8vIFRvbmUgY3VydmVcbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIGNvbnRyb2xQb2ludHM6IFtbMCwgMF0sIFs1NCwgMzNdLCBbNzcsIDgyXSwgWzk0LCAxMDNdLCBbMTIyLCAxMjZdLCBbMTc3LCAxOTNdLCBbMjI5LCAyMzJdLCBbMjU1LCAyNTVdXVxuICAgICAgfSkpO1xuXG4gICAgICAvLyBTb2Z0IGNvbG9yIG92ZXJsYXlcbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlNvZnRDb2xvck92ZXJsYXkoe1xuICAgICAgICBjb2xvcjogbmV3IF9saWJDb2xvcjJbJ2RlZmF1bHQnXSg0MCAvIDI1NSwgNDAgLyAyNTUsIDQwIC8gMjU1KVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnSzInO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdrMic7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEsyRmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEsyRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9rMi1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIEs2IEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5LNkZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgSzZGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKEs2RmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBLNkZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSzZGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoSzZGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLNkZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgLy8gU2F0dXJhdGlvblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuU2F0dXJhdGlvbih7XG4gICAgICAgIHNhdHVyYXRpb246IDAuNVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnSzYnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdrNic7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEs2RmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEs2RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9rNi1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3MlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIEtEeW5hbWljIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5LRHluYW1pY0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgS0R5bmFtaWNGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKEtEeW5hbWljRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBLRHluYW1pY0ZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgS0R5bmFtaWNGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoS0R5bmFtaWNGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhLRHluYW1pY0ZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgLy8gVG9uZSBjdXJ2ZVxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgY29udHJvbFBvaW50czogW1swLCAwXSwgWzE3LCAyN10sIFs0NiwgNjldLCBbOTAsIDExMl0sIFsxNTYsIDIwMF0sIFsyMDMsIDI0M10sIFsyNTUsIDI1NV1dXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNhdHVyYXRpb25cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgICBzYXR1cmF0aW9uOiAwLjdcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ0tEeW5hbWljJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAna2R5bmFtaWMnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBLRHluYW1pY0ZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBLRHluYW1pY0ZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNzNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBMZW5pbiBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuTGVuaW5GaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIExlbmluRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhMZW5pbkZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gTGVuaW5GaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExlbmluRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKExlbmluRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTGVuaW5GaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIC8vIERlc2F0dXJhdGlvblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgICAgZGVzYXR1cmF0aW9uOiAwLjRcbiAgICAgIH0pKTtcblxuICAgICAgLy8gVG9uZSBjdXJ2ZVxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAyMF0sIFs0MCwgMjBdLCBbMTA2LCAxMTFdLCBbMTI5LCAxNTNdLCBbMTkwLCAyMjNdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBncmVlbjogW1swLCAyMF0sIFs0MCwgMjBdLCBbNjIsIDQxXSwgWzEwNiwgMTA4XSwgWzEzMiwgMTU5XSwgWzIwMywgMjM3XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA0MF0sIFs0MCwgNDBdLCBbNzMsIDYwXSwgWzEzMywgMTYwXSwgWzE5MSwgMjk3XSwgWzIwMywgMjM3XSwgWzIzNywgMjM5XSwgWzI1NSwgMjU1XV1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnTGVuaW4nO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdsZW5pbic7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExlbmluRmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExlbmluRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9sZW5pbi1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIExvbW8gRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLkxvbW9GaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIExvbW9GaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKExvbW9GaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIExvbW9GaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvbW9GaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTG9tb0ZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKExvbW9GaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIGNvbnRyb2xQb2ludHM6IFtbMCwgMF0sIFs4NywgMjBdLCBbMTMxLCAxNTZdLCBbMTgzLCAyMDVdLCBbMjU1LCAyMDBdXVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnTG9tbyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ2xvbW8nO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMb21vRmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IExvbW9GaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL2xvbW8tZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNzVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBNZWxsb3cgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLk1lbGxvd0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgTWVsbG93RmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhNZWxsb3dGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIE1lbGxvd0ZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVsbG93RmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE1lbGxvd0ZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1lbGxvd0ZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCAwXSwgWzQxLCA4NF0sIFs4NywgMTM0XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMF0sIFsyNTUsIDIxNl1dLFxuICAgICAgICAgIGJsdWU6IFtbMCwgMF0sIFsyNTUsIDEzMV1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ01lbGxvdyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ21lbGxvdyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1lbGxvd0ZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBNZWxsb3dGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIE1vcm5pbmcgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLk1vcm5pbmdGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIE1vcm5pbmdGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKE1vcm5pbmdGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIE1vcm5pbmdGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1vcm5pbmdGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoTW9ybmluZ0ZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE1vcm5pbmdGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgICByZWQ6IFtbMCwgNDBdLCBbMjU1LCAyMzBdXSxcbiAgICAgICAgICBncmVlbjogW1swLCAxMF0sIFsyNTUsIDIyNV1dLFxuICAgICAgICAgIGJsdWU6IFtbMCwgMjBdLCBbMjU1LCAxODFdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLkdsb3coKSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdNb3JuaW5nJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnbW9ybmluZyc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1vcm5pbmdGaWx0ZXI7XG59KShfZmlsdGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gTW9ybmluZ0ZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvbW9ybmluZy1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3N1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIE9yY2hpZCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuT3JjaGlkRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBPcmNoaWRGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKE9yY2hpZEZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gT3JjaGlkRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcmNoaWRGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3JjaGlkRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT3JjaGlkRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICAvLyBUb25lIGN1cnZlXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgICAgcmVkOiBbWzAsIDBdLCBbMTE1LCAxMzBdLCBbMTk1LCAyMTVdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBncmVlbjogW1swLCAwXSwgWzE0OCwgMTUzXSwgWzE3MiwgMjE1XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA0Nl0sIFs1OCwgNzVdLCBbMTc4LCAyMDVdLCBbMjU1LCAyNTVdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFRvbmUgY3VydmVcbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIGNvbnRyb2xQb2ludHM6IFtbMCwgMF0sIFsxMTcsIDE1MV0sIFsxODksIDIxN10sIFsyNTUsIDI1NV1dXG4gICAgICB9KSk7XG5cbiAgICAgIC8vIERlc2F0dXJhdGlvblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdPcmNoaWQnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdvcmNoaWQnO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcmNoaWRGaWx0ZXI7XG59KShfZmlsdGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gT3JjaGlkRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9vcmNoaWQtZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gNzhcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBQb2xhIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5Qb2xhRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBQb2xhRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhQb2xhRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBQb2xhRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2xhRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFBvbGFGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2xhRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgICAgcmVkOiBbWzAsIDBdLCBbOTQsIDc0XSwgWzE4MSwgMjA1XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMF0sIFszNCwgMzRdLCBbOTksIDc2XSwgWzE3NiwgMTkwXSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCAwXSwgWzEwMiwgNzNdLCBbMjI3LCAyMTNdLCBbMjU1LCAyNTVdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgICBjb250cmFzdDogMS41XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdQb2xhIFNYJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAncG9sYSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbGFGaWx0ZXI7XG59KShfZmlsdGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUG9sYUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYS1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA3OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIFBvbGE2NjkgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLlBvbGE2NjlGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIFBvbGE2NjlGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKFBvbGE2NjlGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIFBvbGE2NjlGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbGE2NjlGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9sYTY2OUZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbGE2NjlGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgICByZWQ6IFtbMCwgMF0sIFs1NiwgMThdLCBbMTk2LCAyMDldLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBncmVlbjogW1swLCAzOF0sIFs3MSwgODRdLCBbMjU1LCAyNTVdXSxcbiAgICAgICAgICBibHVlOiBbWzAsIDBdLCBbMTMxLCAxMzNdLCBbMjA0LCAyMTFdLCBbMjU1LCAyNTVdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlNhdHVyYXRpb24oe1xuICAgICAgICBzYXR1cmF0aW9uOiAwLjhcbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuQ29udHJhc3Qoe1xuICAgICAgICBjb250cmFzdDogMS41XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdQb2xhIDY2OSc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3BvbGE2NjknO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb2xhNjY5RmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFBvbGE2NjlGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3BvbGE2NjktZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gODBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBRdW96aSBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuUXVvemlGaWx0ZXJcbiAqIEBleHRlbmRzIHtJbWdseUtpdC5GaWx0ZXJ9XG4gKi9cblxudmFyIFF1b3ppRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhRdW96aUZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gUXVvemlGaWx0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFF1b3ppRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFF1b3ppRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUXVvemlGaWx0ZXIsIFt7XG4gICAga2V5OiAncmVuZGVyJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGZpbHRlclxuICAgICAqIEBwYXJhbSAge1JlbmRlcmVyfSByZW5kZXJlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihyZW5kZXJlcikge1xuICAgICAgdmFyIHN0YWNrID0gbmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlc1N0YWNrKCk7XG5cbiAgICAgIC8vIERlc2F0dXJhdGlvblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuRGVzYXR1cmF0aW9uKHtcbiAgICAgICAgZGVzYXR1cmF0aW9uOiAwLjY1XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFRvbmUgY3VydmVcbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIHJnYkNvbnRyb2xQb2ludHM6IHtcbiAgICAgICAgICByZWQ6IFtbMCwgNTBdLCBbNDAsIDc4XSwgWzExOCwgMTcwXSwgWzE4MSwgMjExXSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMjddLCBbMjgsIDQ1XSwgWzEwOSwgMTU3XSwgWzE1NywgMTk1XSwgWzE3OSwgMjA4XSwgWzIwNiwgMjEyXSwgWzI1NSwgMjQwXV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA1MF0sIFsxMiwgNTVdLCBbNDYsIDEwM10sIFsxMDMsIDE2Ml0sIFsxOTQsIDE4Ml0sIFsyNDEsIDIwMV0sIFsyNTUsIDIxOV1dXG4gICAgICAgIH1cbiAgICAgIH0pKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1F1b3ppJztcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2lkZW50aWZpZXInLFxuXG4gICAgLyoqXG4gICAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIG9wZXJhdGlvbi4gQ2FuIGJlIHVzZWQgdG8gc2VsZWN0XG4gICAgICogdGhlIGFjdGl2ZSBmaWx0ZXIuXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAncXVvemknO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRdW96aUZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBRdW96aUZpbHRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9vcGVyYXRpb25zL2ZpbHRlcnMvcXVvemktZmlsdGVyLmpzXG4gKiogbW9kdWxlIGlkID0gODFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKTtcblxudmFyIF9maWx0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZmlsdGVyKTtcblxuLyoqXG4gKiBTZW1pcmVkIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5TZW1pcmVkRmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBTZW1pcmVkRmlsdGVyID0gKGZ1bmN0aW9uIChfRmlsdGVyKSB7XG4gIF9pbmhlcml0cyhTZW1pcmVkRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBTZW1pcmVkRmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTZW1pcmVkRmlsdGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFNlbWlyZWRGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTZW1pcmVkRmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgICAgcmVkOiBbWzAsIDEyOV0sIFs3NSwgMTUzXSwgWzE4MSwgMjI3XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgOF0sIFsxMTEsIDg1XSwgWzIxMiwgMTU4XSwgWzI1NSwgMjI2XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCA1XSwgWzc1LCAyMl0sIFsxOTMsIDkwXSwgWzI1NSwgMjI5XV1cbiAgICAgICAgfVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5HbG93KCkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnU2VtaSBSZWQnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdzZW1pcmVkJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VtaXJlZEZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTZW1pcmVkRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9zZW1pcmVkLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDgyXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogU3VubnkgRmlsdGVyXG4gKiBAY2xhc3NcbiAqIEBhbGlhcyBJbWdseUtpdC5GaWx0ZXJzLlN1bm55RmlsdGVyXG4gKiBAZXh0ZW5kcyB7SW1nbHlLaXQuRmlsdGVyfVxuICovXG5cbnZhciBTdW5ueUZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoU3VubnlGaWx0ZXIsIF9GaWx0ZXIpO1xuXG4gIGZ1bmN0aW9uIFN1bm55RmlsdGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdW5ueUZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTdW5ueUZpbHRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN1bm55RmlsdGVyLCBbe1xuICAgIGtleTogJ3JlbmRlcicsXG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtSZW5kZXJlcn0gcmVuZGVyZXJcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocmVuZGVyZXIpIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXNTdGFjaygpO1xuXG4gICAgICBzdGFjay5hZGQobmV3IF9maWx0ZXIyWydkZWZhdWx0J10uUHJpbWl0aXZlcy5Ub25lQ3VydmUoe1xuICAgICAgICByZ2JDb250cm9sUG9pbnRzOiB7XG4gICAgICAgICAgcmVkOiBbWzAsIDBdLCBbNjIsIDgyXSwgWzE0MSwgMTU0XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgZ3JlZW46IFtbMCwgMzldLCBbNTYsIDk2XSwgWzE5MiwgMTc2XSwgWzI1NSwgMjU1XV0sXG4gICAgICAgICAgYmx1ZTogW1swLCAwXSwgWzE3NCwgOTldLCBbMjU1LCAyMzVdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLmFkZChuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzLlRvbmVDdXJ2ZSh7XG4gICAgICAgIGNvbnRyb2xQb2ludHM6IFtbMCwgMF0sIFs1NSwgMjBdLCBbMTU4LCAxOTFdLCBbMjU1LCAyNTVdXVxuICAgICAgfSkpO1xuXG4gICAgICBzdGFjay5yZW5kZXIocmVuZGVyZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ25hbWUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgdGhhdCBpcyBkaXNwbGF5ZWQgaW4gdGhlIFVJXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAnU3VubnknO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdzdW5ueSc7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN1bm55RmlsdGVyO1xufSkoX2ZpbHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFN1bm55RmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy9zdW5ueS1maWx0ZXIuanNcbiAqKiBtb2R1bGUgaWQgPSA4M1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9maWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xuXG52YXIgX2ZpbHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9maWx0ZXIpO1xuXG4vKipcbiAqIFRleGFzIEZpbHRlclxuICogQGNsYXNzXG4gKiBAYWxpYXMgSW1nbHlLaXQuRmlsdGVycy5UZXhhc0ZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgVGV4YXNGaWx0ZXIgPSAoZnVuY3Rpb24gKF9GaWx0ZXIpIHtcbiAgX2luaGVyaXRzKFRleGFzRmlsdGVyLCBfRmlsdGVyKTtcblxuICBmdW5jdGlvbiBUZXhhc0ZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4YXNGaWx0ZXIpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoVGV4YXNGaWx0ZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXhhc0ZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuVG9uZUN1cnZlKHtcbiAgICAgICAgcmdiQ29udHJvbFBvaW50czoge1xuICAgICAgICAgIHJlZDogW1swLCA3Ml0sIFs4OSwgOTldLCBbMTc2LCAyMTJdLCBbMjU1LCAyMzddXSxcbiAgICAgICAgICBncmVlbjogW1swLCA0OV0sIFsyNTUsIDE5Ml1dLFxuICAgICAgICAgIGJsdWU6IFtbMCwgNzJdLCBbMjU1LCAxNTFdXVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIHN0YWNrLnJlbmRlcihyZW5kZXJlcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnbmFtZScsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSB0aGF0IGlzIGRpc3BsYXllZCBpbiB0aGUgVUlcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdUZXhhcyc7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpZGVudGlmaWVyJyxcblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBvcGVyYXRpb24uIENhbiBiZSB1c2VkIHRvIHNlbGVjdFxuICAgICAqIHRoZSBhY3RpdmUgZmlsdGVyLlxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ3RleGFzJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4YXNGaWx0ZXI7XG59KShfZmlsdGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVGV4YXNGaWx0ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vb3BlcmF0aW9ucy9maWx0ZXJzL3RleGFzLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDg0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2ZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyk7XG5cbnZhciBfZmlsdGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ZpbHRlcik7XG5cbi8qKlxuICogWDQwMCBGaWx0ZXJcbiAqIEBjbGFzc1xuICogQGFsaWFzIEltZ2x5S2l0LkZpbHRlcnMuWDQwMEZpbHRlclxuICogQGV4dGVuZHMge0ltZ2x5S2l0LkZpbHRlcn1cbiAqL1xuXG52YXIgWDQwMEZpbHRlciA9IChmdW5jdGlvbiAoX0ZpbHRlcikge1xuICBfaW5oZXJpdHMoWDQwMEZpbHRlciwgX0ZpbHRlcik7XG5cbiAgZnVuY3Rpb24gWDQwMEZpbHRlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWDQwMEZpbHRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihYNDAwRmlsdGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoWDQwMEZpbHRlciwgW3tcbiAgICBrZXk6ICdyZW5kZXInLFxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgZmlsdGVyXG4gICAgICogQHBhcmFtICB7UmVuZGVyZXJ9IHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHJlbmRlcmVyKSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgX2ZpbHRlcjJbJ2RlZmF1bHQnXS5QcmltaXRpdmVzU3RhY2soKTtcblxuICAgICAgc3RhY2suYWRkKG5ldyBfZmlsdGVyMlsnZGVmYXVsdCddLlByaW1pdGl2ZXMuWDQwMCgpKTtcblxuICAgICAgc3RhY2sucmVuZGVyKHJlbmRlcmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICduYW1lJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBuYW1lIHRoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ1g0MDAnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG5cbiAgICAvKipcbiAgICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgb3BlcmF0aW9uLiBDYW4gYmUgdXNlZCB0byBzZWxlY3RcbiAgICAgKiB0aGUgYWN0aXZlIGZpbHRlci5cbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICd4NDAwJztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gWDQwMEZpbHRlcjtcbn0pKF9maWx0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBYNDAwRmlsdGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL29wZXJhdGlvbnMvZmlsdGVycy94NDAwLWZpbHRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDg1XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgRmlsZVJlYWRlciwgSW1hZ2UsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDMsIF94NCwgX3g1KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MywgcHJvcGVydHkgPSBfeDQsIHJlY2VpdmVyID0gX3g1OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MyA9IHBhcmVudDsgX3g0ID0gcHJvcGVydHk7IF94NSA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfdmVuZG9yTmF0aXZlUHJvbWlzZU9ubHkgPSByZXF1aXJlKCcuLi8uLi92ZW5kb3IvbmF0aXZlLXByb21pc2Utb25seScpO1xuXG52YXIgX3ZlbmRvck5hdGl2ZVByb21pc2VPbmx5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3ZlbmRvck5hdGl2ZVByb21pc2VPbmx5KTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBfYmFzZVVpID0gcmVxdWlyZSgnLi4vYmFzZS91aScpO1xuXG52YXIgX2Jhc2VVaTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlVWkpO1xuXG52YXIgX2xpYkNhbnZhcyA9IHJlcXVpcmUoJy4vbGliL2NhbnZhcycpO1xuXG52YXIgX2xpYkNhbnZhczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJDYW52YXMpO1xuXG52YXIgX2xpYkZpbGVMb2FkZXIgPSByZXF1aXJlKCcuL2xpYi9maWxlLWxvYWRlcicpO1xuXG52YXIgX2xpYkZpbGVMb2FkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRmlsZUxvYWRlcik7XG5cbnZhciBfbGliSW1hZ2VSZXNpemVyID0gcmVxdWlyZSgnLi9saWIvaW1hZ2UtcmVzaXplcicpO1xuXG52YXIgX2xpYkltYWdlUmVzaXplcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJJbWFnZVJlc2l6ZXIpO1xuXG52YXIgX2xpYldlYmNhbUhhbmRsZXIgPSByZXF1aXJlKCcuL2xpYi93ZWJjYW0taGFuZGxlcicpO1xuXG52YXIgX2xpYldlYmNhbUhhbmRsZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliV2ViY2FtSGFuZGxlcik7XG5cbnZhciBfbGliVG9wQ29udHJvbHMgPSByZXF1aXJlKCcuL2xpYi90b3AtY29udHJvbHMnKTtcblxudmFyIF9saWJUb3BDb250cm9sczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJUb3BDb250cm9scyk7XG5cbnZhciBfbGliU2Nyb2xsYmFyID0gcmVxdWlyZSgnLi9saWIvc2Nyb2xsYmFyJyk7XG5cbnZhciBfbGliU2Nyb2xsYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlNjcm9sbGJhcik7XG5cbnZhciBfY29uc3RhbnRzID0gcmVxdWlyZSgnLi4vLi4vY29uc3RhbnRzJyk7XG5cbnZhciBOaWdodFVJID0gKGZ1bmN0aW9uIChfVUkpIHtcbiAgX2luaGVyaXRzKE5pZ2h0VUksIF9VSSk7XG5cbiAgZnVuY3Rpb24gTmlnaHRVSSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTmlnaHRVSSk7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihOaWdodFVJLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgdGhpcy5fb3BlcmF0aW9uc01hcCA9IHt9O1xuICAgIHRoaXMuX3RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXYgY2xhc3M9XCJpbWdseWtpdFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtbG9hZGluZ092ZXJsYXlcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWxvYWRpbmdPdmVybGF5LWNvbnRlbnRcIj4gPGltZyBzcmM9XCInKyggaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L2xvYWRpbmcuZ2lmJykpKydcIiAvPiA8c3Bhbj4nKyggaXQuaGVscGVycy50cmFuc2xhdGUoJ2dlbmVyaWMubG9hZGluZycpICkrJy4uLjwvc3Bhbj4gPC9kaXY+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtZmxhc2hPdmVybGF5XCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1mbGFzaE92ZXJsYXktY2xvc2VcIj4gPGltZyBzcmM9XCInKyggaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L2Nsb3NlLnBuZycpKSsnXCIgLz4gPC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1mbGFzaE92ZXJsYXktaGVhZGxpbmVcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWZsYXNoT3ZlcmxheS10ZXh0XCI+PC9kaXY+IDwvZGl2PiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udGFpbmVyXCI+ICc7aWYoIWl0Lm9wdGlvbnMudWkuaGlkZUhlYWRlcil7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1oZWFkZXItcm93XCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1oZWFkZXJcIj4gaW1nLmx5IFBob3RvIEVkaXRvciBTREsgJztpZihpdC5vcHRpb25zLnVpLnNob3dDbG9zZUJ1dHRvbil7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jbG9zZS1idXR0b25cIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvY2xvc2UucG5nJykpKydcIiAvPiA8L2Rpdj4gJzt9b3V0Kz0nIDwvZGl2PiA8L2Rpdj4gJzt9b3V0Kz0nICc7aWYoaXQucmVuZGVyQ29udHJvbHMpe291dCs9JyA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtdG9wLWNvbnRyb2xzLXJvd1wiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtdG9wLWNvbnRyb2xzXCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC10b3AtY29udHJvbHMtbGVmdFwiPiAnO2lmKGl0Lm9wdGlvbnMudWkuc2hvd05ld0J1dHRvbil7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1uZXdcIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvdG9wL25ldy5wbmcnKSkrJ1wiIC8+ICcrKCBpdC5oZWxwZXJzLnRyYW5zbGF0ZSgndG9wLWNvbnRyb2xzLm5ldycpICkrJyA8L2Rpdj4gJzt9b3V0Kz0nICc7aWYoaXQub3B0aW9ucy51aS5zaG93RXhwb3J0QnV0dG9uKXtvdXQrPScgPGRpdiBjbGFzcz1cImltZ2x5a2l0LWV4cG9ydFwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC90b3AvZXhwb3J0LnBuZycpKSsnXCIgLz4gJysoIGl0LmhlbHBlcnMudHJhbnNsYXRlKCd0b3AtY29udHJvbHMuZXhwb3J0JykgKSsnIDwvZGl2PiAnO31vdXQrPScgPGRpdiBjbGFzcz1cImltZ2x5a2l0LXVuZG9cIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvdG9wL3VuZG8ucG5nJykpKydcIiAvPiAnKyggaXQuaGVscGVycy50cmFuc2xhdGUoJ3RvcC1jb250cm9scy51bmRvJykgKSsnIDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXRvcC1jb250cm9scy1yaWdodFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtem9vbS1maXRcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXpvb20tbGV2ZWxcIj4nKyggaXQuaGVscGVycy50cmFuc2xhdGUoJ3RvcC1jb250cm9scy56b29tJykgKSsnOiA8c3BhbiBjbGFzcz1cImltZ2x5a2l0LXpvb20tbGV2ZWwtbnVtXCI+MTAwPC9zcGFuPiU8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXpvb20taW5cIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvdG9wL3pvb20taW4ucG5nJykpKydcIiAvPiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXpvb20tb3V0XCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3RvcC96b29tLW91dC5wbmcnKSkrJ1wiIC8+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiAnO31vdXQrPScgPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jb250YWluZXItcm93XCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtY29udGFpbmVyXCI+ICc7aWYoaXQucmVuZGVyV2ViY2FtKXtvdXQrPScgPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1pbm5lci1jb250YWluZXJcIj4gPHZpZGVvIGNsYXNzPVwiaW1nbHlraXQtd2ViY2FtLXZpZGVvXCIgYXV0b3BsYXk+PC92aWRlbz4gPC9kaXY+ICc7fW91dCs9JyAnO2lmKCEoaXQucmVuZGVyU3BsYXNoU2NyZWVuIHx8IGl0LnJlbmRlcldlYmNhbSkpe291dCs9JyA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWlubmVyLWNvbnRhaW5lclwiPiA8Y2FudmFzIGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWRyYWdnYWJsZVwiPjwvY2FudmFzPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWNvbnRyb2xzIGltZ2x5a2l0LWNhbnZhcy1jb250cm9scy1kaXNhYmxlZFwiPjwvZGl2PiA8L2Rpdj4gJzt9b3V0Kz0nICc7aWYoaXQucmVuZGVyU3BsYXNoU2NyZWVuKXtvdXQrPScgPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNwbGFzaC1jb250YWluZXJcIj4gJztpZihpdC5vcHRpb25zLnVpLnNob3dVcGxvYWRCdXR0b24pe291dCs9JyA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLXJvdyBpbWdseWtpdC1zcGxhc2gtcm93LS11cGxvYWRcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNwbGFzaC1jZWxsXCI+IDxpbnB1dCB0eXBlPVwiZmlsZVwiIGNsYXNzPVwiaW1nbHlraXQtdXBsb2FkLWhpZGRlbi1pbnB1dFwiIC8+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3VwbG9hZC5wbmcnKSkrJ1wiIC8+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtY29udGVudFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLWJ1dHRvblwiPicrKCBpdC5oZWxwZXJzLnRyYW5zbGF0ZSgnc3BsYXNoLnVwbG9hZC5oZWFkbGluZScpICkrJzwvZGl2PiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLXRleHRcIj4nKyggaXQuaGVscGVycy50cmFuc2xhdGUoJ3NwbGFzaC51cGxvYWQuZGVzY3JpcHRpb24nKSApKyc8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gJzt9b3V0Kz0nICc7aWYoaXQub3B0aW9ucy51aS5zaG93VXBsb2FkQnV0dG9uICYmIGl0Lm9wdGlvbnMudWkuc2hvd1dlYmNhbUJ1dHRvbil7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtcm93IGltZ2x5a2l0LXNwbGFzaC1yb3ctLW9yXCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtb3JcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNwbGFzaC1vci1saW5lXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtb3Itd29yZFwiPicrKCBpdC5oZWxwZXJzLnRyYW5zbGF0ZSgnc3BsYXNoLm9yJykgKSsnPC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtb3ItbGluZVwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+ICc7fW91dCs9JyAnO2lmKGl0Lm9wdGlvbnMudWkuc2hvd1dlYmNhbUJ1dHRvbil7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtcm93IGltZ2x5a2l0LXNwbGFzaC1yb3ctLWNhbWVyYVwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLWNlbGxcIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvc2h1dHRlci5wbmcnKSkrJ1wiIC8+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zcGxhc2gtY29udGVudFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLWJ1dHRvblwiPicrKCBpdC5oZWxwZXJzLnRyYW5zbGF0ZSgnc3BsYXNoLndlYmNhbS5oZWFkbGluZScpICkrJzwvZGl2PiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc3BsYXNoLXRleHRcIj4nKyggaXQuaGVscGVycy50cmFuc2xhdGUoJ3NwbGFzaC53ZWJjYW0uZGVzY3JpcHRpb24nKSApKyc8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gJzt9b3V0Kz0nIDwvZGl2PiAnO31vdXQrPScgPC9kaXY+IDwvZGl2PiAnO2lmKGl0LnJlbmRlcldlYmNhbSl7b3V0Kz0nIDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1yb3dcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWNvbnRhaW5lclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHNcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXdlYmNhbS1idXR0b25cIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvc2h1dHRlci1idXR0b24ucG5nJykpKydcIiAvPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gJzt9b3V0Kz0nICc7aWYoaXQucmVuZGVyQ29udHJvbHMpe291dCs9JyA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtcm93XCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1jb250YWluZXJcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzXCI+IDxkaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1vdmVydmlld1wiPiA8dWwgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1saXN0XCI+ICc7IGZvciAodmFyIGlkZW50aWZpZXIgaW4gaXQuY29udHJvbHMpIHsgb3V0Kz0nICc7IHZhciBjb250cm9sID0gaXQuY29udHJvbHNbaWRlbnRpZmllcl07IG91dCs9JyA8bGkgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1pdGVtLS13aXRoLWxhYmVsXCIgZGF0YS1pZGVudGlmaWVyPVwiJysoIGNvbnRyb2wuaWRlbnRpZmllcikrJ1wiJztpZihpdC5jb250cm9sc0Rpc2FibGVkKXtvdXQrPScgZGF0YS1kaXNhYmxlZCc7fW91dCs9Jz4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvb3BlcmF0aW9ucy8nICsgY29udHJvbC5pZGVudGlmaWVyICsgJy5wbmcnKSApKydcIiAvPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtbGFiZWxcIj4nKyhpdC5oZWxwZXJzLnRyYW5zbGF0ZSgnb3BlcmF0aW9ucy4nICsgY29udHJvbC5pZGVudGlmaWVyKSkrJzwvZGl2PiA8L2xpPiAnOyB9IG91dCs9JyA8L3VsPiA8L2Rpdj4gPC9kaXY+IDwvZGl2PiA8L2Rpdj4gPC9kaXY+ICc7fW91dCs9JyA8L2Rpdj48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRDb250cm9scyA9IHt9O1xuICAgIHRoaXMuX2hpc3RvcnkgPSBbXTtcbiAgICB0aGlzLl9pbWFnZVJlc2l6ZWQgPSBmYWxzZTtcblxuICAgIC8vIFRoZSBgTmlnaHRgIFVJIGhhcyBhIGZpeGVkIG9wZXJhdGlvbiBvcmRlclxuICAgIHRoaXMuX3ByZWZlcnJlZE9wZXJhdGlvbk9yZGVyID0gW1xuICAgIC8vIEZpcnN0LCBhbGwgb3BlcmF0aW9ucyB0aGF0IGFmZmVjdCB0aGUgaW1hZ2UgZGltZW5zaW9uc1xuICAgICdyb3RhdGlvbicsICdjcm9wJywgJ2ZsaXAnLFxuXG4gICAgLy8gVGhlbiBjb2xvciBvcGVyYXRpb25zIChmaXJzdCBmaWx0ZXJzLCB0aGVuIGZpbmUtdHVuaW5nKVxuICAgICdmaWx0ZXJzJywgJ2NvbnRyYXN0JywgJ2JyaWdodG5lc3MnLCAnc2F0dXJhdGlvbicsXG5cbiAgICAvLyBUaGVuIHBvc3QtcHJvY2Vzc2luZ1xuICAgICdyYWRpYWwtYmx1cicsICd0aWx0LXNoaWZ0JywgJ2ZyYW1lcycsICdzdGlja2VycycsICd0ZXh0JywgJ2JydXNoJ107XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX29wdGlvbnMudWkgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZGVmYXVsdHModGhpcy5fb3B0aW9ucy51aSwge1xuICAgICAgc2hvd05ld0J1dHRvbjogIXRoaXMuX29wdGlvbnMuaW1hZ2UsXG4gICAgICBzaG93VXBsb2FkQnV0dG9uOiB0cnVlLFxuICAgICAgc2hvd1dlYmNhbUJ1dHRvbjogdHJ1ZSxcbiAgICAgIHNob3dIZWFkZXI6IHRydWUsXG4gICAgICBzaG93Q2xvc2VCdXR0b246IGZhbHNlLFxuICAgICAgc2hvd0V4cG9ydEJ1dHRvbjogZmFsc2UsXG4gICAgICBsYW5ndWFnZTogJ2VuJyxcbiAgICAgIG1heE1lZ2FQaXhlbHM6IDEwLFxuICAgICAgJ2V4cG9ydCc6IHt9XG4gICAgfSk7XG5cbiAgICB0aGlzLl9vcHRpb25zLnVpWydleHBvcnQnXSA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5kZWZhdWx0cyh0aGlzLl9vcHRpb25zLnVpWydleHBvcnQnXSwge1xuICAgICAgdHlwZTogX2NvbnN0YW50cy5JbWFnZUZvcm1hdC5KUEVHLFxuICAgICAgcXVhbGl0eTogMC44XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyB0aGlzIFVJXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhOaWdodFVJLCBbe1xuICAgIGtleTogJ3J1bicsXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgVUkgZm9yIHVzZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB0aGlzLl9maXhPcGVyYXRpb25zU3RhY2soKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyTGFuZ3VhZ2VzKCk7XG5cbiAgICAgIHRoaXMuX2xvYWRMYW5ndWFnZSgpO1xuXG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihOaWdodFVJLnByb3RvdHlwZSksICdydW4nLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fb3B0aW9ucy5jb250YWluZXI7XG5cbiAgICAgIHRoaXMuaGlkZUZsYXNoTWVzc2FnZSA9IHRoaXMuaGlkZUZsYXNoTWVzc2FnZS5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLl9jb250cm9sc0NvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY29udHJvbHMnKTtcbiAgICAgIHRoaXMuX2NhbnZhc0NvbnRyb2xzQ29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jYW52YXMtY29udHJvbHMnKTtcbiAgICAgIHRoaXMuX292ZXJ2aWV3Q29udHJvbHNDb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNvbnRyb2xzLW92ZXJ2aWV3Jyk7XG4gICAgICB0aGlzLl9sb2FkaW5nT3ZlcmxheSA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtbG9hZGluZ092ZXJsYXknKTtcbiAgICAgIHRoaXMuX2xvYWRpbmdTcGFuID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1sb2FkaW5nT3ZlcmxheSBzcGFuJyk7XG4gICAgICB0aGlzLl9mbGFzaE92ZXJsYXkgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWZsYXNoT3ZlcmxheScpO1xuICAgICAgdGhpcy5fZmxhc2hIZWFkbGluZSA9IHRoaXMuX2ZsYXNoT3ZlcmxheS5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtZmxhc2hPdmVybGF5LWhlYWRsaW5lJyk7XG4gICAgICB0aGlzLl9mbGFzaFRleHQgPSB0aGlzLl9mbGFzaE92ZXJsYXkucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWZsYXNoT3ZlcmxheS10ZXh0Jyk7XG4gICAgICB0aGlzLl9mbGFzaENsb3NlQnV0dG9uID0gdGhpcy5fZmxhc2hPdmVybGF5LnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1mbGFzaE92ZXJsYXktY2xvc2UnKTtcbiAgICAgIHRoaXMuX2ZsYXNoQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhpZGVGbGFzaE1lc3NhZ2UpO1xuXG4gICAgICB0aGlzLl9oYW5kbGVPdmVydmlldygpO1xuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy5pbWFnZSkge1xuICAgICAgICB0aGlzLl9yZXNpemVJbWFnZUlmTmVjZXNzYXJ5KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmltYWdlKSB7XG4gICAgICAgIHRoaXMuX2luaXRDYW52YXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY29udGV4dC5yZW5kZXJTcGxhc2hTY3JlZW4pIHtcbiAgICAgICAgdGhpcy5faW5pdEZpbGVMb2FkZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMudWkuc2hvd1dlYmNhbUJ1dHRvbikge1xuICAgICAgICAgIHRoaXMuX2hhbmRsZVdlYmNhbUJ1dHRvbigpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRleHQucmVuZGVyV2ViY2FtKSB7XG4gICAgICAgIHRoaXMuX2luaXRXZWJjYW0oKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdFRvcENvbnRyb2xzKCk7XG4gICAgICB0aGlzLl9pbml0Q29udHJvbHMoKTtcblxuICAgICAgaWYgKHRoaXMuX29wdGlvbnMuaW1hZ2UpIHtcbiAgICAgICAgdGhpcy5zaG93Wm9vbSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fb3B0aW9ucy51aS5zaG93Q2xvc2VCdXR0b24pIHtcbiAgICAgICAgdGhpcy5faGFuZGxlQ2xvc2VCdXR0b24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3RvcENvbnRyb2xzKSB7XG4gICAgICAgIHRoaXMuX3RvcENvbnRyb2xzLnVwZGF0ZUV4cG9ydEJ1dHRvbigpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5ydW4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfbG9hZExhbmd1YWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2xvYWRMYW5ndWFnZSgpIHtcbiAgICAgIHRoaXMuX2xhbmd1YWdlID0gdGhpcy5fbGFuZ3VhZ2VzW3RoaXMuX29wdGlvbnMudWkubGFuZ3VhZ2VdO1xuICAgICAgaWYgKCF0aGlzLl9sYW5ndWFnZSkge1xuICAgICAgICB2YXIgYXZhaWxhYmxlTGFuZ3VhZ2VzID0gT2JqZWN0LmtleXModGhpcy5fbGFuZ3VhZ2VzKS5qb2luKCcsICcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbGFuZ3VhZ2UgXFwnJyArIHRoaXMuX29wdGlvbnMudWkubGFuZ3VhZ2UgKyAnXFwnLiBBdmFpbGFibGUgbGFuZ3VhZ2VzIGFyZTogJyArIGF2YWlsYWJsZUxhbmd1YWdlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIFNESyBhdXRvbWF0aWNhbGx5IGFkZHMgUm90YXRpb24gYW5kIEZsaXAgb3BlcmF0aW9ucyBmb3IgaW1hZ2VzXG4gICAgICogdGhhdCBoYXZlIHRoZSB3cm9uZyByb3RhdGlvbiAoaW4gdGhlIEV4aWYgdGFncykuIFNpbmNlIHdlIGhhdmUgYSBzcGVjaWZpY1xuICAgICAqIG9wZXJhdGlvbiBvcmRlciBmb3IgdGhpcyBVSSwgd2UgbmVlZCB0byBwbGFjZSB0aGVtIGNvcnJlY3RseVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZml4T3BlcmF0aW9uc1N0YWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpeE9wZXJhdGlvbnNTdGFjaygpIHtcbiAgICAgIHZhciBvcGVyYXRpb25zU3RhY2sgPSB0aGlzLl9raXQub3BlcmF0aW9uc1N0YWNrO1xuXG4gICAgICB2YXIgbmV3U3RhY2sgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0aW9uc1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zU3RhY2tbaV07XG4gICAgICAgIGlmICghb3BlcmF0aW9uKSBjb250aW51ZTtcblxuICAgICAgICB2YXIgaWRlbnRpZmllciA9IG9wZXJhdGlvbi5pZGVudGlmaWVyO1xuXG4gICAgICAgIHZhciBpbmRleEluU3RhY2sgPSB0aGlzLl9wcmVmZXJyZWRPcGVyYXRpb25PcmRlci5pbmRleE9mKGlkZW50aWZpZXIpO1xuICAgICAgICBuZXdTdGFja1tpbmRleEluU3RhY2tdID0gb3BlcmF0aW9uO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25zTWFwW2lkZW50aWZpZXJdID0gb3BlcmF0aW9uO1xuICAgICAgfVxuICAgICAgdGhpcy5fa2l0Lm9wZXJhdGlvbnNTdGFjayA9IG5ld1N0YWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB3ZWJjYW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRXZWJjYW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFdlYmNhbSgpIHtcbiAgICAgIHRoaXMuX3dlYmNhbSA9IG5ldyBfbGliV2ViY2FtSGFuZGxlcjJbJ2RlZmF1bHQnXSh0aGlzLl9raXQsIHRoaXMpO1xuICAgICAgdGhpcy5fd2ViY2FtLm9uKCdpbWFnZScsIHRoaXMuX29uV2ViY2FtSW1hZ2VUYWtlbi5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB3ZWJjYW0gaW1hZ2UgaGFzIGJlZW4gdGFrZW5cbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25XZWJjYW1JbWFnZVRha2VuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uV2ViY2FtSW1hZ2VUYWtlbihpbWFnZSkge1xuICAgICAgdGhpcy5fb3B0aW9ucy51aS5zdGFydFdpdGhXZWJjYW0gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NldEltYWdlKGltYWdlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSB3ZWJjYW0gYnV0dG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVXZWJjYW1CdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlV2ViY2FtQnV0dG9uKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX29wdGlvbnMuY29udGFpbmVyO1xuXG4gICAgICB2YXIgd2ViY2FtQnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1zcGxhc2gtcm93LS1jYW1lcmEnKTtcbiAgICAgIHdlYmNhbUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX29wdGlvbnMudWkuc3RhcnRXaXRoV2ViY2FtID0gdHJ1ZTtcbiAgICAgICAgX3RoaXMucnVuKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgZmlsZSBsb2FkZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRGaWxlTG9hZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRGaWxlTG9hZGVyKCkge1xuICAgICAgdGhpcy5fZmlsZUxvYWRlciA9IG5ldyBfbGliRmlsZUxvYWRlcjJbJ2RlZmF1bHQnXSh0aGlzLl9raXQsIHRoaXMpO1xuICAgICAgdGhpcy5fZmlsZUxvYWRlci5vbignZmlsZScsIHRoaXMuX29uRmlsZUxvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxvYWRlZCBhIGZpbGUgdXNpbmcgdGhlIEZpbGVMb2FkZXJcbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRmlsZUxvYWRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkZpbGVMb2FkZWQoZmlsZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgcmVhZGVyLm9ubG9hZCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBkYXRhID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuXG4gICAgICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzMi5fc2V0SW1hZ2UoaW1hZ2UpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaW1hZ2Uuc3JjID0gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgIH0pKGZpbGUpO1xuICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgaW1hZ2Ugb3B0aW9uIGFuZCBzdGFydHMgcmVuZGVyaW5nXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NldEltYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEltYWdlKGltYWdlKSB7XG4gICAgICB0aGlzLl9raXQuc2V0SW1hZ2UoaW1hZ2UpO1xuICAgICAgdGhpcy5ydW4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgdG9wIGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0VG9wQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFRvcENvbnRyb2xzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5jb250ZXh0LnJlbmRlckNvbnRyb2xzKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3RvcENvbnRyb2xzID0gbmV3IF9saWJUb3BDb250cm9sczJbJ2RlZmF1bHQnXSh0aGlzLl9raXQsIHRoaXMpO1xuICAgICAgdGhpcy5fdG9wQ29udHJvbHMucnVuKCk7XG5cbiAgICAgIHRoaXMuX3RvcENvbnRyb2xzLm9uKCduZXcnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5fb3BlcmF0aW9uc01hcCA9IHt9O1xuICAgICAgICBfdGhpczMuX2tpdC5vcGVyYXRpb25zU3RhY2sgPSBbXTtcbiAgICAgICAgX3RoaXMzLl9oaXN0b3J5ID0gW107XG4gICAgICAgIF90aGlzMy5fb3B0aW9ucy5pbWFnZSA9IG51bGw7XG4gICAgICAgIF90aGlzMy5ydW4oKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90b3BDb250cm9scy5vbigndW5kbycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLnVuZG8oKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl90b3BDb250cm9scy5vbignZXhwb3J0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczNbJ2V4cG9ydCddKCk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUGFzcyB6b29tIGluIGV2ZW50XG4gICAgICB0aGlzLl90b3BDb250cm9scy5vbignem9vbS1pbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLl9jYW52YXMuem9vbUluKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5fY3VycmVudENvbnRyb2wpIHtcbiAgICAgICAgICAgIF90aGlzMy5fY3VycmVudENvbnRyb2wub25ab29tKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBQYXNzIHpvb20gb3V0IGV2ZW50XG4gICAgICB0aGlzLl90b3BDb250cm9scy5vbignem9vbS1vdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5fY2FudmFzLnpvb21PdXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLl9jdXJyZW50Q29udHJvbCkge1xuICAgICAgICAgICAgX3RoaXMzLl9jdXJyZW50Q29udHJvbC5vblpvb20oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyB0aGUgaW1hZ2UgdG8gZml0IHRoZSBtYXhpbXVtIHRleHR1cmUgc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzaXplSW1hZ2VJZk5lY2Vzc2FyeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNpemVJbWFnZUlmTmVjZXNzYXJ5KCkge1xuICAgICAgdmFyIGltYWdlID0gdGhpcy5fb3B0aW9ucy5pbWFnZTtcblxuICAgICAgdmFyIGltYWdlRGltZW5zaW9ucyA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gICAgICB2YXIgbWVnYVBpeGVscyA9IGltYWdlRGltZW5zaW9ucy54ICogaW1hZ2VEaW1lbnNpb25zLnkgLyAxMDAwMDAwO1xuXG4gICAgICBpZiAobWVnYVBpeGVscyA+IHRoaXMuX29wdGlvbnMudWkubWF4TWVnYVBpeGVscykge1xuICAgICAgICAvLyBEaW1lbnNpb25zIGV4Y2VlZCBgbWF4TWVnYVBpeGVsc2AuIENhbGN1bGF0ZSBuZXcgc2l6ZVxuICAgICAgICB2YXIgcGl4ZWxzQ291bnQgPSB0aGlzLl9vcHRpb25zLnVpLm1heE1lZ2FQaXhlbHMgKiAxMDAwMDAwO1xuICAgICAgICB2YXIgcmF0aW9IViA9IGltYWdlRGltZW5zaW9ucy54IC8gaW1hZ2VEaW1lbnNpb25zLnk7XG4gICAgICAgIHZhciByYXRpb1ZIID0gaW1hZ2VEaW1lbnNpb25zLnkgLyBpbWFnZURpbWVuc2lvbnMueDtcbiAgICAgICAgdmFyIG5ld0RpbWVuc2lvbnMgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKE1hdGguc3FydChwaXhlbHNDb3VudCAqIHJhdGlvSFYpLCBNYXRoLnNxcnQocGl4ZWxzQ291bnQgKiByYXRpb1ZIKSkuZmxvb3IoKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ3Jlc2l6ZWQnLCB7XG4gICAgICAgICAgcmVhc29uOiAnTUFYX01FR0FfUElYRUxTJyxcbiAgICAgICAgICBkaW1lbnNpb25zOiBuZXdEaW1lbnNpb25zLmNsb25lKClcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5kaXNwbGF5Rmxhc2hNZXNzYWdlKHRoaXMudHJhbnNsYXRlKCdnZW5lcmljLndhcm5pbmdfaGVhZGxpbmUnKSwgdGhpcy50cmFuc2xhdGUoJ3dhcm5pbmdzLmltYWdlX3Jlc2l6ZWQnLCB0aGlzLl9vcHRpb25zLnVpLm1heE1lZ2FQaXhlbHMsIG5ld0RpbWVuc2lvbnMueCwgbmV3RGltZW5zaW9ucy55KSwgJ3dhcm5pbmcnKTtcbiAgICAgICAgdGhpcy5faW1hZ2VSZXNpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5pbWFnZSA9IF9saWJJbWFnZVJlc2l6ZXIyWydkZWZhdWx0J10ucmVzaXplKHRoaXMuX29wdGlvbnMuaW1hZ2UsIG5ld0RpbWVuc2lvbnMpO1xuXG4gICAgICAgIC8vIEZsYWcgYXMganBlZyBpbWFnZSBzbyB0aGF0IHRoZSByZXN1bHRpbmcgaW1hZ2Ugd2lsbFxuICAgICAgICAvLyBhbHNvIGluY2x1ZGUgZXhpZiBkYXRhXG4gICAgICAgIHRoaXMuX29wdGlvbnMuaW1hZ2Uuc3JjID0gJ2RhdGE6aW1hZ2UvanBlZztiYXNlNjQsJztcblxuICAgICAgICAvLyBDb3B5IGFscmVhZHkgcGFyc2VkIGV4aWYgZGF0YSwgc2luY2UgdGhlIG9uZSB3ZSBqdXN0XG4gICAgICAgIC8vIGNyZWF0ZWQgZG9lcyBub3QgaGF2ZSBhbnlcbiAgICAgICAgdGhpcy5fa2l0LnNldEltYWdlKHRoaXMuX29wdGlvbnMuaW1hZ2UsIHRoaXMuX2tpdC5leGlmKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aXRpYWxpemVzIHRoZSBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRDYW52YXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENhbnZhcygpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9jYW52YXMgPSBuZXcgX2xpYkNhbnZhczJbJ2RlZmF1bHQnXSh0aGlzLl9raXQsIHRoaXMsIHRoaXMuX29wdGlvbnMpO1xuICAgICAgdGhpcy5fY2FudmFzLm9uKCd6b29tJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczQuX3RvcENvbnRyb2xzLnVwZGF0ZVpvb21MZXZlbCgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9jYW52YXMub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgX3RoaXM0LmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICAgIF90aGlzNC5kaXNwbGF5RXJyb3JNZXNzYWdlKGUuY29kZSB8fCBlLm1lc3NhZ2UpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9jYW52YXMub24oJ3Jlc2l6ZWQnLCBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICBfdGhpczQuZW1pdCgncmVzaXplZCcsIHBheWxvYWQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgdGhlIGdpdmVuIGVycm9yIGtleVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2Rpc3BsYXlFcnJvck1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5RXJyb3JNZXNzYWdlKGtleSkge1xuICAgICAgdmFyIGVyciA9IHRoaXMudHJhbnNsYXRlKCdlcnJvcnMuJyArIGtleSk7XG4gICAgICB0aGlzLmRpc3BsYXlGbGFzaE1lc3NhZ2UoJ0FuIGVycm9yIGhhcyBvY2N1cnJlZCEnLCBlcnIgKyAnICgnICsga2V5ICsgJyknLCAnZXJyb3InKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyBhIGZsYXNoIG1lc3NhZ2Ugd2l0aCB0aGUgZ2l2ZW4gdGl0bGUgYW5kIHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgPSAnbm90aWNlJ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZGlzcGxheUZsYXNoTWVzc2FnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BsYXlGbGFzaE1lc3NhZ2UoaGVhZGxpbmUsIG1lc3NhZ2UpIHtcbiAgICAgIHZhciB0eXBlID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gJ25vdGljZScgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHRoaXMuX2ZsYXNoVGV4dC50ZXh0Q29udGVudCA9IG1lc3NhZ2U7XG4gICAgICB0aGlzLl9mbGFzaEhlYWRsaW5lLnRleHRDb250ZW50ID0gaGVhZGxpbmU7XG4gICAgICB0aGlzLl9mbGFzaE92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgIHRoaXMuX2ZsYXNoT3ZlcmxheS5jbGFzc05hbWUgPSAnaW1nbHlraXQtZmxhc2hPdmVybGF5IGltZ2x5a2l0LWZsYXNoT3ZlcmxheS0tJyArIHR5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGZsYXNoIG1lc3NhZ2VcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hpZGVGbGFzaE1lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlRmxhc2hNZXNzYWdlKCkge1xuICAgICAgdGhpcy5fZmxhc2hPdmVybGF5LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZW5hYmxlZCBvcGVyYXRpb25zXG4gICAgICogQHBhcmFtIHtJbWdseUtpdC5TZWxlY3Rvcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdE9wZXJhdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RPcGVyYXRpb25zKHNlbGVjdG9yKSB7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihOaWdodFVJLnByb3RvdHlwZSksICdzZWxlY3RPcGVyYXRpb25zJywgdGhpcykuY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBvciBjcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBvcGVyYXRpb24gd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdnZXRPckNyZWF0ZU9wZXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yQ3JlYXRlT3BlcmF0aW9uKGlkZW50aWZpZXIpIHtcbiAgICAgIHZhciBfa2l0ID0gdGhpcy5fa2l0O1xuICAgICAgdmFyIG9wZXJhdGlvbnNTdGFjayA9IF9raXQub3BlcmF0aW9uc1N0YWNrO1xuICAgICAgdmFyIHJlZ2lzdGVyZWRPcGVyYXRpb25zID0gX2tpdC5yZWdpc3RlcmVkT3BlcmF0aW9ucztcblxuICAgICAgdmFyIE9wZXJhdGlvbiA9IHJlZ2lzdGVyZWRPcGVyYXRpb25zW2lkZW50aWZpZXJdO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wZXJhdGlvbnNNYXBbaWRlbnRpZmllcl0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIENyZWF0ZSBvcGVyYXRpb25cbiAgICAgICAgdmFyIG9wZXJhdGlvbkluc3RhbmNlID0gbmV3IE9wZXJhdGlvbih0aGlzLl9raXQpO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25zTWFwW2lkZW50aWZpZXJdID0gb3BlcmF0aW9uSW5zdGFuY2U7XG5cbiAgICAgICAgLy8gRmluZCBpbmRleCBpbiBwcmVmZXJyZWQgb3BlcmF0aW9uIG9yZGVyXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuX3ByZWZlcnJlZE9wZXJhdGlvbk9yZGVyLmluZGV4T2YoaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBpbmRleCA9IHRoaXMuX3ByZWZlcnJlZE9wZXJhdGlvbk9yZGVyLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBvcGVyYXRpb25zU3RhY2tbaW5kZXhdID0gb3BlcmF0aW9uSW5zdGFuY2U7XG5cbiAgICAgICAgcmV0dXJuIG9wZXJhdGlvbkluc3RhbmNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wZXJhdGlvbnNNYXBbaWRlbnRpZmllcl07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgb3BlcmF0aW9uIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgZnJvbSB0aGUgc3RhY2tcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlT3BlcmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlT3BlcmF0aW9uKGlkZW50aWZpZXIpIHtcbiAgICAgIGlmICghdGhpcy5fb3BlcmF0aW9uc01hcFtpZGVudGlmaWVyXSkgcmV0dXJuO1xuXG4gICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5fb3BlcmF0aW9uc01hcFtpZGVudGlmaWVyXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9vcGVyYXRpb25zTWFwW2lkZW50aWZpZXJdO1xuXG4gICAgICB2YXIgaW5kZXggPSB0aGlzLl9raXQub3BlcmF0aW9uc1N0YWNrLmluZGV4T2Yob3BlcmF0aW9uKTtcbiAgICAgIHRoaXMuX2tpdC5vcGVyYXRpb25zU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYWxsIGRlZmF1bHQgb3BlcmF0aW9uIGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZWdpc3RlckNvbnRyb2xzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZ2lzdGVyQ29udHJvbHMoKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnZmlsdGVycycsICdmaWx0ZXJzJywgcmVxdWlyZSgnLi9jb250cm9scy9maWx0ZXJzLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgncm90YXRpb24nLCAncm90YXRpb24nLCByZXF1aXJlKCcuL2NvbnRyb2xzL3JvdGF0aW9uLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnZmxpcCcsICdmbGlwJywgcmVxdWlyZSgnLi9jb250cm9scy9mbGlwLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnYnJpZ2h0bmVzcycsICdicmlnaHRuZXNzJywgcmVxdWlyZSgnLi9jb250cm9scy9icmlnaHRuZXNzLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnY29udHJhc3QnLCAnY29udHJhc3QnLCByZXF1aXJlKCcuL2NvbnRyb2xzL2NvbnRyYXN0LWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnc2F0dXJhdGlvbicsICdzYXR1cmF0aW9uJywgcmVxdWlyZSgnLi9jb250cm9scy9zYXR1cmF0aW9uLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnY3JvcCcsICdjcm9wJywgcmVxdWlyZSgnLi9jb250cm9scy9jcm9wLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgncmFkaWFsLWJsdXInLCAncmFkaWFsLWJsdXInLCByZXF1aXJlKCcuL2NvbnRyb2xzL3JhZGlhbC1ibHVyLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgndGlsdC1zaGlmdCcsICd0aWx0LXNoaWZ0JywgcmVxdWlyZSgnLi9jb250cm9scy90aWx0LXNoaWZ0LWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnZnJhbWVzJywgJ2ZyYW1lcycsIHJlcXVpcmUoJy4vY29udHJvbHMvZnJhbWVzLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnc3RpY2tlcnMnLCAnc3RpY2tlcnMnLCByZXF1aXJlKCcuL2NvbnRyb2xzL3N0aWNrZXJzLWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgndGV4dCcsICd0ZXh0JywgcmVxdWlyZSgnLi9jb250cm9scy90ZXh0LWNvbnRyb2wnKSk7XG4gICAgICB0aGlzLnJlZ2lzdGVyQ29udHJvbCgnYnJ1c2gnLCAnYnJ1c2gnLCByZXF1aXJlKCcuL2NvbnRyb2xzL2JydXNoLWNvbnRyb2wnKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYWxsIGRlZmF1bHQgbGFuZ3VhZ2VzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZWdpc3Rlckxhbmd1YWdlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWdpc3Rlckxhbmd1YWdlcygpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYW5ndWFnZSgnZW4nLCByZXF1aXJlKCcuL2xhbmcvZW4uanNvbicpKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJMYW5ndWFnZSgnZGUnLCByZXF1aXJlKCcuL2xhbmcvZGUuanNvbicpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBvdmVydmlldyBidXR0b24gY2xpY2sgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVPdmVydmlldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVPdmVydmlldygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMuY29udGV4dC5yZW5kZXJDb250cm9scykgcmV0dXJuO1xuXG4gICAgICB2YXIgaXRlbXNMaXN0ID0gdGhpcy5fb3ZlcnZpZXdDb250cm9sc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCd1bCcpO1xuICAgICAgaWYgKCFpdGVtc0xpc3QucGFyZW50Tm9kZSA9PT0gdGhpcy5fb3ZlcnZpZXdDb250cm9sc0NvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbGlzdEl0ZW1zID0gW10uZmlsdGVyLmNhbGwoaXRlbXNMaXN0LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyksIGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gZWwucGFyZW50Tm9kZSA9PT0gaXRlbXNMaXN0O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCBjbGljayBldmVudHMgdG8gYWxsIGl0ZW1zXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IGxpc3RJdGVtc1tpXTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWRlbnRpZmllcicpO1xuICAgICAgICBsaXN0SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczUuc3dpdGNoVG9Db250cm9sKGlkZW50aWZpZXIpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIG92ZXJ2aWV3IGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19lbmFibGVDb250cm9scycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbmFibGVDb250cm9scygpIHtcbiAgICAgIHZhciBpdGVtc0xpc3QgPSB0aGlzLl9vdmVydmlld0NvbnRyb2xzQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ3VsJyk7XG4gICAgICBpZiAoIWl0ZW1zTGlzdC5wYXJlbnROb2RlID09PSB0aGlzLl9vdmVydmlld0NvbnRyb2xzQ29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBsaXN0SXRlbXMgPSBbXS5maWx0ZXIuY2FsbChpdGVtc0xpc3QucXVlcnlTZWxlY3RvckFsbCgnbGknKSwgZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC5wYXJlbnROb2RlID09PSBpdGVtc0xpc3Q7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50cyB0byBhbGwgaXRlbXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IGxpc3RJdGVtc1tpXTtcbiAgICAgICAgbGlzdEl0ZW0ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiBhbiBvdmVydmlldyBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzd2l0Y2hUb0NvbnRyb2wnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2l0Y2hUb0NvbnRyb2woaWRlbnRpZmllcikge1xuICAgICAgaWYgKHRoaXMuY29udGV4dC5jb250cm9sc0Rpc2FibGVkKSByZXR1cm47XG4gICAgICB0aGlzLl9vdmVydmlld0NvbnRyb2xzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgIHRoaXMuX3Njcm9sbGJhci5yZW1vdmUoKTtcblxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDb250cm9sKSB7XG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb250cm9sLmxlYXZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRDb250cm9sID0gdGhpcy5fcmVnaXN0ZXJlZENvbnRyb2xzW2lkZW50aWZpZXJdO1xuICAgICAgdGhpcy5fY3VycmVudENvbnRyb2wuZW50ZXIoKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRDb250cm9sLm9uY2UoJ2JhY2snLCB0aGlzLl9zd2l0Y2hUb092ZXJ2aWV3LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIGJhY2sgdG8gdGhlIG92ZXJ2aWV3IGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zd2l0Y2hUb092ZXJ2aWV3JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N3aXRjaFRvT3ZlcnZpZXcoKSB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudENvbnRyb2wpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudENvbnRyb2wubGVhdmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY3VycmVudENvbnRyb2wgPSBudWxsO1xuICAgICAgdGhpcy5fb3ZlcnZpZXdDb250cm9sc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICAgIHRoaXMuX2luaXRTY3JvbGxiYXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGNvbnRyb2xzIGZvciBhbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvcGVyYXRpb25JZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtDb250cm9sfSBDb250cm9sQ2xhc3NcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlZ2lzdGVyQ29udHJvbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyQ29udHJvbChpZGVudGlmaWVyLCBvcGVyYXRpb25JZGVudGlmaWVyLCBDb250cm9sQ2xhc3MpIHtcbiAgICAgIGlmICghdGhpcy5pc09wZXJhdGlvblNlbGVjdGVkKG9wZXJhdGlvbklkZW50aWZpZXIpKSByZXR1cm47XG5cbiAgICAgIHZhciBpbnN0YW5jZSA9IG5ldyBDb250cm9sQ2xhc3ModGhpcy5fa2l0LCB0aGlzKTtcbiAgICAgIHRoaXMuX3JlZ2lzdGVyZWRDb250cm9sc1tpZGVudGlmaWVyXSA9IGluc3RhbmNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSByZWdpc3RlcmVkIGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0Q29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENvbnRyb2xzKCkge1xuICAgICAgZm9yICh2YXIgaWRlbnRpZmllciBpbiB0aGlzLl9yZWdpc3RlcmVkQ29udHJvbHMpIHtcbiAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLl9yZWdpc3RlcmVkQ29udHJvbHNbaWRlbnRpZmllcl07XG4gICAgICAgIGNvbnRyb2wuc2V0Q29udGFpbmVycyh0aGlzLl9jb250cm9sc0NvbnRhaW5lciwgdGhpcy5fY2FudmFzQ29udHJvbHNDb250YWluZXIpO1xuICAgICAgICBjb250cm9sLmluaXQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdFNjcm9sbGJhcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXN0b20gc2Nyb2xsYmFyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0U2Nyb2xsYmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTY3JvbGxiYXIoKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dC5yZW5kZXJDb250cm9scykgcmV0dXJuO1xuXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fY29udHJvbHNDb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNvbnRyb2xzLWxpc3QnKS5wYXJlbnROb2RlO1xuICAgICAgdGhpcy5fc2Nyb2xsYmFyID0gbmV3IF9saWJTY3JvbGxiYXIyWydkZWZhdWx0J10oY29udGFpbmVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBjbGljayBldmVudCBvbiB0aGUgY2xvc2UgYnV0dG9uLCBlbWl0cyBhIGBjbG9zZWAgZXZlbnRcbiAgICAgKiB3aGVuIGNsaWNraW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVDbG9zZUJ1dHRvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVDbG9zZUJ1dHRvbigpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICB2YXIgY2xvc2VCdXR0b24gPSB0aGlzLl9vcHRpb25zLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY2xvc2UtYnV0dG9uJyk7XG4gICAgICBjbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgX3RoaXM2LmVtaXQoJ2Nsb3NlJyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZS1yZW5kZXJzIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3JlbmRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIGlmICh0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgdGhpcy5fY2FudmFzLnJlbmRlcigpWydjYXRjaCddKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCBhY3RpdmUgb3BlcmF0aW9uc1xuICAgICAqIEB0eXBlIHtPYmplY3QuPFN0cmluZyxPcGVyYXRpb24+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncGF1c2UnLFxuXG4gICAgLyoqXG4gICAgICogUGF1c2VzIHRoZSBVSS4gT3BlcmF0aW9uIHVwZGF0ZXMgd2lsbCBub3QgY2F1c2UgYSByZS1yZW5kZXJpbmdcbiAgICAgKiBvZiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdW1lcyB0aGUgVUkgYW5kIHJlLXJlbmRlcnMgdGhlIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVyZW5kZXIgPSB0cnVlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZXN1bWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXN1bWUoKSB7XG4gICAgICB2YXIgcmVyZW5kZXIgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzBdO1xuXG4gICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICAgIGlmIChyZXJlbmRlcikge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGdpdmVuIG9wZXJhdGlvbiBhbmQgb3B0aW9ucyB0byB0aGUgaGlzdG9yeSBzdGFja1xuICAgICAqIEBwYXJhbSB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCAqPn0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZXhpc3RlbnRcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgaGlzdG9yeSBpdGVtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRIaXN0b3J5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSGlzdG9yeShvcGVyYXRpb24sIG9wdGlvbnMsIGV4aXN0ZW50KSB7XG4gICAgICB2YXIgaGlzdG9yeUl0ZW0gPSB7IG9wZXJhdGlvbjogb3BlcmF0aW9uLCBvcHRpb25zOiBvcHRpb25zLCBleGlzdGVudDogZXhpc3RlbnQgfTtcbiAgICAgIHRoaXMuX2hpc3RvcnkucHVzaChoaXN0b3J5SXRlbSk7XG4gICAgICB0aGlzLl90b3BDb250cm9scy51cGRhdGVVbmRvQnV0dG9uKCk7XG5cbiAgICAgIHRoaXMuZW1pdCgnaGlzdG9yeS1hZGQnLCBoaXN0b3J5SXRlbSk7XG5cbiAgICAgIHJldHVybiBoaXN0b3J5SXRlbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgem9vbSBjb250cm9sXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlWm9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGVab29tKCkge1xuICAgICAgdGhpcy5fdG9wQ29udHJvbHMuaGlkZVpvb20oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgem9vbSBjb250cm9sXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzaG93Wm9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dab29tKCkge1xuICAgICAgdGhpcy5fdG9wQ29udHJvbHMuc2hvd1pvb20oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUYWtlcyB0aGUgbGFzdCBoaXN0b3J5IGl0ZW0gYW5kIGFwcGxpZXMgaXRzIG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3VuZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmRvKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBsYXN0SXRlbSA9IHRoaXMuX2hpc3RvcnkucG9wKCk7XG4gICAgICB2YXIgcHJvbWlzZSA9IF92ZW5kb3JOYXRpdmVQcm9taXNlT25seTJbJ2RlZmF1bHQnXS5yZXNvbHZlKCk7XG4gICAgICBpZiAobGFzdEl0ZW0pIHtcbiAgICAgICAgdGhpcy5lbWl0KCdoaXN0b3J5LXVuZG8nLCBsYXN0SXRlbSk7XG5cbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IGxhc3RJdGVtLm9wZXJhdGlvbjtcbiAgICAgICAgdmFyIGV4aXN0ZW50ID0gbGFzdEl0ZW0uZXhpc3RlbnQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gbGFzdEl0ZW0ub3B0aW9ucztcblxuICAgICAgICBpZiAoIWV4aXN0ZW50KSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVPcGVyYXRpb24ob3BlcmF0aW9uLmlkZW50aWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wZXJhdGlvbiA9IHRoaXMuZ2V0T3JDcmVhdGVPcGVyYXRpb24ob3BlcmF0aW9uLmlkZW50aWZpZXIpO1xuICAgICAgICAgIG9wZXJhdGlvbi5zZXQob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuY2FudmFzLnpvb21Ub0ZpdCh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3RvcENvbnRyb2xzLnVwZGF0ZVVuZG9CdXR0b24oKTtcblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjdXJyZW50IGNvbnRyb2wgcmVwcmVzZW50cyB0aGUgbmV3IHZhbHVlXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoX3RoaXM3Ll9jdXJyZW50Q29udHJvbCkge1xuICAgICAgICAgIF90aGlzNy5fY3VycmVudENvbnRyb2wudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9ydHMgdGhlIGN1cnJlbnQgaW1hZ2Ugd2l0aCB0aGUgZGVmYXVsdCBzZXR0aW5nc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnZXhwb3J0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4cG9ydCgpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuXG4gICAgICB0aGlzLmRpc3BsYXlMb2FkaW5nTWVzc2FnZSh0aGlzLnRyYW5zbGF0ZSgnZ2VuZXJpYy5leHBvcnRpbmcnKSArICcuLi4nKTtcblxuICAgICAgdmFyIHJlbmRlclR5cGUgPSBfY29uc3RhbnRzLlJlbmRlclR5cGUuREFUQVVSTDtcblxuICAgICAgLy8gQ2hlY2sgaWYgbXNUb0Jsb2IgaXMgYXZhaWxhYmxlXG4gICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBpZiAodHlwZW9mIGNhbnZhcy5tc1RvQmxvYiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVuZGVyVHlwZSA9IF9jb25zdGFudHMuUmVuZGVyVHlwZS5NU0JMT0I7XG4gICAgICB9XG5cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczguX2tpdC5yZW5kZXIocmVuZGVyVHlwZSwgX3RoaXM4Ll9vcHRpb25zLnVpWydleHBvcnQnXS50eXBlLCBfdGhpczguX29wdGlvbnMudWlbJ2V4cG9ydCddLmRpbWVuc2lvbnMsIF90aGlzOC5fb3B0aW9ucy51aVsnZXhwb3J0J10ucXVhbGl0eSkudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHN3aXRjaCAocmVuZGVyVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBfY29uc3RhbnRzLlJlbmRlclR5cGUuREFUQVVSTDpcbiAgICAgICAgICAgICAgdmFyIHVybCA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jcmVhdGVCbG9iVVJJRnJvbURhdGFVUkkoZGF0YSk7XG4gICAgICAgICAgICAgIHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgICAgICAgICB2YXIgZXh0ZW5zaW9uID0gX3RoaXM4Ll9vcHRpb25zLnVpWydleHBvcnQnXS50eXBlLnNwbGl0KCcvJykucG9wKCk7XG4gICAgICAgICAgICAgIGxpbmsuZG93bmxvYWQgPSAnaW1nbHlraXQtZXhwb3J0LicgKyBleHRlbnNpb247XG4gICAgICAgICAgICAgIGxpbmsuaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgICAgICAgbGluay5jbGljaygpO1xuICAgICAgICAgICAgICAvLyBDbGVhbnVwIHRoZSBET01cbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIF9jb25zdGFudHMuUmVuZGVyVHlwZS5NU0JMT0I6XG4gICAgICAgICAgICAgIG5hdmlnYXRvci5tc1NhdmVCbG9iKGRhdGEsICdpbWdseWtpdC1leHBvcnQucG5nJyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzOC5oaWRlTG9hZGluZ01lc3NhZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9LCAxMDAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEaXNwbGF5cyB0aGUgZ2l2ZW4gbWVzc2FnZSBpbnNpZGUgdGhlIGxvYWRpbmcgb3ZlcmxheVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdkaXNwbGF5TG9hZGluZ01lc3NhZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNwbGF5TG9hZGluZ01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgdGhpcy5fbG9hZGluZ1NwYW4udGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgdGhpcy5fbG9hZGluZ092ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGxvYWRpbmcgbWVzc2FnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaGlkZUxvYWRpbmdNZXNzYWdlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZUxvYWRpbmdNZXNzYWdlKCkge1xuICAgICAgdGhpcy5fbG9hZGluZ092ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdW5kbyBoaXN0b3J5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gJ25pZ2h0JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdvcGVyYXRpb25zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRpb25zTWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFsbCByZWdpc3RlcmVkIGNvbnRyb2xzXG4gICAgICogQHR5cGUge09iamVjdC48U3RyaW5nLENvbnRyb2w+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udHJvbHMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JlZ2lzdGVyZWRDb250cm9scztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgdGVtcGxhdGUgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKE5pZ2h0VUkucHJvdG90eXBlKSwgJ2NvbnRleHQnLCB0aGlzKTtcbiAgICAgIGNvbnRleHQuY29udHJvbHMgPSB0aGlzLl9yZWdpc3RlcmVkQ29udHJvbHM7XG4gICAgICBjb250ZXh0LnJlbmRlclNwbGFzaFNjcmVlbiA9ICF0aGlzLl9vcHRpb25zLmltYWdlICYmICF0aGlzLl9vcHRpb25zLnVpLnN0YXJ0V2l0aFdlYmNhbTtcbiAgICAgIGNvbnRleHQucmVuZGVyQ29udHJvbHMgPSAhIXRoaXMuX29wdGlvbnMuaW1hZ2U7XG4gICAgICBjb250ZXh0LnJlbmRlcldlYmNhbSA9IHRoaXMuX29wdGlvbnMudWkuc3RhcnRXaXRoV2ViY2FtO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnaGlzdG9yeScsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGlzdG9yeTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZmlsZSBsb2FkZXJcbiAgICAgKiBAdHlwZSB7RmlsZUxvYWRlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2ZpbGVMb2FkZXInLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVMb2FkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFzIHRoZSBpbWFnZSBiZWVuIHJlc2l6ZWQgaW5pdGlhbGx5P1xuICAgICAqIEB0eXBlIHtCb29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaW1hZ2VSZXNpemVkJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbWFnZVJlc2l6ZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE5pZ2h0VUk7XG59KShfYmFzZVVpMlsnZGVmYXVsdCddKTtcblxuTmlnaHRVSS5Db250cm9sID0gcmVxdWlyZSgnLi9jb250cm9scy9jb250cm9sJyk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IE5pZ2h0VUk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvdWkuanNcbiAqKiBtb2R1bGUgaWQgPSA4NlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vbGliL2V2ZW50LWVtaXR0ZXInKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRXZlbnRFbWl0dGVyKTtcblxudmFyIF9oZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzJyk7XG5cbnZhciBfaGVscGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9oZWxwZXJzKTtcblxudmFyIEJhc2VVSSA9IChmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQmFzZVVJLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBCYXNlVUkoa2l0LCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VVSSk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihCYXNlVUkucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2tpdCA9IGtpdDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9vcHRpb25zLnVpID0gdGhpcy5fb3B0aW9ucy51aSB8fCB7fTtcbiAgICB0aGlzLl9vcGVyYXRpb25zID0gW107XG4gICAgdGhpcy5faGVscGVycyA9IG5ldyBfaGVscGVyczJbJ2RlZmF1bHQnXSh0aGlzLmtpdCwgdGhpcywgb3B0aW9ucyk7XG4gICAgdGhpcy5fbGFuZ3VhZ2VzID0ge307XG4gICAgdGhpcy5zZWxlY3RPcGVyYXRpb25zKG51bGwpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByZXBhcmVzIHRoZSBVSSBmb3IgdXNlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhCYXNlVUksIFt7XG4gICAga2V5OiAncnVuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcnVuKCkge1xuICAgICAgdGhpcy5fYXR0YWNoKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0gIHtTdHJpbmd9IGlkZW50aWZpZXJcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IG9iamVjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVnaXN0ZXJMYW5ndWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyTGFuZ3VhZ2UoaWRlbnRpZmllciwgb2JqZWN0KSB7XG4gICAgICB0aGlzLl9sYW5ndWFnZXNbaWRlbnRpZmllcl0gPSBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdHJhbnNsYXRpb24gZm9yIGBrZXlgXG4gICAgICogQHBhcmFtICB7U3RyaW5nfSBrZXlcbiAgICAgKiBAcGFyYW0gIHtBcnJheS48U3RyaW5nPn0gYXJnc1xuICAgICAqIEByZXR1cm4ge1N0cmluZ31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3RyYW5zbGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRyYW5zbGF0ZShrZXkpIHtcbiAgICAgIHZhciBzdHIgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZmV0Y2godGhpcy5fbGFuZ3VhZ2UsIGtleSwgJ3RyYW5zbGF0aW9uLW1pc3NpbmcnKTtcblxuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07XG4gICAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCckJyArIChpICsgMSksIGFyZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhpcyBVSVxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfYXR0YWNoJyxcblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYW5kIGF0dGFjaGVzIHRoZSBVSSBIVE1MXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2F0dGFjaCgpIHtcbiAgICAgIGlmICh0aGlzLl9vcHRpb25zLmNvbnRhaW5lciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jhc2VVSSNhdHRhY2g6IE5vIGNvbnRhaW5lciBzZXQuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBodG1sID0gdGhpcy5fcmVuZGVyKCk7XG4gICAgICB0aGlzLl9vcHRpb25zLmNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXG4gICAgICAvLyBDb250YWluZXIgaGFzIHRvIGJlIHBvc2l0aW9uOiByZWxhdGl2ZVxuICAgICAgdGhpcy5fb3B0aW9ucy5jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHRlbXBsYXRlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl90ZW1wbGF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdCYXNlVUkjX3JlbmRlcjogTm8gdGVtcGxhdGUgc2V0LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGUodGhpcy5jb250ZXh0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBlbmFibGVkIG9wZXJhdGlvbnNcbiAgICAgKiBAcGFyYW0ge0ltZ2x5S2l0LlNlbGVjdG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0T3BlcmF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdE9wZXJhdGlvbnMoc2VsZWN0b3IpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkT3BlcmF0aW9ucyA9IHRoaXMuX2tpdC5yZWdpc3RlcmVkT3BlcmF0aW9ucztcblxuICAgICAgdmFyIG9wZXJhdGlvbklkZW50aWZpZXJzID0gT2JqZWN0LmtleXMocmVnaXN0ZXJlZE9wZXJhdGlvbnMpO1xuXG4gICAgICB2YXIgc2VsZWN0ZWRPcGVyYXRpb25zID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLnNlbGVjdChvcGVyYXRpb25JZGVudGlmaWVycywgc2VsZWN0b3IpO1xuICAgICAgdGhpcy5fb3BlcmF0aW9ucyA9IHNlbGVjdGVkT3BlcmF0aW9ucy5tYXAoZnVuY3Rpb24gKGlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRPcGVyYXRpb25zW2lkZW50aWZpZXJdO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgZ2l2ZW4gb3BlcmF0aW9uIHRvIHRoZSBhdmFpbGFibGUgb3BlcmF0aW9uc1xuICAgICAqIEBwYXJhbSB7T3BlcmF0aW9ufSBvcGVyYXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2FkZE9wZXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE9wZXJhdGlvbihvcGVyYXRpb24pIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbnMucHVzaChvcGVyYXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBvcGVyYXRpb24gd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllciBpcyBzZWxlY3RlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpc09wZXJhdGlvblNlbGVjdGVkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNPcGVyYXRpb25TZWxlY3RlZChpZGVudGlmaWVyKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uSWRlbnRpZmllcnMgPSB0aGlzLl9vcGVyYXRpb25zLm1hcChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHJldHVybiBvcGVyYXRpb24ucHJvdG90eXBlLmlkZW50aWZpZXI7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvcGVyYXRpb25JZGVudGlmaWVycy5pbmRleE9mKGlkZW50aWZpZXIpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byB0aGUgdGVtcGxhdGUgcmVuZGVyZXJcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaWRlbnRpZmllcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdjb250ZXh0JyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9wZXJhdGlvbnM6IHRoaXMuX29wZXJhdGlvbnMsXG4gICAgICAgIGhlbHBlcnM6IHRoaXMuX2hlbHBlcnMsXG4gICAgICAgIG9wdGlvbnM6IHRoaXMuX29wdGlvbnNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIERPTSBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7RE9NRWxlbWVudH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbnRhaW5lcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbGVjdGVkIC8gYWN0aXZlIG9wZXJhdGlvbnNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPEltZ2x5S2l0Lk9wZXJhdGlvbj59XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdvcGVyYXRpb25zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vcGVyYXRpb25zO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBvcHRpb25zXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ29wdGlvbnMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGNhbnZhcyBvYmplY3RcbiAgICAgKiBAdHlwZSB7Q2FudmFzfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY2FudmFzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGhlbHBlcnNcbiAgICAgKiBAdHlwZSB7SGVscGVyc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hlbHBlcnMnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlbHBlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGltYWdlXG4gICAgICogQHR5cGUge0ltYWdlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnaW1hZ2UnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuaW1hZ2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VVSTtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCYXNlVUk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvYmFzZS91aS5qc1xuICoqIG1vZHVsZSBpZCA9IDg3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbnZhciBIZWxwZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSGVscGVycyhraXQsIHVpLCBvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhlbHBlcnMpO1xuXG4gICAgdGhpcy5fa2l0ID0ga2l0O1xuICAgIHRoaXMuX3VpID0gdWk7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGVscGVycywgW3tcbiAgICBrZXk6ICdhc3NldFBhdGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhc3NldFBhdGgoYXNzZXQpIHtcbiAgICAgIHZhciBwYXRoID0gdGhpcy5fb3B0aW9ucy5hc3NldHNVcmwgKyAnLycgKyBhc3NldDtcblxuICAgICAgdmFyIGFzc2V0UGF0aFJlc29sdmVyID0gdGhpcy5fdWkub3B0aW9ucy51aS5hc3NldFBhdGhSZXNvbHZlcjtcbiAgICAgIGlmICh0eXBlb2YgYXNzZXRQYXRoUmVzb2x2ZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhdGggPSBhc3NldFBhdGhSZXNvbHZlcihwYXRoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAndHJhbnNsYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNsYXRlKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3VpLnRyYW5zbGF0ZShrZXkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBIZWxwZXJzO1xufSkoKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gSGVscGVycztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9iYXNlL2hlbHBlcnMuanNcbiAqKiBtb2R1bGUgaWQgPSA4OFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94NCwgX3g1LCBfeDYpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3g0LCBwcm9wZXJ0eSA9IF94NSwgcmVjZWl2ZXIgPSBfeDY7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3g0ID0gcGFyZW50OyBfeDUgPSBwcm9wZXJ0eTsgX3g2ID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyID0gcmVxdWlyZSgnLi4vLi4vLi4vcmVuZGVyZXJzL3dlYmdsLXJlbmRlcmVyJyk7XG5cbnZhciBfcmVuZGVyZXJzV2ViZ2xSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyKTtcblxudmFyIF9yZW5kZXJlcnNDYW52YXNSZW5kZXJlciA9IHJlcXVpcmUoJy4uLy4uLy4uL3JlbmRlcmVycy9jYW52YXMtcmVuZGVyZXInKTtcblxudmFyIF9yZW5kZXJlcnNDYW52YXNSZW5kZXJlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZW5kZXJlcnNDYW52YXNSZW5kZXJlcik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgX2xpYkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9ldmVudC1lbWl0dGVyJyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkV2ZW50RW1pdHRlcik7XG5cbnZhciBfdmVuZG9yUHJvbWlzZSA9IHJlcXVpcmUoJy4uLy4uLy4uL3ZlbmRvci9wcm9taXNlJyk7XG5cbnZhciBfdmVuZG9yUHJvbWlzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92ZW5kb3JQcm9taXNlKTtcblxudmFyIENhbnZhcyA9IChmdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ2FudmFzLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBDYW52YXMoa2l0LCB1aSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW52YXMpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ2FudmFzLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5fdWkgPSB1aTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl91aS5jb250YWluZXI7XG5cbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNhbnZhcy1jb250YWluZXInKTtcbiAgICB0aGlzLl9jYW52YXNJbm5lckNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY2FudmFzLWlubmVyLWNvbnRhaW5lcicpO1xuICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NhbnZhc0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCdjYW52YXMnKTtcbiAgICB0aGlzLl9pbWFnZSA9IHRoaXMuX29wdGlvbnMuaW1hZ2U7XG4gICAgdGhpcy5fcm91bmRab29tQnkgPSAwLjE7XG4gICAgdGhpcy5faXNGaXJzdFJlbmRlciA9IHRydWU7XG5cbiAgICAvLyBNb3VzZSBldmVudCBjYWxsYmFja3MgYm91bmQgdG8gdGhlIGNsYXNzIGNvbnRleHRcbiAgICB0aGlzLl9kcmFnT25Nb3VzZWRvd24gPSB0aGlzLl9kcmFnT25Nb3VzZWRvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9kcmFnT25Nb3VzZW1vdmUgPSB0aGlzLl9kcmFnT25Nb3VzZW1vdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9kcmFnT25Nb3VzZXVwID0gdGhpcy5fZHJhZ09uTW91c2V1cC5iaW5kKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSByZW5kZXJlciwgc2V0cyB0aGUgem9vbSBsZXZlbCBhbmQgaW5pdGlhbGx5XG4gICAqIHJlbmRlcnMgdGhlIG9wZXJhdGlvbnMgc3RhY2tcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKENhbnZhcywgW3tcbiAgICBrZXk6ICdydW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBydW4oKSB7XG4gICAgICB0aGlzLl9pbml0UmVuZGVyZXIoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbml0aWFsIHpvb20gbGV2ZWxcbiAgICAgIHRoaXMuX3pvb21MZXZlbCA9IHRoaXMuX2dldEluaXRpYWxab29tTGV2ZWwoKTtcbiAgICAgIHRoaXMuX3NpemUgPSBudWxsO1xuXG4gICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgdGhpcy5fY2VudGVyQ2FudmFzKCk7XG4gICAgICB0aGlzLl9oYW5kbGVEcmFnKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZ2V0UHJvY2Vzc2VkRGltZW5zaW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2Nlc3NlZERpbWVuc2lvbnMoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgc3RhY2sgPSB0aGlzLnNhbml0aXplZFN0YWNrO1xuXG4gICAgICB2YXIgc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5faW1hZ2Uud2lkdGgsIHRoaXMuX2ltYWdlLmhlaWdodCk7XG4gICAgICBzdGFjay5mb3JFYWNoKGZ1bmN0aW9uIChvcGVyYXRpb24pIHtcbiAgICAgICAgc2l6ZSA9IG9wZXJhdGlvbi5nZXROZXdEaW1lbnNpb25zKF90aGlzLl9yZW5kZXJlciwgc2l6ZSk7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY3VycmVudCBvcGVyYXRpb25zIHN0YWNrXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBpbml0aWFsIHNpemVcbiAgICAgIHZhciBpbml0aWFsU2l6ZSA9IHRoaXMuX3JlbmRlcmVyLmdldEluaXRpYWxEaW1lbnNpb25zRm9yU3RhY2sodGhpcy5zYW5pdGl6ZWRTdGFjaykubXVsdGlwbHkodGhpcy5fem9vbUxldmVsKTtcbiAgICAgIHRoaXMuX3NldENhbnZhc1NpemUoaW5pdGlhbFNpemUpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRTaXplKGluaXRpYWxTaXplKTtcblxuICAgICAgLy8gUmVzZXQgZnJhbWVidWZmZXJzXG4gICAgICB0aGlzLl9yZW5kZXJlci5yZXNldCgpO1xuXG4gICAgICAvLyBSdW4gdGhlIG9wZXJhdGlvbnMgc3RhY2tcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuc2FuaXRpemVkU3RhY2s7XG4gICAgICB0aGlzLl91cGRhdGVTdGFja0RpcnR5U3RhdGVzKHN0YWNrKTtcblxuICAgICAgdmFyIHZhbGlkYXRpb25Qcm9taXNlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3BlcmF0aW9uID0gc3RhY2tbaV07XG4gICAgICAgIHZhbGlkYXRpb25Qcm9taXNlcy5wdXNoKG9wZXJhdGlvbi52YWxpZGF0ZVNldHRpbmdzKCkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3ZlbmRvclByb21pc2UyWydkZWZhdWx0J10uYWxsKHZhbGlkYXRpb25Qcm9taXNlcykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdoZW4gdXNpbmcgV2ViR0wsIHJlc2l6ZSB0aGUgaW1hZ2UgdG8gbWF4IHRleHR1cmUgc2l6ZSBpZiBuZWNlc3NhcnlcbiAgICAgICAgaWYgKF90aGlzMi5faXNGaXJzdFJlbmRlciAmJiBfdGhpczIuX3JlbmRlcmVyLmlkZW50aWZpZXIgPT09ICd3ZWJnbCcpIHtcblxuICAgICAgICAgIGlmIChfdGhpczIuX2ltYWdlLndpZHRoID4gX3RoaXMyLl9yZW5kZXJlci5tYXhUZXh0dXJlU2l6ZSB8fCBfdGhpczIuX2ltYWdlLmhlaWdodCA+IF90aGlzMi5fcmVuZGVyZXIubWF4VGV4dHVyZVNpemUpIHtcbiAgICAgICAgICAgIF90aGlzMi5fdWkuZGlzcGxheUxvYWRpbmdNZXNzYWdlKCdSZXNpemluZy4uLicpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBfdmVuZG9yUHJvbWlzZTJbJ2RlZmF1bHQnXShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fcmVuZGVyZXIucHJlcGFyZUltYWdlKF90aGlzMi5faW1hZ2UpLnRoZW4oZnVuY3Rpb24gKGltYWdlKSB7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5lbWl0KCdyZXNpemVkJywge1xuICAgICAgICAgICAgICAgICAgICByZWFzb246ICdNQVhfVEVYVFVSRV9TSVpFJyxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczogbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzMi5fdWkuaGlkZUxvYWRpbmdNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgICBfdGhpczIuX29wdGlvbnMuaW1hZ2UgPSBpbWFnZTtcbiAgICAgICAgICAgICAgICAgIF90aGlzMi5faW1hZ2UgPSBfdGhpczIuX29wdGlvbnMuaW1hZ2U7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSlbJ2NhdGNoJ10oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE9uIGZpcnN0IHJlbmRlciwgZHJhdyB0aGUgaW1hZ2UgdG8gdGhlIGlucHV0IHRleHR1cmVcbiAgICAgICAgaWYgKF90aGlzMi5faXNGaXJzdFJlbmRlciB8fCBfdGhpczIuX3JlbmRlcmVyLmNvbnN0cnVjdG9yLmlkZW50aWZpZXIgPT09ICdjYW52YXMnKSB7XG4gICAgICAgICAgX3RoaXMyLl9pc0ZpcnN0UmVuZGVyID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fcmVuZGVyZXIuZHJhd0ltYWdlKF90aGlzMi5faW1hZ2UpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLy8gUmVuZGVyIHRoZSBvcGVyYXRpb25zIHN0YWNrXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9taXNlID0gX3ZlbmRvclByb21pc2UyWydkZWZhdWx0J10ucmVzb2x2ZSgpO1xuXG4gICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHN0YWNrW2ldO1xuICAgICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uLnJlbmRlcihfdGhpczIuX3JlbmRlcmVyKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgX2xvb3AoaSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9KVxuICAgICAgLy8gUmVuZGVyIHRoZSBmaW5hbCBpbWFnZVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLl9yZW5kZXJlci5yZW5kZXJGaW5hbCgpO1xuICAgICAgfSlcbiAgICAgIC8vIFVwZGF0ZSB0aGUgbWFyZ2lucyBhbmQgYm91bmRhcmllc1xuICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX3N0b3JlQ2FudmFzU2l6ZSgpO1xuICAgICAgICBfdGhpczIuX3VwZGF0ZUNvbnRhaW5lclNpemUoKTtcbiAgICAgICAgX3RoaXMyLl91cGRhdGVDYW52YXNNYXJnaW5zKCk7XG4gICAgICAgIF90aGlzMi5fYXBwbHlCb3VuZGFyaWVzKCk7XG4gICAgICB9KVsnY2F0Y2gnXShmdW5jdGlvbiAoZSkge1xuICAgICAgICBfdGhpczIuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGltYWdlIHRvIHRoZSBnaXZlbiBvbmVcbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2V0SW1hZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbWFnZShpbWFnZSkge1xuICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICB0aGlzLl9jZW50ZXJDYW52YXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmNyZWFzZSB6b29tIGxldmVsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd6b29tSW4nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB6b29tSW4oKSB7XG4gICAgICB0aGlzLl9pc0luaXRpYWxab29tID0gZmFsc2U7XG5cbiAgICAgIHZhciB6b29tTGV2ZWwgPSBNYXRoLnJvdW5kKHRoaXMuX3pvb21MZXZlbCAqIDEwMCk7XG4gICAgICB2YXIgcm91bmRab29tQnkgPSBNYXRoLnJvdW5kKHRoaXMuX3JvdW5kWm9vbUJ5ICogMTAwKTtcbiAgICAgIHZhciBpbml0aWFsWm9vbUxldmVsID0gTWF0aC5yb3VuZCh0aGlzLl9nZXRJbml0aWFsWm9vbUxldmVsKCkgKiAxMDApO1xuXG4gICAgICAvLyBSb3VuZCB1cCBpZiBuZWVkZWRcbiAgICAgIGlmICh6b29tTGV2ZWwgJSByb3VuZFpvb21CeSAhPT0gMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSBNYXRoLmNlaWwoem9vbUxldmVsIC8gcm91bmRab29tQnkpICogcm91bmRab29tQnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB6b29tTGV2ZWwgKz0gcm91bmRab29tQnk7XG4gICAgICB9XG5cbiAgICAgIHpvb21MZXZlbCA9IE1hdGgubWluKGluaXRpYWxab29tTGV2ZWwgKiAyLCB6b29tTGV2ZWwpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCAvIDEwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjcmVhc2Ugem9vbSBsZXZlbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnem9vbU91dCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHpvb21PdXQoKSB7XG4gICAgICB0aGlzLl9pc0luaXRpYWxab29tID0gZmFsc2U7XG5cbiAgICAgIHZhciB6b29tTGV2ZWwgPSBNYXRoLnJvdW5kKHRoaXMuX3pvb21MZXZlbCAqIDEwMCk7XG4gICAgICB2YXIgcm91bmRab29tQnkgPSBNYXRoLnJvdW5kKHRoaXMuX3JvdW5kWm9vbUJ5ICogMTAwKTtcbiAgICAgIHZhciBpbml0aWFsWm9vbUxldmVsID0gTWF0aC5yb3VuZCh0aGlzLl9nZXRJbml0aWFsWm9vbUxldmVsKCkgKiAxMDApO1xuXG4gICAgICAvLyBSb3VuZCB1cCBpZiBuZWVkZWRcbiAgICAgIGlmICh6b29tTGV2ZWwgJSByb3VuZFpvb21CeSAhPT0gMCkge1xuICAgICAgICB6b29tTGV2ZWwgPSBNYXRoLmZsb29yKHpvb21MZXZlbCAvIHJvdW5kWm9vbUJ5KSAqIHJvdW5kWm9vbUJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgem9vbUxldmVsIC09IHJvdW5kWm9vbUJ5O1xuICAgICAgfVxuXG4gICAgICB6b29tTGV2ZWwgPSBNYXRoLm1heChpbml0aWFsWm9vbUxldmVsLCB6b29tTGV2ZWwpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Wm9vbUxldmVsKHpvb21MZXZlbCAvIDEwMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyBhbmQgcG9zaXRpb25zIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge1ZlY3RvcjJ9IFtzaXplXVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q2FudmFzU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDYW52YXNTaXplKHNpemUpIHtcbiAgICAgIHNpemUgPSBzaXplIHx8IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcbiAgICAgIHNpemUgPSBzaXplLmNsb25lKCkuZmxvb3IoKTtcblxuICAgICAgaWYgKHRoaXMuX2NhbnZhcy53aWR0aCA9PT0gc2l6ZS54ICYmIHRoaXMuX2NhbnZhcy5oZWlnaHQgPT09IHNpemUueSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHNpemUueDtcbiAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBzaXplLnk7XG5cbiAgICAgIHRoaXMuX3N0b3JlQ2FudmFzU2l6ZSgpO1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBjb250YWluZXIgc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQ29udGFpbmVyU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVDb250YWluZXJTaXplKCkge1xuICAgICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgdGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUud2lkdGggPSBzaXplLnggKyAncHgnO1xuICAgICAgdGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZS55ICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1lbWJlcnMgdGhlIGNhbnZhcyBzaXplXG4gICAgICogQGNvbW1lbnQgVGhpcyB3YXMgaW50cm9kdWNlZCBiZWNhdXNlIHRoZSBjYW52YXMgc2l6ZSB3YXMgbm90IGFsd2F5c1xuICAgICAqICAgICAgICAgIGNvcnJlY3QgZHVlIHRvIHNvbWUgcmFjZSBjb25kaXRpb25zLiBOb3cgdGhhdCBwcm9taXNlcyB3b3JrXG4gICAgICogICAgICAgICAgcHJvcGVybHksIGRvIHdlIHN0aWxsIG5lZWQgdGhpcz9cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3N0b3JlQ2FudmFzU2l6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9yZUNhbnZhc1NpemUoKSB7XG4gICAgICB0aGlzLl9zaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENlbnRlcnMgdGhlIGNhbnZhcyBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfY2VudGVyQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NlbnRlckNhbnZhcygpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX21heFNpemUuZGl2aWRlKDIpO1xuXG4gICAgICB0aGlzLl9jYW52YXNJbm5lckNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9jYW52YXNJbm5lckNvbnRhaW5lci5zdHlsZS50b3AgPSBwb3NpdGlvbi55ICsgJ3B4JztcblxuICAgICAgdGhpcy5fdXBkYXRlQ2FudmFzTWFyZ2lucygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNhbnZhcyBtYXJnaW5zIHNvIHRoYXQgdGhleSBhcmUgdGhlIG5lZ2F0aXZlIGhhbGYgd2lkdGhcbiAgICAgKiBhbmQgaGVpZ2h0IG9mIHRoZSBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZUNhbnZhc01hcmdpbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQ2FudmFzTWFyZ2lucygpIHtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIG1hcmdpbiA9IGNhbnZhc1NpemUuZGl2aWRlKDIpLm11bHRpcGx5KC0xKTtcbiAgICAgIHRoaXMuX2NhbnZhc0lubmVyQ29udGFpbmVyLnN0eWxlLm1hcmdpbkxlZnQgPSBtYXJnaW4ueCArICdweCc7XG4gICAgICB0aGlzLl9jYW52YXNJbm5lckNvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPSBtYXJnaW4ueSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgem9vbSBsZXZlbCwgcmUtcmVuZGVycyB0aGUgY2FudmFzIGFuZFxuICAgICAqIHJlcG9zaXRpb25zIGl0XG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHpvb21MZXZlbFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVuZGVyID0gdHJ1ZVxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbml0aWFsWm9vbSA9IGZhbHNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldFpvb21MZXZlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFpvb21MZXZlbCh6b29tTGV2ZWwpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVuZGVyID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBpc0luaXRpYWxab29tID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHRoaXMuX3pvb21MZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgIHRoaXMuX2lzSW5pdGlhbFpvb20gPSBpc0luaXRpYWxab29tO1xuXG4gICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgIHRoaXMuc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl91cGRhdGVDYW52YXNNYXJnaW5zKCk7XG4gICAgICAgICAgX3RoaXMzLl9hcHBseUJvdW5kYXJpZXMoKTtcbiAgICAgICAgICBfdGhpczMuZW1pdCgnem9vbScpOyAvLyB3aWxsIGJlIHJlZGlyZWN0ZWQgdG8gdG9wIGNvbnRyb2xzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVDYW52YXNNYXJnaW5zKCk7XG4gICAgICAgICAgdGhpcy5fYXBwbHlCb3VuZGFyaWVzKCk7XG4gICAgICAgICAgdGhpcy5lbWl0KCd6b29tJyk7IC8vIHdpbGwgYmUgcmVkaXJlY3RlZCB0byB0b3AgY29udHJvbHNcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYWxsIG9wZXJhdGlvbnMgdG8gZGlydHlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NldEFsbE9wZXJhdGlvbnNUb0RpcnR5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0QWxsT3BlcmF0aW9uc1RvRGlydHkoKSB7XG4gICAgICB2YXIgb3BlcmF0aW9uc1N0YWNrID0gdGhpcy5fa2l0Lm9wZXJhdGlvbnNTdGFjaztcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcGVyYXRpb25zU3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNTdGFja1tpXTtcbiAgICAgICAgaWYgKCFvcGVyYXRpb24pIGNvbnRpbnVlO1xuICAgICAgICBvcGVyYXRpb24uZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBhbGwgb3BlcmF0aW9uc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXRBbGxPcGVyYXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRBbGxPcGVyYXRpb25zKCkge1xuICAgICAgdmFyIG9wZXJhdGlvbnNTdGFjayA9IHRoaXMuX2tpdC5vcGVyYXRpb25zU3RhY2s7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BlcmF0aW9uc1N0YWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBvcGVyYXRpb24gPSBvcGVyYXRpb25zU3RhY2tbaV07XG4gICAgICAgIGlmICghb3BlcmF0aW9uKSBjb250aW51ZTtcbiAgICAgICAgb3BlcmF0aW9uLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaW5pdGlhbCB6b29tIGxldmVsIHNvIHRoYXQgdGhlIGltYWdlIGZpdHMgdGhlIG1heGltdW1cbiAgICAgKiBjYW52YXMgc2l6ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0SW5pdGlhbFpvb21MZXZlbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRJbml0aWFsWm9vbUxldmVsKCkge1xuICAgICAgdmFyIG5hdGl2ZURpbWVuc2lvbnMgPSB0aGlzLl9yZW5kZXJlci5nZXRPdXRwdXREaW1lbnNpb25zRm9yU3RhY2sodGhpcy5zYW5pdGl6ZWRTdGFjayk7XG4gICAgICB2YXIgZml0RGltZW5zaW9ucyA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5yZXNpemVWZWN0b3JUb0ZpdChuYXRpdmVEaW1lbnNpb25zLCB0aGlzLl9tYXhTaXplKTtcblxuICAgICAgcmV0dXJuIGZpdERpbWVuc2lvbnMuZGl2aWRlKG5hdGl2ZURpbWVuc2lvbnMpLng7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHJlbmRlcmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0UmVuZGVyZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdFJlbmRlcmVyKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGlmIChfcmVuZGVyZXJzV2ViZ2xSZW5kZXJlcjJbJ2RlZmF1bHQnXS5pc1N1cHBvcnRlZCgpICYmIHRoaXMuX29wdGlvbnMucmVuZGVyZXIgIT09ICdjYW52YXMnKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyID0gbmV3IF9yZW5kZXJlcnNXZWJnbFJlbmRlcmVyMlsnZGVmYXVsdCddKG51bGwsIHRoaXMuX2NhbnZhcywgdGhpcy5faW1hZ2UpO1xuICAgICAgICB0aGlzLl93ZWJnbEVuYWJsZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChfcmVuZGVyZXJzQ2FudmFzUmVuZGVyZXIyWydkZWZhdWx0J10uaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlciA9IG5ldyBfcmVuZGVyZXJzQ2FudmFzUmVuZGVyZXIyWydkZWZhdWx0J10obnVsbCwgdGhpcy5fY2FudmFzLCB0aGlzLl9pbWFnZSk7XG4gICAgICAgIHRoaXMuX3dlYmdsRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVuZGVyZXIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIENhbnZhcyBub3IgV2ViR0wgcmVuZGVyZXIgYXJlIHN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcmVuZGVyZXIub24oJ25ldy1jYW52YXMnLCBmdW5jdGlvbiAoY2FudmFzKSB7XG4gICAgICAgIF90aGlzNC5fc2V0Q2FudmFzKGNhbnZhcyk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIF90aGlzNC5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9yZW5kZXJlci5vbigncmVzZXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5yZXNldEFsbE9wZXJhdGlvbnMoKTtcbiAgICAgICAgX3RoaXM0Ll9pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgX3RoaXM0LnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwbGFjZXMgdGhlIGNhbnZhcyB3aXRoIHRoZSBnaXZlbiBjYW52YXMsIHVwZGF0ZXMgbWFyZ2lucyBldGNcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0Q2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldENhbnZhcyhjYW52YXMpIHtcbiAgICAgIHZhciBjYW52YXNQYXJlbnQgPSB0aGlzLl9jYW52YXMucGFyZW50Tm9kZTtcbiAgICAgIGNhbnZhc1BhcmVudC5yZW1vdmVDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgICAgdGhpcy5fY2FudmFzID0gY2FudmFzO1xuICAgICAgY2FudmFzUGFyZW50LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUNhbnZhc01hcmdpbnMoKTtcbiAgICAgIHRoaXMuX2FwcGx5Qm91bmRhcmllcygpO1xuICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyU2l6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURyYWcoKSB7XG4gICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fZHJhZ09uTW91c2Vkb3duKTtcbiAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fZHJhZ09uTW91c2Vkb3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0ZWQgdG91Y2hpbmcgLyBjbGlja2luZyB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZHJhZ09uTW91c2Vkb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdPbk1vdXNlZG93bihlKSB7XG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgY2FudmFzWCA9IHBhcnNlSW50KHRoaXMuX2NhbnZhc0lubmVyQ29udGFpbmVyLnN0eWxlLmxlZnQsIDEwKTtcbiAgICAgIHZhciBjYW52YXNZID0gcGFyc2VJbnQodGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUudG9wLCAxMCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2RyYWdPbk1vdXNlbW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9kcmFnT25Nb3VzZW1vdmUpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fZHJhZ09uTW91c2V1cCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2RyYWdPbk1vdXNldXApO1xuXG4gICAgICAvLyBSZW1lbWJlciBpbml0aWFsIHBvc2l0aW9uXG4gICAgICB0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5faW5pdGlhbENhbnZhc1Bvc2l0aW9uID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXNYLCBjYW52YXNZKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBjYW52YXNcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19kcmFnT25Nb3VzZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZHJhZ09uTW91c2Vtb3ZlKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIG5ld01vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHZhciBtb3VzZURpZmYgPSBuZXdNb3VzZVBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuICAgICAgdmFyIG5ld1Bvc2l0aW9uID0gdGhpcy5faW5pdGlhbENhbnZhc1Bvc2l0aW9uLmNsb25lKCkuYWRkKG1vdXNlRGlmZik7XG5cbiAgICAgIHRoaXMuX2NhbnZhc0lubmVyQ29udGFpbmVyLnN0eWxlLmxlZnQgPSBuZXdQb3NpdGlvbi54ICsgJ3B4JztcbiAgICAgIHRoaXMuX2NhbnZhc0lubmVyQ29udGFpbmVyLnN0eWxlLnRvcCA9IG5ld1Bvc2l0aW9uLnkgKyAncHgnO1xuXG4gICAgICB0aGlzLl9hcHBseUJvdW5kYXJpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoZSBjYW52YXMgcG9zaXRpb25zIGFyZSB3aXRoaW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2FwcGx5Qm91bmRhcmllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseUJvdW5kYXJpZXMoKSB7XG4gICAgICB2YXIgeCA9IHBhcnNlSW50KHRoaXMuX2NhbnZhc0lubmVyQ29udGFpbmVyLnN0eWxlLmxlZnQsIDEwKTtcbiAgICAgIHZhciB5ID0gcGFyc2VJbnQodGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUudG9wLCAxMCk7XG4gICAgICB2YXIgY2FudmFzUG9zaXRpb24gPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKHgsIHkpO1xuXG4gICAgICAvLyBCb3VuZGFyaWVzXG4gICAgICB2YXIgYm91bmRhcmllcyA9IHRoaXMuX2JvdW5kYXJpZXM7XG4gICAgICBjYW52YXNQb3NpdGlvbi54ID0gTWF0aC5taW4oYm91bmRhcmllcy5tYXgueCwgTWF0aC5tYXgoYm91bmRhcmllcy5taW4ueCwgY2FudmFzUG9zaXRpb24ueCkpO1xuICAgICAgY2FudmFzUG9zaXRpb24ueSA9IE1hdGgubWluKGJvdW5kYXJpZXMubWF4LnksIE1hdGgubWF4KGJvdW5kYXJpZXMubWluLnksIGNhbnZhc1Bvc2l0aW9uLnkpKTtcblxuICAgICAgdGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUubGVmdCA9IGNhbnZhc1Bvc2l0aW9uLnggKyAncHgnO1xuICAgICAgdGhpcy5fY2FudmFzSW5uZXJDb250YWluZXIuc3R5bGUudG9wID0gY2FudmFzUG9zaXRpb24ueSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcGVkIGRyYWdnaW5nIHRoZSBjYW52c2FcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19kcmFnT25Nb3VzZXVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2RyYWdPbk1vdXNldXAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9kcmFnT25Nb3VzZW1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fZHJhZ09uTW91c2Vtb3ZlKTtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2RyYWdPbk1vdXNldXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9kcmFnT25Nb3VzZXVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcG9zaXRpb24gYm91bmRhcmllcyBmb3IgdGhlIGNhbnZhcyBpbnNpZGUgdGhlIGNvbnRhaW5lclxuICAgICAqIEB0eXBlIHtPYmplY3QuPFZlY3RvcjI+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlU3RhY2tEaXJ0eVN0YXRlcycsXG5cbiAgICAvKipcbiAgICAgKiBGaW5kIHRoZSBmaXJzdCBkaXJ0eSBvcGVyYXRpb24gb2YgdGhlIHN0YWNrIGFuZCBzZXRzIGFsbCBmb2xsb3dpbmdcbiAgICAgKiBvcGVyYXRpb25zIHRvIGRpcnR5XG4gICAgICogQHBhcmFtIHtBcnJheS48T3BlcmF0aW9uPn0gc3RhY2tcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3RhY2tEaXJ0eVN0YXRlcyhzdGFjaykge1xuICAgICAgdmFyIGRpcnR5Rm91bmQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG9wZXJhdGlvbiA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoIW9wZXJhdGlvbikgY29udGludWU7XG4gICAgICAgIGlmIChvcGVyYXRpb24uZGlydHkpIHtcbiAgICAgICAgICBkaXJ0eUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkaXJ0eUZvdW5kKSB7XG4gICAgICAgICAgb3BlcmF0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFpvb21zIHRoZSBjYW52YXMgc28gdGhhdCBpdCBmaXRzIHRoZSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlbmRlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnem9vbVRvRml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gem9vbVRvRml0KCkge1xuICAgICAgdmFyIHJlbmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMF07XG5cbiAgICAgIHZhciBpbml0aWFsWm9vbUxldmVsID0gdGhpcy5fZ2V0SW5pdGlhbFpvb21MZXZlbCgpO1xuICAgICAgcmV0dXJuIHRoaXMuc2V0Wm9vbUxldmVsKGluaXRpYWxab29tTGV2ZWwsIHJlbmRlciwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSByZW5kZXJlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVzZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnJlc2V0KHRydWUpO1xuICAgICAgdGhpcy5fa2l0Lm9wZXJhdGlvbnNTdGFjayA9IFtdO1xuICAgICAgdGhpcy5faXNGaXJzdFJlbmRlciA9IHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb3BlcmF0aW9ucyBzdGFjayB3aXRob3V0IGZhbHN5IHZhbHVlc1xuICAgICAqIEB0eXBlIHtBcnJheS48T3BlcmF0aW9uPn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19ib3VuZGFyaWVzJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9jYW52YXMud2lkdGgsIHRoaXMuX2NhbnZhcy5oZWlnaHQpO1xuICAgICAgdmFyIG1heFNpemUgPSB0aGlzLl9tYXhTaXplO1xuXG4gICAgICB2YXIgZGlmZiA9IGNhbnZhc1NpemUuY2xvbmUoKS5zdWJ0cmFjdChtYXhTaXplKS5tdWx0aXBseSgtMSk7XG5cbiAgICAgIHZhciBib3VuZGFyaWVzID0ge1xuICAgICAgICBtaW46IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oZGlmZi54LCBkaWZmLnkpLFxuICAgICAgICBtYXg6IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMCwgMClcbiAgICAgIH07XG5cbiAgICAgIGlmIChjYW52YXNTaXplLnggPCBtYXhTaXplLngpIHtcbiAgICAgICAgYm91bmRhcmllcy5taW4ueCA9IGRpZmYueCAvIDI7XG4gICAgICAgIGJvdW5kYXJpZXMubWF4LnggPSBkaWZmLnggLyAyO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FudmFzU2l6ZS55IDwgbWF4U2l6ZS55KSB7XG4gICAgICAgIGJvdW5kYXJpZXMubWluLnkgPSBkaWZmLnkgLyAyO1xuICAgICAgICBib3VuZGFyaWVzLm1heC55ID0gZGlmZi55IC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhhbGZDYW52YXNTaXplID0gY2FudmFzU2l6ZS5jbG9uZSgpLmRpdmlkZSgyKTtcbiAgICAgIGJvdW5kYXJpZXMubWluLmFkZChoYWxmQ2FudmFzU2l6ZSk7XG4gICAgICBib3VuZGFyaWVzLm1heC5hZGQoaGFsZkNhbnZhc1NpemUpO1xuICAgICAgcmV0dXJuIGJvdW5kYXJpZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gY2FudmFzIHNpemVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX21heFNpemUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odGhpcy5fY2FudmFzQ29udGFpbmVyLm9mZnNldFdpZHRoLCB0aGlzLl9jYW52YXNDb250YWluZXIub2Zmc2V0SGVpZ2h0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdzYW5pdGl6ZWRTdGFjaycsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc2FuaXRpemVkU3RhY2sgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fa2l0Lm9wZXJhdGlvbnNTdGFjay5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgb3BlcmF0aW9uID0gdGhpcy5fa2l0Lm9wZXJhdGlvbnNTdGFja1tpXTtcbiAgICAgICAgaWYgKCFvcGVyYXRpb24pIGNvbnRpbnVlO1xuICAgICAgICBzYW5pdGl6ZWRTdGFjay5wdXNoKG9wZXJhdGlvbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2FuaXRpemVkU3RhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgem9vbSBsZXZlbFxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd6b29tTGV2ZWwnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3pvb21MZXZlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FudmFzIHNpemUgaW4gcGl4ZWxzXG4gICAgICogQHR5cGUge1ZlY3RvcjJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzaXplJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHJlbmRlcmVyXG4gICAgICogQHJldHVybiB7UmVuZGVyZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdyZW5kZXJlcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENhbnZhcztcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDYW52YXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL2NhbnZhcy5qc1xuICoqIG1vZHVsZSBpZCA9IDg5XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9ldmVudC1lbWl0dGVyJyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkV2ZW50RW1pdHRlcik7XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBGaWxlTG9hZGVyID0gKGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhGaWxlTG9hZGVyLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBGaWxlTG9hZGVyKGtpdCwgdWkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZUxvYWRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGaWxlTG9hZGVyLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5fdWkgPSB1aTtcblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzExMDM1My9odG1sNS1kcmFnbGVhdmUtZmlyZWQtd2hlbi1ob3ZlcmluZy1hLWNoaWxkLWVsZW1lbnRcbiAgICB0aGlzLl9kcmFnQ291bnRlciA9IDA7XG5cbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl91aS5jb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNwbGFzaC1jb250YWluZXInKTtcblxuICAgIHRoaXMuX29uRHJvcEFyZWFEcmFnRW50ZXIgPSB0aGlzLl9vbkRyb3BBcmVhRHJhZ0VudGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ecm9wQXJlYURyYWdPdmVyID0gdGhpcy5fb25Ecm9wQXJlYURyYWdPdmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ecm9wQXJlYURyYWdMZWF2ZSA9IHRoaXMuX29uRHJvcEFyZWFEcmFnTGVhdmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkRyb3BBcmVhRHJvcCA9IHRoaXMuX29uRHJvcEFyZWFEcm9wLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Ecm9wQXJlYUNsaWNrID0gdGhpcy5fb25Ecm9wQXJlYUNsaWNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25GaWxlSW5wdXRDaGFuZ2UgPSB0aGlzLl9vbkZpbGVJbnB1dENoYW5nZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faGlkZGVuSW5wdXRGaWVsZCA9IHRoaXMuX3VpLmNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtdXBsb2FkLWhpZGRlbi1pbnB1dCcpO1xuICAgIHRoaXMuX2hpZGRlbklucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fb25GaWxlSW5wdXRDaGFuZ2UpO1xuXG4gICAgdGhpcy5faGFuZGxlRHJvcEFyZWEoKTtcbiAgICBpZiAodGhpcy5fdWkub3B0aW9ucy5pbWFnZSkge1xuICAgICAgdGhpcy5yZW1vdmVET00oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMgdGhlIGZpbGUgZGlhbG9nXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhGaWxlTG9hZGVyLCBbe1xuICAgIGtleTogJ29wZW5GaWxlRGlhbG9nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbkZpbGVEaWFsb2coKSB7XG4gICAgICB0aGlzLl9oaWRkZW5JbnB1dEZpZWxkLmNsaWNrKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgdGhlIGRyb3AgYXJlYSwgYWRkcyBldmVudCBsaXN0ZW5lcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZURyb3BBcmVhJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZURyb3BBcmVhKCkge1xuICAgICAgdGhpcy5fZHJvcEFyZWEgPSB0aGlzLl9jb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNwbGFzaC1yb3ctLXVwbG9hZCcpO1xuICAgICAgdGhpcy5fZHJvcEFyZWEuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5fb25Ecm9wQXJlYURyYWdFbnRlcik7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5hZGRFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuX29uRHJvcEFyZWFEcmFnT3Zlcik7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyb3BBcmVhRHJhZ0xlYXZlKTtcbiAgICAgIHRoaXMuX2Ryb3BBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLl9vbkRyb3BBcmVhRHJvcCk7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5hZGRFdmVudExpc3RlbmVyKCdkcmFnZHJvcCcsIHRoaXMuX29uRHJvcEFyZWFEcm9wKTtcbiAgICAgIHRoaXMuX2Ryb3BBcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Ecm9wQXJlYUNsaWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgZHJvcCBhcmVhLiBPcGVucyB0aGUgZmlsZVxuICAgICAqIGRpYWxvZyBieSB0cmlnZ2VyaW5nIGEgY2xpY2sgb24gdGhlIGhpZGRlbiBpbnB1dCBmaWVsZFxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRHJvcEFyZWFDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRyb3BBcmVhQ2xpY2soZSkge1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMub3BlbkZpbGVEaWFsb2coKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIGEgZmlsZSBvdmVyIHRoZSBkcm9wIGFyZWFcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRyb3BBcmVhRHJhZ0VudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJvcEFyZWFEcmFnRW50ZXIoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9kcmFnQ291bnRlcisrO1xuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdCh0aGlzLl9kcm9wQXJlYSkuYWRkKCdpbWdseWtpdC1zcGxhc2gtYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2UgbmVlZCB0byBjYW5jZWwgdGhpcyBldmVudCB0byBnZXQgYSBkcm9wIGV2ZW50XG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Ecm9wQXJlYURyYWdPdmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJvcEFyZWFEcmFnT3ZlcihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkb2VzIG5vIGxvbmdlciBkcmFnIGEgZmlsZSBvdmVyIHRoZSBkcm9wIGFyZWFcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRyb3BBcmVhRHJhZ0xlYXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJvcEFyZWFEcmFnTGVhdmUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9kcmFnQ291bnRlci0tO1xuXG4gICAgICBpZiAodGhpcy5fZHJhZ0NvdW50ZXIgPT09IDApIHtcbiAgICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdCh0aGlzLl9kcm9wQXJlYSkucmVtb3ZlKCdpbWdseWtpdC1zcGxhc2gtYWN0aXZlJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkcm9wcyBhIGZpbGUgb24gdGhlIGRyb3AgYXJlYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRHJvcEFyZWFEcm9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRHJvcEFyZWFEcm9wKGUpIHtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG5cbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QodGhpcy5fZHJvcEFyZWEpLnJlbW92ZSgnaW1nbHlraXQtc3BsYXNoLWFjdGl2ZScpO1xuXG4gICAgICBpZiAoIWUuZGF0YVRyYW5zZmVyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX3VpLmRpc3BsYXlMb2FkaW5nTWVzc2FnZSh0aGlzLl91aS50cmFuc2xhdGUoJ2dlbmVyaWMuaW1wb3J0aW5nJykgKyAnLi4uJyk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZUZpbGUoZS5kYXRhVHJhbnNmZXIuZmlsZXNbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0ZWQgYSBmaWxlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25GaWxlSW5wdXRDaGFuZ2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25GaWxlSW5wdXRDaGFuZ2UoKSB7XG4gICAgICB0aGlzLl9oYW5kbGVGaWxlKHRoaXMuX2hpZGRlbklucHV0RmllbGQuZmlsZXNbMF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0ZWQgYSBmaWxlLiBFbWl0cyBhIGBmaWxlYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge0ZpbGV9IGZpbGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUZpbGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRmlsZShmaWxlKSB7XG4gICAgICB0aGlzLmVtaXQoJ2ZpbGUnLCBmaWxlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVtb3ZlcyB0aGUgY29udGFpbmVyIGZvcm0gdGhlIGRvbVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRE9NKCkge1xuICAgICAgdGhpcy5fZHJvcEFyZWEucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ2VudGVyJywgdGhpcy5fb25Ecm9wQXJlYURyYWdFbnRlcik7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIHRoaXMuX29uRHJvcEFyZWFEcmFnT3Zlcik7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLl9vbkRyb3BBcmVhRHJhZ0xlYXZlKTtcbiAgICAgIHRoaXMuX2Ryb3BBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLl9vbkRyb3BBcmVhRHJvcCk7XG4gICAgICB0aGlzLl9kcm9wQXJlYS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZHJvcCcsIHRoaXMuX29uRHJvcEFyZWFEcm9wKTtcbiAgICAgIHRoaXMuX2Ryb3BBcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25Ecm9wQXJlYUNsaWNrKTtcblxuICAgICAgaWYgKHRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZUxvYWRlcjtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGaWxlTG9hZGVyO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2xpYi9maWxlLWxvYWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDkwXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgcmVzaXplOiBmdW5jdGlvbiByZXNpemUoaW1hZ2UsIGRpbWVuc2lvbnMpIHtcbiAgICB2YXIgbmV3Q2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgbmV3Q2FudmFzLndpZHRoID0gZGltZW5zaW9ucy54O1xuICAgIG5ld0NhbnZhcy5oZWlnaHQgPSBkaW1lbnNpb25zLnk7XG5cbiAgICB2YXIgY29udGV4dCA9IG5ld0NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMueSk7XG5cbiAgICByZXR1cm4gbmV3Q2FudmFzO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2xpYi9pbWFnZS1yZXNpemVyLmpzXG4gKiogbW9kdWxlIGlkID0gOTFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBJbWFnZSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9saWJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvZXZlbnQtZW1pdHRlcicpO1xuXG52YXIgX2xpYkV2ZW50RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJFdmVudEVtaXR0ZXIpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIFdlYmNhbUhhbmRsZXIgPSAoZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFdlYmNhbUhhbmRsZXIsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIFdlYmNhbUhhbmRsZXIoa2l0LCB1aSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJjYW1IYW5kbGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFdlYmNhbUhhbmRsZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9raXQgPSBraXQ7XG4gICAgdGhpcy5fdWkgPSB1aTtcblxuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl91aS5jb250YWluZXI7XG5cbiAgICB0aGlzLl9jYW52YXNDb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNhbnZhcy1jb250YWluZXInKTtcblxuICAgIHRoaXMuX3ZpZGVvID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC13ZWJjYW0tdmlkZW8nKTtcbiAgICB0aGlzLl93ZWJjYW1CdXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXdlYmNhbS1idXR0b24nKTtcbiAgICB0aGlzLl93ZWJjYW1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbldlYmNhbUJ1dHRvbkNsaWNrLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX2luaXRWaWRlb1N0cmVhbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tlZCB0aGUgc2h1dHRlciBidXR0b24uIERyYXdzIHRoZSBjdXJyZW50XG4gICAqIHZpZGVvIGZyYW1lIHRvIGEgY2FudmFzLCBjcmVhdGVzIGFuIGltYWdlIGZyb20gaXQgYW5kIGVtaXRzIHRoZSBgaW1hZ2VgXG4gICAqIGV2ZW50XG4gICAqIEBwYXJhbSAge0V2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhXZWJjYW1IYW5kbGVyLCBbe1xuICAgIGtleTogJ19vbldlYmNhbUJ1dHRvbkNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uV2ViY2FtQnV0dG9uQ2xpY2soZSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5fdmlkZW8udmlkZW9XaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLl92aWRlby52aWRlb0hlaWdodDtcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBjb250ZXh0LmRyYXdJbWFnZSh0aGlzLl92aWRlbywgMCwgMCk7XG5cbiAgICAgIC8vIERlcHJlY2F0ZWQgTWVkaWFTdHJlYW0gQVBJXG4gICAgICBpZiAodGhpcy5fc3RyZWFtLnN0b3ApIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtLnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgLy8gTmV3IE1lZGlhU3RyZWFtVHJhY2sgQVBJLCBzdG9wcGluZyBhbGwgdHJhY2tzXG4gICAgICBpZiAodGhpcy5fdHJhY2tzKSB7XG4gICAgICAgIHRoaXMuX3RyYWNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFjaykge1xuICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ZpZGVvLnBhdXNlKCk7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zdHJlYW07XG4gICAgICBkZWxldGUgdGhpcy5fdmlkZW87XG5cbiAgICAgIHZhciBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuZW1pdCgnaW1hZ2UnLCBpbWFnZSk7XG4gICAgICB9KTtcbiAgICAgIGltYWdlLnNyYyA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSB2aWRlbyBzdHJlYW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRWaWRlb1N0cmVhbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0VmlkZW9TdHJlYW0oKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgfHwgbmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCBuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhIHx8IG5hdmlnYXRvci5tc0dldFVzZXJNZWRpYTtcbiAgICAgIGlmICghZ2V0VXNlck1lZGlhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViY2FtIGZlYXR1cmUgbm90IHN1cHBvcnRlZCEgOignKTtcbiAgICAgIH1cblxuICAgICAgZ2V0VXNlck1lZGlhLmNhbGwobmF2aWdhdG9yLCB7IHZpZGVvOiB0cnVlIH0sIGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICAgICAgX3RoaXMyLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGlmIChzdHJlYW0uZ2V0VHJhY2tzKSB7XG4gICAgICAgICAgX3RoaXMyLl90cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMyLl92aWRlby5vbmxvYWRlZG1ldGFkYXRhID0gX3RoaXMyLl9vblZpZGVvUmVhZHkuYmluZChfdGhpczIpO1xuICAgICAgICBfdGhpczIuX3ZpZGVvLnNyYyA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHN0cmVhbSk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ19vblZpZGVvUmVhZHknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25WaWRlb1JlYWR5KCkge1xuICAgICAgdGhpcy5fcmVzaXplVmlkZW8oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzaXplVmlkZW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplVmlkZW8oKSB7XG4gICAgICB2YXIgX3ZpZGVvID0gdGhpcy5fdmlkZW87XG4gICAgICB2YXIgdmlkZW9XaWR0aCA9IF92aWRlby52aWRlb1dpZHRoO1xuICAgICAgdmFyIHZpZGVvSGVpZ2h0ID0gX3ZpZGVvLnZpZGVvSGVpZ2h0O1xuXG4gICAgICB2YXIgc2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10odmlkZW9XaWR0aCwgdmlkZW9IZWlnaHQpO1xuICAgICAgdmFyIG1heFNpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKHRoaXMuX2NhbnZhc0NvbnRhaW5lci5vZmZzZXRXaWR0aCwgdGhpcy5fY2FudmFzQ29udGFpbmVyLm9mZnNldEhlaWdodCk7XG5cbiAgICAgIHZhciBmaW5hbFNpemUgPSBfbGliVXRpbHMyWydkZWZhdWx0J10ucmVzaXplVmVjdG9yVG9GaXQoc2l6ZSwgbWF4U2l6ZSk7XG4gICAgICB0aGlzLl92aWRlby5zdHlsZS53aWR0aCA9IGZpbmFsU2l6ZS54ICsgJ3B4JztcbiAgICAgIHRoaXMuX3ZpZGVvLnN0eWxlLmhlaWdodCA9IGZpbmFsU2l6ZS55ICsgJ3B4JztcblxuICAgICAgdmFyIGRpZmYgPSBtYXhTaXplLmNsb25lKCkuc3VidHJhY3QoZmluYWxTaXplKS5kaXZpZGUoMik7XG5cbiAgICAgIHRoaXMuX3ZpZGVvLnN0eWxlLm1hcmdpbkxlZnQgPSBkaWZmLnggKyAncHgnO1xuICAgICAgdGhpcy5fdmlkZW8uc3R5bGUubWFyZ2luVG9wID0gZGlmZi55ICsgJ3B4JztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdnZXRVc2VyTWVkaWEnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBXZWJjYW1IYW5kbGVyO1xufSkoX2xpYkV2ZW50RW1pdHRlcjJbJ2RlZmF1bHQnXSk7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFdlYmNhbUhhbmRsZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL3dlYmNhbS1oYW5kbGVyLmpzXG4gKiogbW9kdWxlIGlkID0gOTJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2V2ZW50LWVtaXR0ZXInKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRXZlbnRFbWl0dGVyKTtcblxudmFyIFRvcENvbnRyb2xzID0gKGZ1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhUb3BDb250cm9scywgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gVG9wQ29udHJvbHMoa2l0LCB1aSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3BDb250cm9scyk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUb3BDb250cm9scy5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fa2l0ID0ga2l0O1xuICAgIHRoaXMuX3VpID0gdWk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbnRyb2xzXG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhUb3BDb250cm9scywgW3tcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX3VpLmNhbnZhcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgY29udHJvbHNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3J1bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bigpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLl91aS5jb250YWluZXI7XG5cbiAgICAgIHRoaXMuX3JpZ2h0Q29udHJvbHMgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXRvcC1jb250cm9scy1yaWdodCcpO1xuICAgICAgdGhpcy5fbGVmdENvbnRyb2xzID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC10b3AtY29udHJvbHMtbGVmdCcpO1xuXG4gICAgICB0aGlzLl91bmRvQnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC11bmRvJyk7XG4gICAgICB0aGlzLl96b29tSW4gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXpvb20taW4nKTtcbiAgICAgIHRoaXMuX3pvb21PdXQgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXpvb20tb3V0Jyk7XG4gICAgICB0aGlzLl96b29tTGV2ZWwgPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXpvb20tbGV2ZWwtbnVtJyk7XG4gICAgICB0aGlzLl9uZXdCdXR0b24gPSBjb250YWluZXIucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LW5ldycpO1xuICAgICAgdGhpcy5fZXhwb3J0QnV0dG9uID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1leHBvcnQnKTtcbiAgICAgIHRoaXMuX2hhbmRsZVpvb20oKTtcbiAgICAgIHRoaXMuX2hhbmRsZVVuZG8oKTtcbiAgICAgIHRoaXMuX2hhbmRsZU5ldygpO1xuICAgICAgdGhpcy5faGFuZGxlRXhwb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgem9vbSBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlWm9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVab29tKCkge1xuICAgICAgdGhpcy5fem9vbUluLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5fb25ab29tSW5DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3pvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vblpvb21PdXRDbGljay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSB1bmRvIGNvbnRyb2xcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZVVuZG8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVW5kbygpIHtcbiAgICAgIHRoaXMuX3VuZG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl91bmRvLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fdW5kbygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIG5ldyBidXR0b25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZU5ldycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVOZXcoKSB7XG4gICAgICBpZiAoIXRoaXMuX25ld0J1dHRvbikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9uZXdCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbk5ld0NsaWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGV4cG9ydCBidXR0b25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUV4cG9ydCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVFeHBvcnQoKSB7XG4gICAgICBpZiAoIXRoaXMuX2V4cG9ydEJ1dHRvbikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9leHBvcnRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkV4cG9ydENsaWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBuZXcgYnV0dG9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25OZXdDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk5ld0NsaWNrKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLmVtaXQoJ25ldycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBleHBvcnQgYnV0dG9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FeHBvcnRDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkV4cG9ydENsaWNrKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuZW1pdCgnZXhwb3J0Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIHVuZG8gYnV0dG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ191bmRvJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuZG8oKSB7XG4gICAgICB0aGlzLmVtaXQoJ3VuZG8nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB1bmRvIGJ1dHRvbiB2aXNpYmxlIHN0YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVVbmRvQnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlVW5kb0J1dHRvbigpIHtcbiAgICAgIHZhciBoaXN0b3J5ID0gdGhpcy5fdWkuaGlzdG9yeTtcblxuICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3VuZG9CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VuZG9CdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGV4cG9ydCBidXR0b24gdmlzaWJsZSBzdGF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAndXBkYXRlRXhwb3J0QnV0dG9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRXhwb3J0QnV0dG9uKCkge1xuICAgICAgaWYgKCF0aGlzLl9leHBvcnRCdXR0b24pIHJldHVybjtcblxuICAgICAgdmFyIGltYWdlID0gdGhpcy5fdWkuaW1hZ2U7XG5cbiAgICAgIGlmIChpbWFnZSkge1xuICAgICAgICB0aGlzLl9leHBvcnRCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhwb3J0QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja2VkIHRoZSB6b29tIGluIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7RXZlbnR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblpvb21JbkNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uWm9vbUluQ2xpY2soZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdGhpcy5lbWl0KCd6b29tLWluJyk7XG4gICAgICB0aGlzLnVwZGF0ZVpvb21MZXZlbCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tlZCB0aGUgem9vbSBvdXQgYnV0dG9uXG4gICAgICogQHBhcmFtIHtFdmVudH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uWm9vbU91dENsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uWm9vbU91dENsaWNrKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHRoaXMuZW1pdCgnem9vbS1vdXQnKTtcbiAgICAgIHRoaXMudXBkYXRlWm9vbUxldmVsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHpvb20gY29udHJvbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2hvd1pvb20nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93Wm9vbSgpIHtcbiAgICAgIHRoaXMuX3JpZ2h0Q29udHJvbHMuc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSB6b29tIGNvbnRyb2xcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hpZGVab29tJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZVpvb20oKSB7XG4gICAgICB0aGlzLl9yaWdodENvbnRyb2xzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgem9vbSBsZXZlbCBkaXNwbGF5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICd1cGRhdGVab29tTGV2ZWwnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVab29tTGV2ZWwoKSB7XG4gICAgICB2YXIgem9vbUxldmVsID0gdGhpcy5fY2FudmFzLnpvb21MZXZlbDtcblxuICAgICAgdGhpcy5fem9vbUxldmVsLmlubmVySFRNTCA9IE1hdGgucm91bmQoem9vbUxldmVsICogMTAwKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVG9wQ29udHJvbHM7XG59KShfbGliRXZlbnRFbWl0dGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVG9wQ29udHJvbHM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL3RvcC1jb250cm9scy5qc1xuICoqIG1vZHVsZSBpZCA9IDkzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBtYXhTY3JvbGxiYXJXaWR0aCA9IDE4O1xuXG4vKipcbiAqIE91ciBjdXN0b20gc2Nyb2xsIGJhclxuICovXG5cbnZhciBTY3JvbGxiYXIgPSAoZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXJcbiAgICovXG5cbiAgZnVuY3Rpb24gU2Nyb2xsYmFyKGNvbnRhaW5lcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTY3JvbGxiYXIpO1xuXG4gICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX2lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9pc0hvdmVyaW5nID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuX2Jyb3dzZXJTdXBwb3J0ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FwcGVuZERPTSgpO1xuICAgIHRoaXMuX3Jlc2l6ZUJ1dHRvbigpO1xuICAgIHRoaXMuX3VwZGF0ZVZhbHVlcygpO1xuXG4gICAgdGhpcy5fb25CdXR0b25Eb3duID0gdGhpcy5fb25CdXR0b25Eb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25CdXR0b25Nb3ZlID0gdGhpcy5fb25CdXR0b25Nb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25CdXR0b25VcCA9IHRoaXMuX29uQnV0dG9uVXAuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uQ29udGFpbmVyRW50ZXIgPSB0aGlzLl9vbkNvbnRhaW5lckVudGVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Db250YWluZXJMZWF2ZSA9IHRoaXMuX29uQ29udGFpbmVyTGVhdmUuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX29uQmFja2dyb3VuZENsaWNrID0gdGhpcy5fb25CYWNrZ3JvdW5kQ2xpY2suYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgdGhpcy5fb25Db250YWluZXJFbnRlcik7XG4gICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9vbkNvbnRhaW5lckxlYXZlKTtcbiAgICB0aGlzLl9jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Db250YWluZXJFbnRlcik7XG4gICAgdGhpcy5fZG9tLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkJ1dHRvbkRvd24pO1xuICAgIHRoaXMuX2RvbS5idXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uQnV0dG9uRG93bik7XG4gICAgdGhpcy5fZG9tLmJhY2tncm91bmQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkJhY2tncm91bmRDbGljayk7XG4gICAgdGhpcy5fbGlzdC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9vbkxpc3RTY3JvbGwuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9vbkxpc3RTY3JvbGwoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGlzIGZlYXR1cmUgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGJyb3dzZXJcbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFNjcm9sbGJhciwgW3tcbiAgICBrZXk6ICdfYnJvd3NlclN1cHBvcnRlZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9icm93c2VyU3VwcG9ydGVkKCkge1xuICAgICAgdmFyIElFTWF0Y2ggPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5tYXRjaCgvTVNJRSAoW1xcZC5dKykvKTtcbiAgICAgIGlmIChJRU1hdGNoICYmIHBhcnNlRmxvYXQoSUVNYXRjaFsxXSkgPD0gOSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgc2Nyb2xsYmFyIGJhY2tncm91bmRcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2tncm91bmRDbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2tncm91bmRDbGljayhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMuX2RvbS5iYWNrZ3JvdW5kKSByZXR1cm47XG5cbiAgICAgIHZhciBwb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdmFyIGJhY2tncm91bmRPZmZzZXQgPSB0aGlzLl9kb20uYmFja2dyb3VuZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGJhY2tncm91bmRPZmZzZXQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGJhY2tncm91bmRPZmZzZXQubGVmdCwgYmFja2dyb3VuZE9mZnNldC50b3ApO1xuXG4gICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QoYmFja2dyb3VuZE9mZnNldCk7XG5cbiAgICAgIHJlbGF0aXZlUG9zaXRpb24ueCAtPSB0aGlzLl92YWx1ZXMuYnV0dG9uLndpZHRoICogMC41O1xuXG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihyZWxhdGl2ZVBvc2l0aW9uLngpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZW50ZXJzIHRoZSBsaXN0IHdpdGggdGhlIG1vdXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkNvbnRhaW5lckVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29udGFpbmVyRW50ZXIoKSB7XG4gICAgICB0aGlzLl9pc0hvdmVyaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgbGVhdmVzIHRoZSBsaXN0IHdpdGggdGhlIG1vdXNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkNvbnRhaW5lckxlYXZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29udGFpbmVyTGVhdmUoKSB7XG4gICAgICB0aGlzLl9pc0hvdmVyaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLmhpZGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgc2Nyb2xsYmFyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIGlmICghdGhpcy5fYnJvd3NlclN1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgICBpZiAoIXRoaXMuX2lzU2Nyb2xsaW5nTmVjZXNzYXJ5KSByZXR1cm47XG4gICAgICBfbGliVXRpbHMyWydkZWZhdWx0J10uY2xhc3NMaXN0KHRoaXMuX2RvbS5iYWNrZ3JvdW5kKS5hZGQoJ3Zpc2libGUnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgc2Nyb2xsYmFyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdoaWRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5fYnJvd3NlclN1cHBvcnRlZCgpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5faXNEcmFnZ2luZykgcmV0dXJuO1xuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdCh0aGlzLl9kb20uYmFja2dyb3VuZCkucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgc2l6ZSB2YWx1ZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVZhbHVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVWYWx1ZXMoKSB7XG4gICAgICB0aGlzLl92YWx1ZXMgPSB7XG4gICAgICAgIGxpc3Q6IHtcbiAgICAgICAgICB0b3RhbFdpZHRoOiB0aGlzLl9saXN0LnNjcm9sbFdpZHRoLFxuICAgICAgICAgIHZpc2libGVXaWR0aDogdGhpcy5fbGlzdC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICBzY3JvbGxhYmxlV2lkdGg6IHRoaXMuX2xpc3Quc2Nyb2xsV2lkdGggLSB0aGlzLl9saXN0Lm9mZnNldFdpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgIHdpZHRoOiB0aGlzLl9kb20uYnV0dG9uLm9mZnNldFdpZHRoLFxuICAgICAgICAgIHNjcm9sbGFibGVXaWR0aDogdGhpcy5fZG9tLmJhY2tncm91bmQub2Zmc2V0V2lkdGggLSB0aGlzLl9kb20uYnV0dG9uLm9mZnNldFdpZHRoXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIGJ1dHRvblxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJ1dHRvbkRvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CdXR0b25Eb3duKGV2ZW50KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9pc0RyYWdnaW5nID0gdHJ1ZTtcblxuICAgICAgdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgICB0aGlzLl9pbml0aWFsQnV0dG9uUG9zaXRpb24gPSB0aGlzLl9idXR0b25Qb3NpdGlvbiB8fCAwO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkJ1dHRvbk1vdmUpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25CdXR0b25Nb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkJ1dHRvblVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25CdXR0b25VcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgYnV0dG9uXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQnV0dG9uTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJ1dHRvbk1vdmUoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZXZlbnQpO1xuICAgICAgdmFyIGRpZmYgPSBtb3VzZVBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuICAgICAgdmFyIG5ld0J1dHRvblBvc2l0aW9uID0gdGhpcy5faW5pdGlhbEJ1dHRvblBvc2l0aW9uICsgZGlmZi54O1xuXG4gICAgICB0aGlzLl9zZXRCdXR0b25Qb3NpdGlvbihuZXdCdXR0b25Qb3NpdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYnV0dG9uIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBuZXdCdXR0b25Qb3NpdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0QnV0dG9uUG9zaXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0QnV0dG9uUG9zaXRpb24obmV3QnV0dG9uUG9zaXRpb24pIHtcbiAgICAgIC8vIENsYW1wIGJ1dHRvbiBwb3NpdGlvblxuICAgICAgbmV3QnV0dG9uUG9zaXRpb24gPSBNYXRoLm1heCgwLCBuZXdCdXR0b25Qb3NpdGlvbik7XG4gICAgICBuZXdCdXR0b25Qb3NpdGlvbiA9IE1hdGgubWluKG5ld0J1dHRvblBvc2l0aW9uLCB0aGlzLl92YWx1ZXMuYnV0dG9uLnNjcm9sbGFibGVXaWR0aCk7XG5cbiAgICAgIC8vIFNldCBidXR0b24gcG9zaXRpb25cbiAgICAgIHRoaXMuX2J1dHRvblBvc2l0aW9uID0gbmV3QnV0dG9uUG9zaXRpb247XG4gICAgICB0aGlzLl9kb20uYnV0dG9uLnN0eWxlLmxlZnQgPSB0aGlzLl9idXR0b25Qb3NpdGlvbiArICdweCc7XG5cbiAgICAgIC8vIFVwZGF0ZSBsaXN0IHNjcm9sbCBwb3NpdGlvblxuICAgICAgdmFyIHByb2dyZXNzID0gbmV3QnV0dG9uUG9zaXRpb24gLyB0aGlzLl92YWx1ZXMuYnV0dG9uLnNjcm9sbGFibGVXaWR0aDtcbiAgICAgIHZhciBzY3JvbGxQb3NpdGlvbiA9IHRoaXMuX3ZhbHVlcy5saXN0LnNjcm9sbGFibGVXaWR0aCAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5fbGlzdC5zY3JvbGxMZWZ0ID0gc2Nyb2xsUG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgYnV0dG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJ1dHRvblVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQnV0dG9uVXAoKSB7XG4gICAgICB0aGlzLl9pc0RyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQnV0dG9uTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkJ1dHRvbk1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQnV0dG9uVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkJ1dHRvblVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHNjcm9sbHMgdGhlIGxpc3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGlzdFNjcm9sbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkxpc3RTY3JvbGwoKSB7XG4gICAgICBpZiAodGhpcy5faXNEcmFnZ2luZykgcmV0dXJuO1xuXG4gICAgICB2YXIgbGlzdFNjcm9sbFdpZHRoID0gdGhpcy5fbGlzdC5zY3JvbGxXaWR0aCAtIHRoaXMuX2xpc3Qub2Zmc2V0V2lkdGg7XG4gICAgICB2YXIgbGlzdFNjcm9sbFBvc2l0aW9uID0gdGhpcy5fbGlzdC5zY3JvbGxMZWZ0O1xuXG4gICAgICB2YXIgYmFja2dyb3VuZFNjcm9sbFdpZHRoID0gdGhpcy5fZG9tLmJhY2tncm91bmQub2Zmc2V0V2lkdGggLSB0aGlzLl9kb20uYnV0dG9uLm9mZnNldFdpZHRoO1xuICAgICAgdmFyIHByb2dyZXNzID0gbGlzdFNjcm9sbFBvc2l0aW9uIC8gbGlzdFNjcm9sbFdpZHRoO1xuXG4gICAgICB0aGlzLl9idXR0b25Qb3NpdGlvbiA9IGJhY2tncm91bmRTY3JvbGxXaWR0aCAqIHByb2dyZXNzO1xuICAgICAgdGhpcy5fZG9tLmJ1dHRvbi5zdHlsZS5sZWZ0ID0gdGhpcy5fYnV0dG9uUG9zaXRpb24gKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGJ1dHRvbiB0byByZXByZXNlbnQgdGhlIHZpc2libGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZXNpemVCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplQnV0dG9uKCkge1xuICAgICAgdmFyIGxpc3RTY3JvbGxXaWR0aCA9IHRoaXMuX2xpc3Quc2Nyb2xsV2lkdGg7XG4gICAgICB2YXIgbGlzdFdpZHRoID0gdGhpcy5fbGlzdC5vZmZzZXRXaWR0aDtcblxuICAgICAgdGhpcy5fYnV0dG9uV2lkdGggPSBsaXN0V2lkdGggLyBsaXN0U2Nyb2xsV2lkdGggKiBsaXN0V2lkdGg7XG4gICAgICB0aGlzLl9kb20uYnV0dG9uLnN0eWxlLndpZHRoID0gdGhpcy5fYnV0dG9uV2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhlIERPTSBlbGVtZW50cyB0byB0aGUgY29udGFpbmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hcHBlbmRET00nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYXBwZW5kRE9NKCkge1xuICAgICAgdmFyIGJhY2tncm91bmQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QoYmFja2dyb3VuZCkuYWRkKCdpbWdseWtpdC1zY3JvbGxiYXItYmFja2dyb3VuZCcpO1xuICAgICAgYmFja2dyb3VuZC5zdHlsZS5ib3R0b20gPSBtYXhTY3JvbGxiYXJXaWR0aCArICdweCc7XG5cbiAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QoYnV0dG9uKS5hZGQoJ2ltZ2x5a2l0LXNjcm9sbGJhci1idXR0b24nKTtcblxuICAgICAgYmFja2dyb3VuZC5hcHBlbmRDaGlsZChidXR0b24pO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGJhY2tncm91bmQpO1xuXG4gICAgICAvLyBDb250YWluZXIgc2hvdWxkIGhhdmUgcG9zaXRpb246IHJlbGF0aXZlXG4gICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuXG4gICAgICAvLyBGaW5kIHRoZSBsaXN0XG4gICAgICB0aGlzLl9saXN0ID0gdGhpcy5fY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb250cm9scy1saXN0Jyk7XG4gICAgICB0aGlzLl9kb20gPSB7IGJhY2tncm91bmQ6IGJhY2tncm91bmQsIGJ1dHRvbjogYnV0dG9uIH07XG5cbiAgICAgIC8vIFJlc2l6ZSB0aGUgbGlzdCBhbmQgdGhlIGNvbnRhaW5lclxuICAgICAgdGhpcy5fbGlzdC5zdHlsZS5oZWlnaHQgPSAnJztcbiAgICAgIHZhciBsaXN0SGVpZ2h0ID0gdGhpcy5fbGlzdC5vZmZzZXRIZWlnaHQ7XG4gICAgICBsaXN0SGVpZ2h0ICs9IG1heFNjcm9sbGJhcldpZHRoO1xuICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGxpc3RIZWlnaHQgKyAncHgnO1xuICAgICAgdGhpcy5fbGlzdC5zdHlsZS5oZWlnaHQgPSBsaXN0SGVpZ2h0ICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBET00gZWxlbWVudHMgYW5kIGV2ZW50IGxpc3RlbmVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgaWYgKCF0aGlzLl9icm93c2VyU3VwcG9ydGVkKCkpIHJldHVybjtcblxuICAgICAgdGhpcy5fZG9tLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkJ1dHRvbkRvd24pO1xuICAgICAgdGhpcy5fZG9tLmJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25CdXR0b25Eb3duKTtcblxuICAgICAgdGhpcy5fZG9tLmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9kb20uYmFja2dyb3VuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgc2Nyb2xsaW5nIGlzIG5lY2Vzc2FyeVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaXNTY3JvbGxpbmdOZWNlc3NhcnknLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2xpc3Quc2Nyb2xsV2lkdGggPiB0aGlzLl9saXN0Lm9mZnNldFdpZHRoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY3JvbGxiYXI7XG59KSgpO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTY3JvbGxiYXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL3Njcm9sbGJhci5qc1xuICoqIG1vZHVsZSBpZCA9IDk0XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgX19ET1RKU19URU1QTEFURSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG5cbnZhciBfY29udHJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250cm9sKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIEZpbHRlcnNDb250cm9sID0gKGZ1bmN0aW9uIChfQ29udHJvbCkge1xuICBfaW5oZXJpdHMoRmlsdGVyc0NvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBGaWx0ZXJzQ29udHJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsdGVyc0NvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRmlsdGVyc0NvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKEZpbHRlcnNDb250cm9sLCBbe1xuICAgIGtleTogJ2luaXQnLFxuXG4gICAgLyoqXG4gICAgICogRW50cnkgcG9pbnQgZm9yIHRoaXMgY29udHJvbFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIGNvbnRyb2xzVGVtcGxhdGUgPSBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWxpc3QtY29udGFpbmVyXCI+IDx1bCBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWxpc3QgaW1nbHktY29udHJvbHMtbGlzdC13aXRoLWJ1dHRvbnNcIj4gJzsgZm9yKHZhciBpZGVudGlmaWVyIGluIGl0LmZpbHRlcnMpIHsgb3V0Kz0nICc7IHZhciBmaWx0ZXIgPSBpdC5maWx0ZXJzW2lkZW50aWZpZXJdOyBvdXQrPScgJzsgdmFyIG5hbWUgPSBmaWx0ZXIucHJvdG90eXBlLm5hbWU7IG91dCs9JyAnOyB2YXIgZW5hYmxlZCA9IGl0LmFjdGl2ZUZpbHRlci5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyOyBvdXQrPScgPGxpIGRhdGEtaWRlbnRpZmllcj1cIicrKCBpZGVudGlmaWVyKSsnXCIgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1pdGVtLXdpdGgtbGFiZWwnO2lmKGVuYWJsZWQpe291dCs9JyBpbWdseWtpdC1jb250cm9scy1pdGVtLWFjdGl2ZSc7fW91dCs9J1wiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9maWx0ZXJzLycgKyBpZGVudGlmaWVyICsgJy5wbmcnKSkrJ1wiIC8+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1pdGVtLWxhYmVsXCI+JysoIG5hbWUgKSsnPC9kaXY+IDwvbGk+ICc7IH0gb3V0Kz0nIDwvdWw+PC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPSBjb250cm9sc1RlbXBsYXRlO1xuXG4gICAgICB0aGlzLl9hdmFpbGFibGVGaWx0ZXJzID0ge307XG4gICAgICB0aGlzLl9maWx0ZXJzID0ge307XG5cbiAgICAgIHRoaXMuX2FkZERlZmF1bHRGaWx0ZXJzKCk7XG5cbiAgICAgIC8vIFNlbGVjdCBhbGwgZmlsdGVycyBwZXIgZGVmYXVsdFxuICAgICAgdGhpcy5zZWxlY3RGaWx0ZXJzKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAaW50ZXJuYWwgV2UgbmVlZCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gZnJvbSB0aGUgb3BlcmF0aW9uIHdoZW5cbiAgICAgKiAgICAgICAgICAgcmVuZGVyaW5nLCB3aGljaCBpcyB3aHkgd2UgaGF2ZSB0byBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQWxsQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQWxsQ29udHJvbHMoKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLmZpbHRlcnM7XG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLl91aS5nZXRPckNyZWF0ZU9wZXJhdGlvbignZmlsdGVycycpO1xuXG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGaWx0ZXJzQ29udHJvbC5wcm90b3R5cGUpLCAnX3JlbmRlckFsbENvbnRyb2xzJywgdGhpcykuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5faGlzdG9yeUl0ZW0gPSBudWxsO1xuICAgICAgdGhpcy5faW5pdGlhbEZpbHRlciA9IHRoaXMuX29wZXJhdGlvbi5nZXRGaWx0ZXIoKTtcbiAgICAgIHRoaXMuX2RlZmF1bHRGaWx0ZXIgPSB0aGlzLl9vcGVyYXRpb24uYXZhaWxhYmxlT3B0aW9ucy5maWx0ZXJbJ2RlZmF1bHQnXTtcblxuICAgICAgdmFyIGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XG4gICAgICB0aGlzLl9saXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgICAvLyBMaXN0ZW4gdG8gY2xpY2sgZXZlbnRzXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IF90aGlzLl9saXN0SXRlbXNbaV07XG4gICAgICAgIGxpc3RJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLl9vbkxpc3RJdGVtQ2xpY2sobGlzdEl0ZW0pO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgaGl0cyB0aGUgYmFjayBidXR0b25cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrKCkge1xuICAgICAgdmFyIGN1cnJlbnRGaWx0ZXIgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RmlsdGVyKCk7XG4gICAgICBpZiAoY3VycmVudEZpbHRlciA9PT0gdGhpcy5fZGVmYXVsdEZpbHRlcikge1xuICAgICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ2ZpbHRlcnMnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrZWQgYSBsaXN0IGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGlzdEl0ZW1DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkxpc3RJdGVtQ2xpY2soaXRlbSkge1xuICAgICAgdGhpcy5fZGVhY3RpdmF0ZUFsbEl0ZW1zKCk7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWRlbnRpZmllcicpO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldEZpbHRlcih0aGlzLl9maWx0ZXJzW2lkZW50aWZpZXJdKTtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcblxuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5hZGQoJ2ltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tYWN0aXZlJyk7XG5cbiAgICAgIHZhciBjdXJyZW50RmlsdGVyID0gdGhpcy5fb3BlcmF0aW9uLmdldEZpbHRlcigpO1xuICAgICAgaWYgKGN1cnJlbnRGaWx0ZXIgIT09IHRoaXMuX2luaXRpYWxGaWx0ZXIgJiYgIXRoaXMuX2hpc3RvcnlJdGVtKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLl9vcGVyYXRpb24sIHtcbiAgICAgICAgICBmaWx0ZXI6IHRoaXMuX2luaXRpYWxGaWx0ZXJcbiAgICAgICAgfSwgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgYWxsIGxpc3QgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2RlYWN0aXZhdGVBbGxJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlQWxsSXRlbXMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSB0aGlzLl9saXN0SXRlbXNbaV07XG4gICAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QobGlzdEl0ZW0pLnJlbW92ZSgnaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYWxsIHRoZSBrbm93biBmaWx0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hZGREZWZhdWx0RmlsdGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGREZWZhdWx0RmlsdGVycygpIHtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9pZGVudGl0eS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvazEtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2syLWZpbHRlcicpKTtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9rNi1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMva2R5bmFtaWMtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2ZyaWRnZS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvYnJlZXplLWZpbHRlcicpKTtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9vcmNoaWQtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2NoZXN0LWZpbHRlcicpKTtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9mcm9udC1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvZml4aWUtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL3g0MDAtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2J3LWZpbHRlcicpKTtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9id2hhcmQtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2xlbmluLWZpbHRlcicpKTtcbiAgICAgIHRoaXMuYWRkRmlsdGVyKHJlcXVpcmUoJy4uLy4uLy4uL29wZXJhdGlvbnMvZmlsdGVycy9xdW96aS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYTY2OS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvcG9sYS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvZm9vZC1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvZ2xhbS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvY2Vsc2l1cy1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvdGV4YXMtZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL21vcm5pbmctZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2xvbW8tZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2dvYmJsaW4tZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL21lbGxvdy1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvc3VubnktZmlsdGVyJykpO1xuICAgICAgdGhpcy5hZGRGaWx0ZXIocmVxdWlyZSgnLi4vLi4vLi4vb3BlcmF0aW9ucy9maWx0ZXJzL2ExNS1maWx0ZXInKSk7XG4gICAgICB0aGlzLmFkZEZpbHRlcihyZXF1aXJlKCcuLi8uLi8uLi9vcGVyYXRpb25zL2ZpbHRlcnMvc2VtaXJlZC1maWx0ZXInKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBnaXZlbiBmaWx0ZXJcbiAgICAgKiBAcGFyYW0gIHtjbGFzc30gZmlsdGVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2FkZEZpbHRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEZpbHRlcihmaWx0ZXIpIHtcbiAgICAgIHRoaXMuX2F2YWlsYWJsZUZpbHRlcnNbZmlsdGVyLmlkZW50aWZpZXJdID0gZmlsdGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIGZpbHRlcnNcbiAgICAgKiBAcGFyYW0ge1NlbGVjdG9yfSBzZWxlY3RvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0RmlsdGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdEZpbHRlcnMoc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnMgPSB7fTtcblxuICAgICAgdmFyIGZpbHRlcklkZW50aWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5fYXZhaWxhYmxlRmlsdGVycyk7XG5cbiAgICAgIHZhciBzZWxlY3RlZEZpbHRlcnMgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uc2VsZWN0KGZpbHRlcklkZW50aWZpZXJzLCBzZWxlY3Rvcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkRmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHNlbGVjdGVkRmlsdGVyc1tpXTtcbiAgICAgICAgdGhpcy5fZmlsdGVyc1tpZGVudGlmaWVyXSA9IHRoaXMuX2F2YWlsYWJsZUZpbHRlcnNbaWRlbnRpZmllcl07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ29udHJvbHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIGF2YWlsYWJsZSB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmaWx0ZXJzOiB0aGlzLl9maWx0ZXJzLFxuICAgICAgICBhY3RpdmVGaWx0ZXI6IHRoaXMuX29wZXJhdGlvbi5nZXRGaWx0ZXIoKVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsdGVyc0NvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cbkZpbHRlcnNDb250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ2ZpbHRlcnMnO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGaWx0ZXJzQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy9maWx0ZXJzLWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA5NVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfYmFzZUhlbHBlcnMgPSByZXF1aXJlKCcuLi8uLi9iYXNlL2hlbHBlcnMnKTtcblxudmFyIF9iYXNlSGVscGVyczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlSGVscGVycyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2V2ZW50LWVtaXR0ZXInKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRXZlbnRFbWl0dGVyKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJTY3JvbGxiYXIgPSByZXF1aXJlKCcuLi9saWIvc2Nyb2xsYmFyJyk7XG5cbnZhciBfbGliU2Nyb2xsYmFyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlNjcm9sbGJhcik7XG5cbi8qKlxuICogVG8gY3JlYXRlIGFuIHtAbGluayBJbWdseUtpdC5OaWdodFVJLkNvbnRyb2x9IGNsYXNzIG9mIHlvdXIgb3duLCBjYWxsXG4gKiB0aGlzIG1ldGhvZCBhbmQgcHJvdmlkZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGFuZCBmdW5jdGlvbnMuXG4gKiBAZnVuY3Rpb25cbiAqL1xuXG52YXIgX2xpYkV4dGVuZCA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9leHRlbmQnKTtcblxudmFyIF9saWJFeHRlbmQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRXh0ZW5kKTtcblxudmFyIENvbnRyb2wgPSAoZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKENvbnRyb2wsIF9FdmVudEVtaXR0ZXIpO1xuXG4gIGZ1bmN0aW9uIENvbnRyb2woa2l0LCB1aSwgb3BlcmF0aW9uKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udHJvbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fa2l0ID0ga2l0O1xuICAgIHRoaXMuX3VpID0gdWk7XG4gICAgdGhpcy5fb3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgIHRoaXMuX2hlbHBlcnMgPSBuZXcgX2Jhc2VIZWxwZXJzMlsnZGVmYXVsdCddKHRoaXMuX2tpdCwgdGhpcy5fdWksIHRoaXMuX3VpLm9wdGlvbnMpO1xuICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMgPSB7XG4gICAgICBkb25lQnV0dG9uOiBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWJ1dHRvbiBpbWdseWtpdC1jb250cm9scy1kb25lXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L2J1dHRvbnMvZG9uZS5wbmcnKSApKydcIiAvPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtZG9uZS1oaWdobGlnaHRlZFwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9idXR0b25zL2RvbmUtaGlnaGxpZ2h0ZWQucG5nJykgKSsnXCIgLz4gPC9kaXY+PC9kaXY+JztyZXR1cm4gb3V0O1xufVxuICAgIH07XG5cbiAgICB0aGlzLl90ZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtJysoaXQuaWRlbnRpZmllcikrJ1wiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtYnV0dG9uIGltZ2x5a2l0LWNvbnRyb2xzLWJhY2tcIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvYnV0dG9ucy9iYWNrLnBuZycpICkrJ1wiIC8+IDwvZGl2PiAnKyhpdC5wYXJ0aWFscy5jb250cm9sKSsnPC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLl9oaXN0b3J5SXRlbSA9IG51bGw7XG5cbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRhaW5lcnMgdGhhdCB0aGUgY29udHJvbCB3aWxsIGJlIHJlbmRlcmVkIHRvXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udHJvbHNDb250YWluZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjYW52YXNDb250cm9sc0NvbnRhaW5lclxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoQ29udHJvbCwgW3tcbiAgICBrZXk6ICdzZXRDb250YWluZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q29udGFpbmVycyhjb250cm9sc0NvbnRhaW5lciwgY2FudmFzQ29udHJvbHNDb250YWluZXIpIHtcbiAgICAgIHRoaXMuX2NvbnRyb2xzQ29udGFpbmVyID0gY29udHJvbHNDb250YWluZXI7XG4gICAgICB0aGlzLl9jYW52YXNDb250cm9sc0NvbnRhaW5lciA9IGNhbnZhc0NvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBlbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdpbml0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIGNvbnRyb2wgdG8gZGlzcGxheSB0aGUgY3VycmVudCB2YWx1ZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgIHRoaXMuX3JlbmRlckFsbENvbnRyb2xzKCk7XG4gICAgICB0aGlzLl9vbkVudGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29udHJvbCB0byByZXByZXNlbnQgdGhlIGluaXRpYWwgdmFsdWVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zZXRJbml0aWFsVmFsdWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEluaXRpYWxWYWx1ZXMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY29udHJvbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckFsbENvbnRyb2xzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckFsbENvbnRyb2xzKCkge1xuICAgICAgdGhpcy5fcmVuZGVyQ29udHJvbHMoKTtcbiAgICAgIHRoaXMuX3JlbmRlckNhbnZhc0NvbnRyb2xzKCk7XG4gICAgICB0aGlzLl9pbml0U2Nyb2xsYmFyKCk7XG5cbiAgICAgIHRoaXMuX2hhbmRsZUJhY2tBbmREb25lQnV0dG9ucygpO1xuICAgICAgdGhpcy5fZW5hYmxlQ2FudmFzQ29udHJvbHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udHJvbCNfcmVuZGVyT3ZlcnZpZXdDb250cm9sczogQ29udHJvbCBuZWVkcyB0byBkZWZpbmUgdGhpcy5fY29udHJvbHNUZW1wbGF0ZS4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIHRoZSB0ZW1wbGF0ZVxuICAgICAgdmFyIGh0bWwgPSB0aGlzLl90ZW1wbGF0ZSh0aGlzLl9jb250ZXh0KTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jb250cm9scyAhPT0gJ3VuZGVmaW5lZCcgJiYgdGhpcy5fY29udHJvbHMucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9jb250cm9scy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRyb2xzKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgd3JhcHBlclxuICAgICAgdGhpcy5fY29udHJvbHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzLmlubmVySFRNTCA9IGh0bWw7XG5cbiAgICAgIC8vIEFwcGVuZCB0byBET01cbiAgICAgIHRoaXMuX2NvbnRyb2xzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRyb2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBjYW52YXMgY29udHJvbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNhbnZhc0NvbnRyb2xzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNhbnZhc0NvbnRyb2xzKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYW52YXNDb250cm9sc1RlbXBsYXRlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47IC8vIENhbnZhcyBjb250cm9scyBhcmUgb3B0aW9uYWxcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIHRoZSB0ZW1wbGF0ZVxuICAgICAgdmFyIGh0bWwgPSB0aGlzLl9jYW52YXNDb250cm9sc1RlbXBsYXRlKHRoaXMuX2NvbnRleHQpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NhbnZhc0NvbnRyb2xzICE9PSAndW5kZWZpbmVkJyAmJiB0aGlzLl9jYW52YXNDb250cm9scy5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX2NhbnZhc0NvbnRyb2xzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fY2FudmFzQ29udHJvbHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSB3cmFwcGVyXG4gICAgICB0aGlzLl9jYW52YXNDb250cm9scyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHMuaW5uZXJIVE1MID0gaHRtbDtcblxuICAgICAgLy8gQXBwZW5kIHRvIERPTVxuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzQ29udHJvbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBjdXN0b20gc2Nyb2xsYmFyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0U2Nyb2xsYmFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTY3JvbGxiYXIoKSB7XG4gICAgICB2YXIgbGlzdCA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb250cm9scy1saXN0Jyk7XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICB0aGlzLl9zY3JvbGxiYXIgPSBuZXcgX2xpYlNjcm9sbGJhcjJbJ2RlZmF1bHQnXShsaXN0LnBhcmVudE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGNvbnRyb2xzIGZyb20gdGhlIERPTVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVtb3ZlQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlQ29udHJvbHMoKSB7XG4gICAgICB0aGlzLl9jb250cm9scy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRyb2xzKTtcbiAgICAgIGlmICh0aGlzLl9jYW52YXNDb250cm9scykge1xuICAgICAgICB0aGlzLl9jYW52YXNDb250cm9scy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NhbnZhc0NvbnRyb2xzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3Njcm9sbGJhcikgdGhpcy5fc2Nyb2xsYmFyLnJlbW92ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGJhY2sgYW5kIGRvbmUgYnV0dG9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlQmFja0FuZERvbmVCdXR0b25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUJhY2tBbmREb25lQnV0dG9ucygpIHtcbiAgICAgIC8vIEJhY2sgYnV0dG9uXG4gICAgICB0aGlzLl9iYWNrQnV0dG9uID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNvbnRyb2xzLWJhY2snKTtcbiAgICAgIGlmICh0aGlzLl9iYWNrQnV0dG9uKSB7XG4gICAgICAgIHRoaXMuX2JhY2tCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkJhY2tCdXR0b25DbGljay5iaW5kKHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uZSBidXR0b25cbiAgICAgIHRoaXMuX2RvbmVCdXR0b24gPSB0aGlzLl9jb250cm9scy5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY29udHJvbHMtZG9uZScpO1xuICAgICAgaWYgKHRoaXMuX2RvbmVCdXR0b24pIHtcbiAgICAgICAgdGhpcy5fZG9uZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uRG9uZUJ1dHRvbkNsaWNrLmJpbmQodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmFja0J1dHRvbkNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFja0J1dHRvbkNsaWNrKCkge1xuICAgICAgdGhpcy5fb25CYWNrKCk7XG4gICAgICB0aGlzLmVtaXQoJ2JhY2snKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBkb25lIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRvbmVCdXR0b25DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmVCdXR0b25DbGljaygpIHtcbiAgICAgIHRoaXMuX29uRG9uZSgpO1xuICAgICAgdGhpcy5lbWl0KCdiYWNrJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgZG9uZSBidXR0b25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hpZ2hsaWdodERvbmVCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlnaGxpZ2h0RG9uZUJ1dHRvbigpIHtcbiAgICAgIGlmICghdGhpcy5fZG9uZUJ1dHRvbikgcmV0dXJuO1xuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdCh0aGlzLl9kb25lQnV0dG9uKS5hZGQoJ2hpZ2hsaWdodGVkJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQGludGVybmFsIFVzZWQgYnkgdGhlIFNESywgZG9uJ3Qgb3ZlcnJpZGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdlbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVudGVyKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gdHJ1ZTtcblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9jYW52YXNDb250cm9sc1RlbXBsYXRlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl91aS5oaWRlWm9vbSgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZW5kZXJBbGxDb250cm9scygpO1xuICAgICAgdGhpcy5fb25FbnRlcigpO1xuICAgICAgdGhpcy5fc2V0SW5pdGlhbFZhbHVlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGRlYWN0aXZhdGVkXG4gICAgICogQGludGVybmFsIFVzZWQgYnkgdGhlIFNESywgZG9uJ3Qgb3ZlcnJpZGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdsZWF2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxlYXZlKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuX3VpLnNob3dab29tKCk7XG5cbiAgICAgIHRoaXMuX3JlbW92ZUNvbnRyb2xzKCk7XG4gICAgICB0aGlzLl9kaXNhYmxlQ2FudmFzQ29udHJvbHMoKTtcbiAgICAgIHRoaXMuX29uTGVhdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdfZW5hYmxlQ2FudmFzQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5hYmxlQ2FudmFzQ29udHJvbHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QodGhpcy5fY2FudmFzQ29udHJvbHNDb250YWluZXIpLnJlbW92ZSgnaW1nbHlraXQtY2FudmFzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX2Rpc2FibGVDYW52YXNDb250cm9scycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kaXNhYmxlQ2FudmFzQ29udHJvbHMoKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QodGhpcy5fY2FudmFzQ29udHJvbHNDb250YWluZXIpLmFkZCgnaW1nbHlraXQtY2FudmFzLWNvbnRyb2xzLWRpc2FibGVkJyk7XG4gICAgfVxuXG4gICAgLy8gUHJvdGVjdGVkIG1ldGhvZHNcblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGFjdGl2YXRlZC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge31cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGRlYWN0aXZhdGVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGVhdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25MZWF2ZSgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2soKSB7fVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZG9uZSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRvbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb25lKCkge31cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHpvb20gbGV2ZWwgaGFzIGJlZW4gY2hhbmdlZCB3aGlsZVxuICAgICAqIHRoaXMgY29udHJvbCBpcyBhY3RpdmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ29uWm9vbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uWm9vbSgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIGF2YWlsYWJsZSB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2NvbnRleHQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGNvbnRleHQgPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZXh0ZW5kKGNvbnRleHQsIHtcbiAgICAgICAgaGVscGVyczogdGhpcy5faGVscGVycyxcbiAgICAgICAgaWRlbnRpZmllcjogdGhpcy5pZGVudGlmaWVyXG4gICAgICB9KTtcblxuICAgICAgLy8gUmVuZGVyIHBhcnRpYWxzIGJlZm9yZSByZW5kZXJpbmcgY29udHJvbFxuICAgICAgY29udGV4dC5wYXJ0aWFscyA9IHt9O1xuICAgICAgZm9yICh2YXIgX25hbWUgaW4gdGhpcy5fcGFydGlhbFRlbXBsYXRlcykge1xuICAgICAgICB2YXIgdGVtcGxhdGUgPSB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzW19uYW1lXTtcbiAgICAgICAgdmFyIHBhcnRpYWxDb250ZXh0ID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmV4dGVuZCh7fSwgY29udGV4dCwgdGVtcGxhdGUuYWRkaXRpb25hbENvbnRleHQgfHwge30pO1xuICAgICAgICBjb250ZXh0LnBhcnRpYWxzW19uYW1lXSA9IHRlbXBsYXRlKHBhcnRpYWxDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRleHQucGFydGlhbHMuY29udHJvbCA9IHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUoY29udGV4dCk7XG5cbiAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHRoYXQgaXMgYXZhaWxhYmxlIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENvbnRyb2w7XG59KShfbGliRXZlbnRFbWl0dGVyMlsnZGVmYXVsdCddKTtcblxuQ29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9IG51bGw7XG5Db250cm9sLmV4dGVuZCA9IF9saWJFeHRlbmQyWydkZWZhdWx0J107XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENvbnRyb2w7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvY29udHJvbHMvY29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDk2XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgX19ET1RKU19URU1QTEFURSAqL1xuLypcbiAqIFBob3RvIEVkaXRvciBTREsgLSBwaG90b2VkaXRvcnNkay5jb21cbiAqIENvcHlyaWdodCAoYykgMjAxMy0yMDE1IDllbGVtZW50cyBHbWJIXG4gKlxuICogUmVsZWFzZWQgdW5kZXIgQXR0cmlidXRpb24tTm9uQ29tbWVyY2lhbCAzLjAgVW5wb3J0ZWRcbiAqIGh0dHA6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLzMuMC9cbiAqXG4gKiBGb3IgY29tbWVyY2lhbCB1c2UsIHBsZWFzZSBjb250YWN0IHVzIGF0IGNvbnRhY3RAOWVsZW1lbnRzLmNvbVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKCd2YWx1ZScgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0pKCk7XG5cbnZhciBfZ2V0ID0gZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94MykgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeCwgcHJvcGVydHkgPSBfeDIsIHJlY2VpdmVyID0gX3gzOyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94ID0gcGFyZW50OyBfeDIgPSBwcm9wZXJ0eTsgX3gzID0gcmVjZWl2ZXI7IF9hZ2FpbiA9IHRydWU7IGRlc2MgPSBwYXJlbnQgPSB1bmRlZmluZWQ7IGNvbnRpbnVlIF9mdW5jdGlvbjsgfSB9IGVsc2UgaWYgKCd2YWx1ZScgaW4gZGVzYykgeyByZXR1cm4gZGVzYy52YWx1ZTsgfSBlbHNlIHsgdmFyIGdldHRlciA9IGRlc2MuZ2V0OyBpZiAoZ2V0dGVyID09PSB1bmRlZmluZWQpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSByZXR1cm4gZ2V0dGVyLmNhbGwocmVjZWl2ZXIpOyB9IH0gfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbicpOyB9IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gJ2Z1bmN0aW9uJyAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ1N1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgJyArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIF9jb250cm9sID0gcmVxdWlyZSgnLi9jb250cm9sJyk7XG5cbnZhciBfY29udHJvbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb250cm9sKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBSb3RhdGlvbkNvbnRyb2wgPSAoZnVuY3Rpb24gKF9Db250cm9sKSB7XG4gIF9pbmhlcml0cyhSb3RhdGlvbkNvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBSb3RhdGlvbkNvbnRyb2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJvdGF0aW9uQ29udHJvbCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihSb3RhdGlvbkNvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFJvdGF0aW9uQ29udHJvbCwgW3tcbiAgICBrZXk6ICdpbml0JyxcblxuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciB0aGlzIGNvbnRyb2xcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBjb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXY+IDx1bCBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWxpc3QgaW1nbHktY29udHJvbHMtbGlzdC13aXRoLWJ1dHRvbnNcIj4gPGxpIGRhdGEtZGVncmVlcz1cIi05MFwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9yb3RhdGlvbi9sZWZ0LnBuZycpKSsnXCIgLz4gPC9saT4gPGxpIGRhdGEtZGVncmVlcz1cIjkwXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3JvdGF0aW9uL3JpZ2h0LnBuZycpKSsnXCIgLz4gPC9saT4gPC91bD48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5faGlzdG9yeUl0ZW0gPSBudWxsO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLnJvdGF0aW9uO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5fdWkuZ2V0T3JDcmVhdGVPcGVyYXRpb24oJ3JvdGF0aW9uJyk7XG4gICAgICB0aGlzLl9vcGVyYXRpb24uZGlydHkgPSB0cnVlO1xuICAgICAgdGhpcy5fY3JvcE9wZXJhdGlvbiA9IHRoaXMuX3VpLm9wZXJhdGlvbnMuY3JvcDtcblxuICAgICAgdGhpcy5faW5pdGlhbERlZ3JlZXMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RGVncmVlcygpO1xuXG4gICAgICB2YXIgbGlzdEl0ZW1zID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcbiAgICAgIGlmICh0aGlzLl9jcm9wT3BlcmF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbFN0YXJ0ICYmICF0aGlzLl9pbml0aWFsRW5kKSB7XG4gICAgICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzZXR0aW5ncyBmb3IgJ2JhY2snIGFuZCAnZG9uZScgYnV0dG9uc1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxTdGFydCA9IHRoaXMuX2Nyb3BPcGVyYXRpb24uZ2V0U3RhcnQoKS5jbG9uZSgpO1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxFbmQgPSB0aGlzLl9jcm9wT3BlcmF0aW9uLmdldEVuZCgpLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2xpc3RJdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3RJdGVtcyk7XG5cbiAgICAgIC8vIExpc3RlbiB0byBjbGljayBldmVudHNcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gX3RoaXMuX2xpc3RJdGVtc1tpXTtcbiAgICAgICAgbGlzdEl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX29uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saXN0SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZ2l2ZW4gaXRlbSBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHBhcmFtIHtET01PYmplY3R9IGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGlzdEl0ZW1DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkxpc3RJdGVtQ2xpY2soaXRlbSkge1xuICAgICAgdmFyIGRlZ3JlZXMgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1kZWdyZWVzJyk7XG4gICAgICBkZWdyZWVzID0gcGFyc2VJbnQoZGVncmVlcywgMTApO1xuXG4gICAgICB2YXIgY3VycmVudERlZ3JlZXMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RGVncmVlcygpO1xuXG4gICAgICBpZiAoIXRoaXMuX2hpc3RvcnlJdGVtKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLl9vcGVyYXRpb24sIHtcbiAgICAgICAgICBkZWdyZWVzOiB0aGlzLl9pbml0aWFsRGVncmVlc1xuICAgICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcm90YXRlQ3JvcChkZWdyZWVzKTtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXREZWdyZWVzKGN1cnJlbnREZWdyZWVzICsgZGVncmVlcyk7XG4gICAgICB0aGlzLl91aS5jYW52YXMuem9vbVRvRml0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUm90YXRlcyB0aGUgY3VycmVudCBjcm9wIG9wdGlvbnMgYnkgdGhlIGdpdmVuIGRlZ3JlZXNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gZGVncmVlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcm90YXRlQ3JvcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yb3RhdGVDcm9wKGRlZ3JlZXMpIHtcbiAgICAgIGlmICghdGhpcy5fY3JvcE9wZXJhdGlvbikgcmV0dXJuO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9jcm9wT3BlcmF0aW9uLmdldFN0YXJ0KCkuY2xvbmUoKTtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9jcm9wT3BlcmF0aW9uLmdldEVuZCgpLmNsb25lKCk7XG5cbiAgICAgIHZhciBfc3RhcnQgPSBzdGFydC5jbG9uZSgpO1xuICAgICAgc3dpdGNoIChkZWdyZWVzKSB7XG4gICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgc3RhcnQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDEuMCAtIGVuZC55LCBfc3RhcnQueCk7XG4gICAgICAgICAgZW5kID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgxLjAgLSBfc3RhcnQueSwgZW5kLngpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIC05MDpcbiAgICAgICAgICBzdGFydCA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oX3N0YXJ0LnksIDEuMCAtIGVuZC54KTtcbiAgICAgICAgICBlbmQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGVuZC55LCAxLjAgLSBfc3RhcnQueCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nyb3BPcGVyYXRpb24uc2V0KHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFjaygpIHtcbiAgICAgIHZhciBjdXJyZW50RGVncmVlcyA9IHRoaXMuX29wZXJhdGlvbi5nZXREZWdyZWVzKCk7XG4gICAgICBpZiAoY3VycmVudERlZ3JlZXMgPT09IDApIHtcbiAgICAgICAgdGhpcy5fdWkucmVtb3ZlT3BlcmF0aW9uKCdyb3RhdGlvbicpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSb3RhdGlvbkNvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cblJvdGF0aW9uQ29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdyb3RhdGlvbic7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IFJvdGF0aW9uQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy9yb3RhdGlvbi1jb250cm9sLmpzXG4gKiogbW9kdWxlIGlkID0gOTdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgRmxpcENvbnRyb2wgPSAoZnVuY3Rpb24gKF9Db250cm9sKSB7XG4gIF9pbmhlcml0cyhGbGlwQ29udHJvbCwgX0NvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIEZsaXBDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGbGlwQ29udHJvbCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihGbGlwQ29udHJvbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBjb250cm9sLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoRmxpcENvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2PiA8dWwgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1saXN0IGltZ2x5LWNvbnRyb2xzLWxpc3Qtd2l0aC1idXR0b25zXCI+IDxsaSBkYXRhLWRpcmVjdGlvbj1cImhvcml6b250YWxcIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvZmxpcC9ob3Jpem9udGFsLnBuZycpKSsnXCIgLz4gPC9saT4gPGxpIGRhdGEtZGlyZWN0aW9uPVwidmVydGljYWxcIj4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvZmxpcC92ZXJ0aWNhbC5wbmcnKSkrJ1wiIC8+IDwvbGk+IDwvdWw+PC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPSBjb250cm9sc1RlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGFjdGl2YXRlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRW50ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FbnRlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gbnVsbDtcbiAgICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSAhIXRoaXMuX3VpLm9wZXJhdGlvbnMuZmxpcDtcbiAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdmbGlwJyk7XG5cbiAgICAgIHRoaXMuX2luaXRpYWxIb3Jpem9udGFsID0gdGhpcy5fb3BlcmF0aW9uLmdldEhvcml6b250YWwoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxWZXJ0aWNhbCA9IHRoaXMuX29wZXJhdGlvbi5nZXRWZXJ0aWNhbCgpO1xuXG4gICAgICB2YXIgbGlzdEl0ZW1zID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvckFsbCgnbGknKTtcbiAgICAgIHRoaXMuX2xpc3RJdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3RJdGVtcyk7XG5cbiAgICAgIC8vIExpc3RlbiB0byBjbGljayBldmVudHNcblxuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIGxpc3RJdGVtID0gX3RoaXMuX2xpc3RJdGVtc1tpXTtcbiAgICAgICAgbGlzdEl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMuX29uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlyZWN0aW9uJyk7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdob3Jpem9udGFsJyAmJiBfdGhpcy5fb3BlcmF0aW9uLmdldEhvcml6b250YWwoKSkge1xuICAgICAgICAgIF90aGlzLl90b2dnbGVJdGVtKGxpc3RJdGVtLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcgJiYgX3RoaXMuX29wZXJhdGlvbi5nZXRWZXJ0aWNhbCgpKSB7XG4gICAgICAgICAgX3RoaXMuX3RvZ2dsZUl0ZW0obGlzdEl0ZW0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcChpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrZWQgYSBsaXN0IGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGlzdEl0ZW1DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkxpc3RJdGVtQ2xpY2soaXRlbSkge1xuICAgICAgdmFyIGRpcmVjdGlvbiA9IGl0ZW0uZ2V0QXR0cmlidXRlKCdkYXRhLWRpcmVjdGlvbicpO1xuICAgICAgdmFyIGFjdGl2ZSA9IGZhbHNlO1xuXG4gICAgICB2YXIgY3VycmVudEhvcml6b250YWwgPSB0aGlzLl9vcGVyYXRpb24uZ2V0SG9yaXpvbnRhbCgpO1xuICAgICAgdmFyIGN1cnJlbnRWZXJ0aWNhbCA9IHRoaXMuX29wZXJhdGlvbi5nZXRWZXJ0aWNhbCgpO1xuXG4gICAgICBpZiAoZGlyZWN0aW9uID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldEhvcml6b250YWwoIWN1cnJlbnRIb3Jpem9udGFsKTtcbiAgICAgICAgY3VycmVudEhvcml6b250YWwgPSAhY3VycmVudEhvcml6b250YWw7XG4gICAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICAgICAgYWN0aXZlID0gIWN1cnJlbnRIb3Jpem9udGFsO1xuICAgICAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldFZlcnRpY2FsKCFjdXJyZW50VmVydGljYWwpO1xuICAgICAgICBjdXJyZW50VmVydGljYWwgPSAhY3VycmVudFZlcnRpY2FsO1xuICAgICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgICAgIGFjdGl2ZSA9ICFjdXJyZW50VmVydGljYWw7XG4gICAgICB9XG5cbiAgICAgIGlmICgodGhpcy5faW5pdGlhbFZlcnRpY2FsICE9PSBjdXJyZW50VmVydGljYWwgfHwgdGhpcy5faW5pdGlhbEhvcml6b250YWwgIT09IGN1cnJlbnRIb3Jpem9udGFsKSAmJiAhdGhpcy5faGlzdG9yeUl0ZW0pIHtcbiAgICAgICAgdGhpcy5faGlzdG9yeUl0ZW0gPSB0aGlzLl91aS5hZGRIaXN0b3J5KHRoaXMuX29wZXJhdGlvbiwge1xuICAgICAgICAgIHZlcnRpY2FsOiB0aGlzLl9pbml0aWFsVmVydGljYWwsXG4gICAgICAgICAgaG9yaXpvbnRhbDogdGhpcy5faW5pdGlhbEhvcml6b250YWxcbiAgICAgICAgfSwgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RvZ2dsZUl0ZW0oaXRlbSwgYWN0aXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIGdpdmVuIGl0ZW1cbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGl0ZW1cbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGFjdGl2ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdG9nZ2xlSXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVJdGVtKGl0ZW0sIGFjdGl2ZSkge1xuICAgICAgdmFyIGFjdGl2ZUNsYXNzID0gJ2ltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tYWN0aXZlJztcbiAgICAgIGlmIChhY3RpdmUpIHtcbiAgICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5hZGQoYWN0aXZlQ2xhc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5yZW1vdmUoYWN0aXZlQ2xhc3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrKCkge1xuICAgICAgdmFyIGN1cnJlbnRWZXJ0aWNhbCA9IHRoaXMuX29wZXJhdGlvbi5nZXRWZXJ0aWNhbCgpO1xuICAgICAgdmFyIGN1cnJlbnRIb3Jpem9udGFsID0gdGhpcy5fb3BlcmF0aW9uLmdldEhvcml6b250YWwoKTtcblxuICAgICAgaWYgKCFjdXJyZW50VmVydGljYWwgJiYgIWN1cnJlbnRIb3Jpem9udGFsKSB7XG4gICAgICAgIHRoaXMuX3VpLnJlbW92ZU9wZXJhdGlvbignZmxpcCcpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZsaXBDb250cm9sO1xufSkoX2NvbnRyb2wyWydkZWZhdWx0J10pO1xuXG5GbGlwQ29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdmbGlwJztcblxuZXhwb3J0c1snZGVmYXVsdCddID0gRmxpcENvbnRyb2w7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvY29udHJvbHMvZmxpcC1jb250cm9sLmpzXG4gKiogbW9kdWxlIGlkID0gOThcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYlNsaWRlciA9IHJlcXVpcmUoJy4uL2xpYi9zbGlkZXInKTtcblxudmFyIF9saWJTbGlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliU2xpZGVyKTtcblxudmFyIEJyaWdodG5lc3NDb250cm9sID0gKGZ1bmN0aW9uIChfQ29udHJvbCkge1xuICBfaW5oZXJpdHMoQnJpZ2h0bmVzc0NvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBCcmlnaHRuZXNzQ29udHJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJpZ2h0bmVzc0NvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJpZ2h0bmVzc0NvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKEJyaWdodG5lc3NDb250cm9sLCBbe1xuICAgIGtleTogJ2luaXQnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVudHJ5IHBvaW50IGZvciB0aGlzIGNvbnRyb2xcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBjb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXY+ICcrKGl0LnBhcnRpYWxzLnNsaWRlcikrJzwvZGl2Pic7cmV0dXJuIG91dDtcbn07XG4gICAgICB0aGlzLl9jb250cm9sc1RlbXBsYXRlID0gY29udHJvbHNUZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyID0gX2xpYlNsaWRlcjJbJ2RlZmF1bHQnXS50ZW1wbGF0ZTtcblxuICAgICAgdGhpcy5fb25VcGRhdGUgPSB0aGlzLl9vblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhpcyBjb250cm9sIGlzIGFjdGl2YXRlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRW50ZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FbnRlcigpIHtcbiAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gbnVsbDtcbiAgICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgPSAhIXRoaXMuX3VpLm9wZXJhdGlvbnMuYnJpZ2h0bmVzcztcbiAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdicmlnaHRuZXNzJyk7XG5cbiAgICAgIC8vIEluaXRpYWxseSBzZXQgdmFsdWVcbiAgICAgIHZhciBicmlnaHRuZXNzID0gdGhpcy5fb3BlcmF0aW9uLmdldEJyaWdodG5lc3MoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxCcmlnaHRuZXNzID0gYnJpZ2h0bmVzcztcblxuICAgICAgdmFyIHNsaWRlckVsZW1lbnQgPSB0aGlzLl9jb250cm9scy5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtc2xpZGVyJyk7XG4gICAgICB0aGlzLl9zbGlkZXIgPSBuZXcgX2xpYlNsaWRlcjJbJ2RlZmF1bHQnXShzbGlkZXJFbGVtZW50LCB7XG4gICAgICAgIG1pblZhbHVlOiAtMSxcbiAgICAgICAgbWF4VmFsdWU6IDEsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogYnJpZ2h0bmVzc1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9zbGlkZXIub24oJ3VwZGF0ZScsIHRoaXMuX29uVXBkYXRlKTtcbiAgICAgIHRoaXMuX3NsaWRlci5zZXRWYWx1ZShicmlnaHRuZXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFjaygpIHtcbiAgICAgIHZhciBjdXJyZW50QnJpZ2h0bmVzcyA9IHRoaXMuX29wZXJhdGlvbi5nZXRCcmlnaHRuZXNzKCk7XG5cbiAgICAgIGlmIChjdXJyZW50QnJpZ2h0bmVzcyA9PT0gMS4wKSB7XG4gICAgICAgIHRoaXMuX3VpLnJlbW92ZU9wZXJhdGlvbignYnJpZ2h0bmVzcycpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgICB0aGlzLl9zbGlkZXIgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldEJyaWdodG5lc3ModmFsdWUpO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuXG4gICAgICBpZiAoIXRoaXMuX2hpc3RvcnlJdGVtKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLl9vcGVyYXRpb24sIHtcbiAgICAgICAgICBicmlnaHRuZXNzOiB0aGlzLl9pbml0aWFsQnJpZ2h0bmVzc1xuICAgICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQnJpZ2h0bmVzc0NvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cbkJyaWdodG5lc3NDb250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ2JyaWdodG5lc3MnO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBCcmlnaHRuZXNzQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy9icmlnaHRuZXNzLWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSA5OVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL2V2ZW50LWVtaXR0ZXInKTtcblxudmFyIF9saWJFdmVudEVtaXR0ZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliRXZlbnRFbWl0dGVyKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBTbGlkZXIgPSAoZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKFNsaWRlciwgX0V2ZW50RW1pdHRlcik7XG5cbiAgZnVuY3Rpb24gU2xpZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFNsaWRlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5fb3B0aW9ucyA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5kZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICBtaW5WYWx1ZTogMCxcbiAgICAgIG1heFZhbHVlOiAxLFxuICAgICAgZGVmYXVsdFZhbHVlOiAwXG4gICAgfSk7XG5cbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX29wdGlvbnMuZGVmYXVsdFZhbHVlO1xuXG4gICAgdGhpcy5fc2xpZGVyRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNsaWRlci1zbGlkZXInKTtcbiAgICB0aGlzLl9kb3RFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtc2xpZGVyLWRvdCcpO1xuICAgIHRoaXMuX2NlbnRlckRvdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1zbGlkZXItY2VudGVyLWRvdCcpO1xuICAgIHRoaXMuX2ZpbGxFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtc2xpZGVyLWZpbGwnKTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWxlbWVudCA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNsaWRlci1iYWNrZ3JvdW5kJyk7XG5cbiAgICAvLyBNb3VzZSBldmVudCBjYWxsYmFja3MgYm91bmQgdG8gY2xhc3MgY29udGV4dFxuICAgIHRoaXMuX29uTW91c2VEb3duID0gdGhpcy5fb25Nb3VzZURvd24uYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbk1vdXNlTW92ZSA9IHRoaXMuX29uTW91c2VNb3ZlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25Nb3VzZVVwID0gdGhpcy5fb25Nb3VzZVVwLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25DZW50ZXJEb3RDbGljayA9IHRoaXMuX29uQ2VudGVyRG90Q2xpY2suYmluZCh0aGlzKTtcbiAgICB0aGlzLl9vbkJhY2tncm91bmRDbGljayA9IHRoaXMuX29uQmFja2dyb3VuZENsaWNrLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9iYWNrZ3JvdW5kRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQmFja2dyb3VuZENsaWNrKTtcbiAgICB0aGlzLl9maWxsRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uQmFja2dyb3VuZENsaWNrKTtcblxuICAgIHRoaXMuX2hhbmRsZURvdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aWFsIHRlbXBsYXRlIHN0cmluZ1xuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xuICAgIGtleTogJ3NldFZhbHVlJyxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGdpdmVuIHZhbHVlXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXG4gICAgICB2YXIgX29wdGlvbnMgPSB0aGlzLl9vcHRpb25zO1xuICAgICAgdmFyIG1heFZhbHVlID0gX29wdGlvbnMubWF4VmFsdWU7XG4gICAgICB2YXIgbWluVmFsdWUgPSBfb3B0aW9ucy5taW5WYWx1ZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBYIHBvc2l0aW9uXG4gICAgICB2YXIgdmFsdWVSYW5nZSA9IG1heFZhbHVlIC0gbWluVmFsdWU7XG4gICAgICB2YXIgcGVyY2VudGFnZSA9ICh2YWx1ZSAtIG1pblZhbHVlKSAvIHZhbHVlUmFuZ2U7XG4gICAgICB2YXIgc2xpZGVyV2lkdGggPSB0aGlzLl9zbGlkZXJFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgdGhpcy5fc2V0WChzbGlkZXJXaWR0aCAqIHBlcmNlbnRhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHNsaWRlciBwb3NpdGlvbiB0byB0aGUgZ2l2ZW4gWCB2YWx1ZSBhbmQgcmVzaXplc1xuICAgICAqIHRoZSBmaWxsIGRpdlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0WCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRYKHgpIHtcbiAgICAgIHRoaXMuX3hQb3NpdGlvbiA9IHg7XG4gICAgICB0aGlzLl9kb3RFbGVtZW50LnN0eWxlLmxlZnQgPSB4ICsgJ3B4JztcblxuICAgICAgLy8gWCBwb3NpdGlvbiByZWxhdGl2ZSB0byBjZW50ZXIgdG8gc2ltcGxpZnkgY2FsY3VsYXRpb25zXG4gICAgICB2YXIgaGFsZlNsaWRlcldpZHRoID0gdGhpcy5fc2xpZGVyRWxlbWVudC5vZmZzZXRXaWR0aCAvIDI7XG4gICAgICB2YXIgcmVsYXRpdmVYID0geCAtIGhhbGZTbGlkZXJXaWR0aDtcblxuICAgICAgLy8gVXBkYXRlIHN0eWxlXG4gICAgICB0aGlzLl9maWxsRWxlbWVudC5zdHlsZS53aWR0aCA9IE1hdGguYWJzKHJlbGF0aXZlWCkgKyAncHgnO1xuICAgICAgaWYgKHJlbGF0aXZlWCA8IDApIHtcbiAgICAgICAgdGhpcy5fZmlsbEVsZW1lbnQuc3R5bGUubGVmdCA9IGhhbGZTbGlkZXJXaWR0aCAtIE1hdGguYWJzKHJlbGF0aXZlWCkgKyAncHgnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZmlsbEVsZW1lbnQuc3R5bGUubGVmdCA9IGhhbGZTbGlkZXJXaWR0aCArICdweCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgZG90IGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVEb3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRG90KCkge1xuICAgICAgdGhpcy5fZG90RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XG4gICAgICB0aGlzLl9kb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbk1vdXNlRG93bik7XG5cbiAgICAgIGlmICh0aGlzLl9jZW50ZXJEb3RFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuX2NlbnRlckRvdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkNlbnRlckRvdENsaWNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgY2VudGVyIGJ1dHRvbi4gUmVzZXRzIHRvIGRlZmF1bHRcbiAgICAgKiBzZXR0aW5ncy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQ2VudGVyRG90Q2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25DZW50ZXJEb3RDbGljaygpIHtcbiAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5fb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl92YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gdGhlIHNsaWRlciBiYWNrZ3JvdW5kXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrZ3JvdW5kQ2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrZ3JvdW5kQ2xpY2soZSkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB2YXIgc2xpZGVyT2Zmc2V0ID0gdGhpcy5fc2xpZGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHNsaWRlck9mZnNldCA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oc2xpZGVyT2Zmc2V0LmxlZnQsIHNsaWRlck9mZnNldC55KTtcblxuICAgICAgdmFyIHJlbGF0aXZlUG9zaXRpb24gPSBwb3NpdGlvbi5jbG9uZSgpLnN1YnRyYWN0KHNsaWRlck9mZnNldCk7XG5cbiAgICAgIHRoaXMuX3NldFgocmVsYXRpdmVQb3NpdGlvbi54KTtcbiAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIGEgbW91c2UgYnV0dG9uIG9uIHRoZSBzbGlkZXIgZG90XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdXNlRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlRG93bihlKSB7XG4gICAgICBpZiAoZS50eXBlID09PSAnbW91c2Vkb3duJyAmJiBlLmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApO1xuXG4gICAgICAvLyBSZW1lbWJlciBpbml0aWFsIHBvc2l0aW9uXG4gICAgICB2YXIgZG90UG9zaXRpb24gPSB0aGlzLl9kb3RFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNsaWRlclBvc2l0aW9uID0gdGhpcy5fc2xpZGVyRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgdGhpcy5faW5pdGlhbFNsaWRlclggPSBkb3RQb3NpdGlvbi5sZWZ0IC0gc2xpZGVyUG9zaXRpb24ubGVmdDtcbiAgICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gbW91c2VQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Nb3VzZU1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3VzZU1vdmUoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdmFyIG1vdXNlRGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuXG4gICAgICAvLyBBZGQgaGFsZiB3aWR0aCBvZiB0aGUgZG90IGZvciBuZWdhdGl2ZSBtYXJnaW4gY29tcGVuc2F0aW9uXG4gICAgICB2YXIgaGFsZkRvdFdpZHRoID0gdGhpcy5fZG90RWxlbWVudC5vZmZzZXRXaWR0aCAqIDAuNTtcbiAgICAgIHZhciBuZXdTbGlkZXJYID0gdGhpcy5faW5pdGlhbFNsaWRlclggKyBtb3VzZURpZmYueCArIGhhbGZEb3RXaWR0aDtcblxuICAgICAgLy8gWCBib3VuZGFyaWVzXG4gICAgICB2YXIgc2xpZGVyV2lkdGggPSB0aGlzLl9zbGlkZXJFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgbmV3U2xpZGVyWCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG5ld1NsaWRlclgsIHNsaWRlcldpZHRoKSk7XG5cbiAgICAgIHRoaXMuX3NldFgobmV3U2xpZGVyWCk7XG4gICAgICB0aGlzLl91cGRhdGVWYWx1ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIHVzaW5nIHRoZSBzbGlkZXIgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVZhbHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZhbHVlKCkge1xuICAgICAgdmFyIHNsaWRlcldpZHRoID0gdGhpcy5fc2xpZGVyRWxlbWVudC5vZmZzZXRXaWR0aDtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBuZXcgdmFsdWVcbiAgICAgIHZhciBfb3B0aW9uczIgPSB0aGlzLl9vcHRpb25zO1xuICAgICAgdmFyIG1pblZhbHVlID0gX29wdGlvbnMyLm1pblZhbHVlO1xuICAgICAgdmFyIG1heFZhbHVlID0gX29wdGlvbnMyLm1heFZhbHVlO1xuXG4gICAgICB2YXIgcGVyY2VudGFnZSA9IHRoaXMuX3hQb3NpdGlvbiAvIHNsaWRlcldpZHRoO1xuICAgICAgdmFyIHZhbHVlID0gbWluVmFsdWUgKyAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgKiBwZXJjZW50YWdlO1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkb2VzIG5vdCBwcmVzcyB0aGUgbW91c2UgYnV0dG9uIGFueW1vcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTW91c2VVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlVXAoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAndGVtcGxhdGUnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc2xpZGVyXCIgaWQ9XCInKygodHlwZW9mIGl0LmlkID09PSBcInVuZGVmaW5lZFwiPycnOml0LmlkKSkrJ1wiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc2xpZGVyLW1pbnVzXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3NsaWRlci9taW51cy5wbmcnKSApKydcIiAvPiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1zbGlkZXJcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1jb250ZW50XCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zbGlkZXItYmFja2dyb3VuZFwiPjwvZGl2PiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc2xpZGVyLWZpbGxcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1jZW50ZXItZG90XCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zbGlkZXItZG90XCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1wbHVzXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3NsaWRlci9wbHVzLnBuZycpICkrJ1wiIC8+IDwvZGl2PjwvZGl2Pic7cmV0dXJuIG91dDtcbn07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNsaWRlcjtcbn0pKF9saWJFdmVudEVtaXR0ZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTbGlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL3NsaWRlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xuXG52YXIgX2NvbnRyb2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udHJvbCk7XG5cbnZhciBfbGliU2xpZGVyID0gcmVxdWlyZSgnLi4vbGliL3NsaWRlcicpO1xuXG52YXIgX2xpYlNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJTbGlkZXIpO1xuXG52YXIgQ29udHJhc3RDb250cm9sID0gKGZ1bmN0aW9uIChfQ29udHJvbCkge1xuICBfaW5oZXJpdHMoQ29udHJhc3RDb250cm9sLCBfQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gQ29udHJhc3RDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb250cmFzdENvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ29udHJhc3RDb250cm9sLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIGNvbnRyb2wuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhDb250cmFzdENvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2PiAnKyhpdC5wYXJ0aWFscy5zbGlkZXIpKyc8L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLnNsaWRlciA9IF9saWJTbGlkZXIyWydkZWZhdWx0J10udGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgdGhpcy5faGlzdG9yeUl0ZW0gPSBudWxsO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9ICEhdGhpcy5fdWkub3BlcmF0aW9ucy5jb250cmFzdDtcbiAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdjb250cmFzdCcpO1xuXG4gICAgICAvLyBJbml0aWFsbHkgc2V0IHZhbHVlXG4gICAgICB2YXIgY29udHJhc3QgPSB0aGlzLl9vcGVyYXRpb24uZ2V0Q29udHJhc3QoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxDb250cmFzdCA9IGNvbnRyYXN0O1xuXG4gICAgICB2YXIgc2xpZGVyRWxlbWVudCA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1zbGlkZXInKTtcbiAgICAgIHRoaXMuX3NsaWRlciA9IG5ldyBfbGliU2xpZGVyMlsnZGVmYXVsdCddKHNsaWRlckVsZW1lbnQsIHtcbiAgICAgICAgbWluVmFsdWU6IDAsXG4gICAgICAgIG1heFZhbHVlOiAyLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGNvbnRyYXN0XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NsaWRlci5vbigndXBkYXRlJywgdGhpcy5fb25VcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9zbGlkZXIuc2V0VmFsdWUodGhpcy5faW5pdGlhbENvbnRyYXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFjaygpIHtcbiAgICAgIHZhciBjdXJyZW50Q29udHJhc3QgPSB0aGlzLl9vcGVyYXRpb24uZ2V0Q29udHJhc3QoKTtcblxuICAgICAgaWYgKGN1cnJlbnRDb250cmFzdCA9PT0gMS4wKSB7XG4gICAgICAgIHRoaXMuX3VpLnJlbW92ZU9wZXJhdGlvbignY29udHJhc3QnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHZhbHVlIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblVwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblVwZGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldENvbnRyYXN0KHZhbHVlKTtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcblxuICAgICAgdmFyIGN1cnJlbnRDb250cmFzdCA9IHRoaXMuX29wZXJhdGlvbi5nZXRDb250cmFzdCgpO1xuICAgICAgaWYgKHRoaXMuX2luaXRpYWxDb250cmFzdCAhPT0gY3VycmVudENvbnRyYXN0ICYmICF0aGlzLl9oaXN0b3J5SXRlbSkge1xuICAgICAgICB0aGlzLl9oaXN0b3J5SXRlbSA9IHRoaXMuX3VpLmFkZEhpc3RvcnkodGhpcy5fb3BlcmF0aW9uLCB7XG4gICAgICAgICAgY29udHJhc3Q6IHRoaXMuX2luaXRpYWxDb250cmFzdFxuICAgICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29udHJhc3RDb250cm9sO1xufSkoX2NvbnRyb2wyWydkZWZhdWx0J10pO1xuXG5Db250cmFzdENvbnRyb2wucHJvdG90eXBlLmlkZW50aWZpZXIgPSAnY29udHJhc3QnO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBDb250cmFzdENvbnRyb2w7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvY29udHJvbHMvY29udHJhc3QtY29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwMVxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfbGliU2xpZGVyID0gcmVxdWlyZSgnLi4vbGliL3NsaWRlcicpO1xuXG52YXIgX2xpYlNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJTbGlkZXIpO1xuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgU2F0dXJhdGlvbkNvbnRyb2wgPSAoZnVuY3Rpb24gKF9Db250cm9sKSB7XG4gIF9pbmhlcml0cyhTYXR1cmF0aW9uQ29udHJvbCwgX0NvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIFNhdHVyYXRpb25Db250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTYXR1cmF0aW9uQ29udHJvbCk7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTYXR1cmF0aW9uQ29udHJvbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBjb250cm9sLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoU2F0dXJhdGlvbkNvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2PiAnKyhpdC5wYXJ0aWFscy5zbGlkZXIpKyc8L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLnNsaWRlciA9IF9saWJTbGlkZXIyWydkZWZhdWx0J10udGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgdGhpcy5faGlzdG9yeUl0ZW0gPSBudWxsO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9ICEhdGhpcy5fdWkub3BlcmF0aW9ucy5zYXR1cmF0aW9uO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5fdWkuZ2V0T3JDcmVhdGVPcGVyYXRpb24oJ3NhdHVyYXRpb24nKTtcblxuICAgICAgLy8gSW5pdGlhbGx5IHNldCB2YWx1ZVxuICAgICAgdmFyIHNhdHVyYXRpb24gPSB0aGlzLl9vcGVyYXRpb24uZ2V0U2F0dXJhdGlvbigpO1xuICAgICAgdGhpcy5faW5pdGlhbFNhdHVyYXRpb24gPSBzYXR1cmF0aW9uO1xuXG4gICAgICB2YXIgc2xpZGVyRWxlbWVudCA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1zbGlkZXInKTtcbiAgICAgIHRoaXMuX3NsaWRlciA9IG5ldyBfbGliU2xpZGVyMlsnZGVmYXVsdCddKHNsaWRlckVsZW1lbnQsIHtcbiAgICAgICAgbWluVmFsdWU6IDAsXG4gICAgICAgIG1heFZhbHVlOiAyLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHNhdHVyYXRpb25cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2xpZGVyLm9uKCd1cGRhdGUnLCB0aGlzLl9vblVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX3NsaWRlci5zZXRWYWx1ZSh0aGlzLl9pbml0aWFsU2F0dXJhdGlvbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFjayBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2soKSB7XG4gICAgICB2YXIgY3VycmVudFNhdHVyYXRpb24gPSB0aGlzLl9vcGVyYXRpb24uZ2V0U2F0dXJhdGlvbigpO1xuXG4gICAgICBpZiAoY3VycmVudFNhdHVyYXRpb24gPT09IDEpIHtcbiAgICAgICAgdGhpcy5fdWkucmVtb3ZlT3BlcmF0aW9uKCdzYXR1cmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiB1cGRhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25VcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25VcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXRTYXR1cmF0aW9uKHZhbHVlKTtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcblxuICAgICAgdmFyIGN1cnJlbnRTYXR1cmF0aW9uID0gdGhpcy5fb3BlcmF0aW9uLmdldFNhdHVyYXRpb24oKTtcbiAgICAgIGlmICh0aGlzLl9pbml0aWFsU2F0dXJhdGlvbiAhPT0gY3VycmVudFNhdHVyYXRpb24gJiYgIXRoaXMuX2hpc3RvcnlJdGVtKSB7XG4gICAgICAgIHRoaXMuX2hpc3RvcnlJdGVtID0gdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLl9vcGVyYXRpb24sIHtcbiAgICAgICAgICBzYXR1cmF0aW9uOiB0aGlzLl9pbml0aWFsU2F0dXJhdGlvblxuICAgICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2F0dXJhdGlvbkNvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cblNhdHVyYXRpb25Db250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3NhdHVyYXRpb24nO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTYXR1cmF0aW9uQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy9zYXR1cmF0aW9uLWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gyLCBfeDMsIF94NCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDIsIHByb3BlcnR5ID0gX3gzLCByZWNlaXZlciA9IF94NDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDIgPSBwYXJlbnQ7IF94MyA9IHByb3BlcnR5OyBfeDQgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIENyb3BDb250cm9sID0gKGZ1bmN0aW9uIChfQ29udHJvbCkge1xuICBfaW5oZXJpdHMoQ3JvcENvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBDcm9wQ29udHJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ3JvcENvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQ3JvcENvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKENyb3BDb250cm9sLCBbe1xuICAgIGtleTogJ2luaXQnLFxuXG4gICAgLyoqXG4gICAgICogRW50cnkgcG9pbnQgZm9yIHRoaXMgY29udHJvbFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdGhpcy5fYXZhaWxhYmxlUmF0aW9zID0ge307XG4gICAgICB0aGlzLl9yYXRpb3MgPSB7fTtcblxuICAgICAgdmFyIGNvbnRyb2xzVGVtcGxhdGUgPSBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdj4gPHVsIGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtbGlzdCBpbWdseS1jb250cm9scy1saXN0LXdpdGgtYnV0dG9uc1wiPiAnOyBmb3IodmFyIGlkZW50aWZpZXIgaW4gaXQucmF0aW9zKSB7IG91dCs9JyAnOyB2YXIgcmF0aW8gPSBpdC5yYXRpb3NbaWRlbnRpZmllcl07IG91dCs9JyAnOyB2YXIgZW5hYmxlZCA9IHJhdGlvLnNlbGVjdGVkOyBvdXQrPScgPGxpIGRhdGEtaWRlbnRpZmllcj1cIicrKCBpZGVudGlmaWVyKSsnXCIgZGF0YS1yYXRpbz1cIicrKCByYXRpby5yYXRpbykrJ1wiJztpZihlbmFibGVkKXtvdXQrPScgZGF0YS1zZWxlY3RlZCc7fW91dCs9Jz4gPGltZyBzcmM9XCInKyhpdC5oZWxwZXJzLmFzc2V0UGF0aCgndWkvbmlnaHQvY3JvcC8nICsgaWRlbnRpZmllciArICcucG5nJykpKydcIiAvPiA8L2xpPiAnOyB9IG91dCs9JyA8L3VsPjwvZGl2PicrKGl0LnBhcnRpYWxzLmRvbmVCdXR0b24pO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIHZhciBjYW52YXNDb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtY3JvcC1jb250YWluZXJcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLXRvcFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWNyb3AtdG9wLWxlZnRcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLXRvcC1jZW50ZXJcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLXRvcC1yaWdodFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWNlbnRlclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWNyb3AtY2VudGVyLWxlZnRcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWNlbnRlci1jZW50ZXJcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWtub2JzXCI+IDxkaXYgZGF0YS1jb3JuZXI9XCJ0b3AtbGVmdFwiPjwvZGl2PiA8ZGl2IGRhdGEtY29ybmVyPVwidG9wLXJpZ2h0XCI+PC9kaXY+IDxkaXYgZGF0YS1jb3JuZXI9XCJib3R0b20tbGVmdFwiPjwvZGl2PiA8ZGl2IGRhdGEtY29ybmVyPVwiYm90dG9tLXJpZ2h0XCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWNlbnRlci1yaWdodFwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWJvdHRvbVwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLWNyb3AtYm90dG9tLWxlZnRcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWJvdHRvbS1jZW50ZXJcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1jcm9wLWJvdHRvbS1yaWdodFwiPjwvZGl2PiA8L2Rpdj48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGNhbnZhc0NvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIC8vIE1vdXNlIGV2ZW50IGNhbGxiYWNrcyBib3VuZCB0byB0aGUgY2xhc3MgY29udGV4dFxuICAgICAgdGhpcy5fb25Lbm9iRG93biA9IHRoaXMuX29uS25vYkRvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uS25vYkRyYWcgPSB0aGlzLl9vbktub2JEcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbktub2JVcCA9IHRoaXMuX29uS25vYlVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkNlbnRlckRvd24gPSB0aGlzLl9vbkNlbnRlckRvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uQ2VudGVyRHJhZyA9IHRoaXMuX29uQ2VudGVyRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25DZW50ZXJVcCA9IHRoaXMuX29uQ2VudGVyVXAuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5fYWRkRGVmYXVsdFJhdGlvcygpO1xuXG4gICAgICAvLyBTZWxlY3QgYWxsIHJhdGlvcyBwZXIgZGVmYXVsdFxuICAgICAgdGhpcy5zZWxlY3RSYXRpb3MobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgcmF0aW9zXG4gICAgICogQHBhcmFtIHtTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdFJhdGlvcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFJhdGlvcyhzZWxlY3Rvcikge1xuICAgICAgdGhpcy5fcmF0aW9zID0ge307XG5cbiAgICAgIHZhciByYXRpb0lkZW50aWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5fYXZhaWxhYmxlUmF0aW9zKTtcblxuICAgICAgdmFyIHNlbGVjdGVkUmF0aW9zID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLnNlbGVjdChyYXRpb0lkZW50aWZpZXJzLCBzZWxlY3Rvcik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkUmF0aW9zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpZGVudGlmaWVyID0gc2VsZWN0ZWRSYXRpb3NbaV07XG4gICAgICAgIHRoaXMuX3JhdGlvc1tpZGVudGlmaWVyXSA9IHRoaXMuX2F2YWlsYWJsZVJhdGlvc1tpZGVudGlmaWVyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJDb250cm9scygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdGhlIGRlZmF1bHQgcmF0aW9zXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hZGREZWZhdWx0UmF0aW9zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZERlZmF1bHRSYXRpb3MoKSB7XG4gICAgICB0aGlzLmFkZFJhdGlvKCdjdXN0b20nLCAnKicsIHRydWUpO1xuICAgICAgdGhpcy5hZGRSYXRpbygnc3F1YXJlJywgJzEnKTtcbiAgICAgIHRoaXMuYWRkUmF0aW8oJzQtMycsICcxLjMzJyk7XG4gICAgICB0aGlzLmFkZFJhdGlvKCcxNi05JywgJzEuNzcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcmF0aW8gd2l0aCB0aGUgZ2l2ZW4gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZGVudGlmaWVyXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHJhdGlvXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzZWxlY3RlZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWRkUmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSYXRpbyhpZGVudGlmaWVyLCByYXRpbywgc2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuX2F2YWlsYWJsZVJhdGlvc1tpZGVudGlmaWVyXSA9IHsgcmF0aW86IHJhdGlvLCBzZWxlY3RlZDogc2VsZWN0ZWQgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRW50ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wQ29udHJvbC5wcm90b3R5cGUpLCAnX29uRW50ZXInLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLmNyb3A7XG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLl91aS5nZXRPckNyZWF0ZU9wZXJhdGlvbignY3JvcCcpO1xuXG4gICAgICB0aGlzLl9kZWZhdWx0U3RhcnQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAuMSwgMC4xKTtcbiAgICAgIHRoaXMuX2RlZmF1bHRFbmQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAuOSwgMC45KTtcblxuICAgICAgLy8gU3RvcmUgaW5pdGlhbCBzZXR0aW5ncyBmb3IgJ2JhY2snIGJ1dHRvblxuICAgICAgdGhpcy5faW5pdGlhbFN0YXJ0ID0gdGhpcy5fb3BlcmF0aW9uLmdldFN0YXJ0KCkuY2xvbmUoKTtcbiAgICAgIHRoaXMuX2luaXRpYWxFbmQgPSB0aGlzLl9vcGVyYXRpb24uZ2V0RW5kKCkuY2xvbmUoKTtcblxuICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl9pbml0aWFsU3RhcnQgfHwgdGhpcy5fZGVmYXVsdFN0YXJ0O1xuICAgICAgdGhpcy5fZW5kID0gdGhpcy5faW5pdGlhbEVuZCB8fCB0aGlzLl9kZWZhdWx0RW5kO1xuXG4gICAgICAvLyBNaW5pbXVtIHNpemUgaW4gcGl4ZWxzXG4gICAgICB0aGlzLl9taW5pbXVtU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oNTAsIDUwKTtcblxuICAgICAgdGhpcy5faW5pdGlhbFpvb21MZXZlbCA9IHRoaXMuX3VpLmNhbnZhcy56b29tTGV2ZWw7XG4gICAgICB0aGlzLl91aS5jYW52YXMuem9vbVRvRml0KGZhbHNlKTtcblxuICAgICAgdmFyIHByZWZpeCA9ICcuaW1nbHlraXQtY2FudmFzLWNyb3AnO1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuX2NhbnZhc0NvbnRyb2xzO1xuICAgICAgdmFyIGtub2JzQ29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IocHJlZml4ICsgJy1rbm9icycpO1xuXG4gICAgICAvLyBNYWtlIHN1cmUgd2Ugc2VlIHRoZSB3aG9sZSBpbnB1dCBpbWFnZVxuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICAgIHN0YXJ0OiBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApLFxuICAgICAgICBlbmQ6IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMSwgMSlcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGaW5kIGFsbCA0IGtub2JzXG4gICAgICB0aGlzLl9rbm9icyA9IHtcbiAgICAgICAgdG9wTGVmdDoga25vYnNDb250YWluZXIucXVlcnlTZWxlY3RvcignW2RhdGEtY29ybmVyPXRvcC1sZWZ0XScpLFxuICAgICAgICB0b3BSaWdodDoga25vYnNDb250YWluZXIucXVlcnlTZWxlY3RvcignW2RhdGEtY29ybmVyPXRvcC1yaWdodF0nKSxcbiAgICAgICAgYm90dG9tTGVmdDoga25vYnNDb250YWluZXIucXVlcnlTZWxlY3RvcignW2RhdGEtY29ybmVyPWJvdHRvbS1sZWZ0XScpLFxuICAgICAgICBib3R0b21SaWdodDoga25vYnNDb250YWluZXIucXVlcnlTZWxlY3RvcignW2RhdGEtY29ybmVyPWJvdHRvbS1yaWdodF0nKVxuICAgICAgfTtcblxuICAgICAgLy8gRmluZCB0aGUgZGl2IGFyZWFzIHRoYXQgYWZmZWN0IHRoZSBkaXNwbGF5ZWQgY3JvcCBzaXplXG4gICAgICB0aGlzLl9hcmVhcyA9IHtcbiAgICAgICAgdG9wTGVmdDogdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcihwcmVmaXggKyAnLXRvcC1sZWZ0JyksXG4gICAgICAgIHRvcENlbnRlcjogdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcihwcmVmaXggKyAnLXRvcC1jZW50ZXInKSxcbiAgICAgICAgY2VudGVyTGVmdDogdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcihwcmVmaXggKyAnLWNlbnRlci1sZWZ0JyksXG4gICAgICAgIGNlbnRlckNlbnRlcjogdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcihwcmVmaXggKyAnLWNlbnRlci1jZW50ZXInKVxuICAgICAgfTtcblxuICAgICAgdGhpcy5fa25vYnNDb250YWluZXIgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY2FudmFzLWNyb3Ata25vYnMnKTtcblxuICAgICAgdGhpcy5faGFuZGxlQ29udHJvbHMoKTtcbiAgICAgIHRoaXMuX2hhbmRsZUtub2JzKCk7XG4gICAgICB0aGlzLl9oYW5kbGVLbm9ic0NvbnRhaW5lcigpO1xuXG4gICAgICAvLyBSZXN1bWUgdGhlIHJlbmRlcmluZ1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnpvb21Ub0ZpdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlRE9NKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSByYXRpbyBjb250cm9sc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQ29udHJvbHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoJ3VsID4gbGknKTtcbiAgICAgIHRoaXMuX3JhdGlvSXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgaXRlbSA9IF90aGlzMi5fcmF0aW9JdGVtc1tpXTtcbiAgICAgICAgdmFyIHNlbGVjdGVkID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtc2VsZWN0ZWQnKTtcbiAgICAgICAgdmFyIHJhdGlvID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmF0aW8nKTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1pZGVudGlmaWVyJyk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZWN0ZWQgIT09ICd1bmRlZmluZWQnICYmIHNlbGVjdGVkICE9PSBudWxsICYmICFfdGhpczIuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUpIHtcbiAgICAgICAgICBfdGhpczIuX3NldFJhdGlvKGlkZW50aWZpZXIsIHJhdGlvLCBmYWxzZSk7XG4gICAgICAgICAgX3RoaXMyLl9zZWxlY3RSYXRpbyhpdGVtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBfdGhpczIuX29uUmF0aW9DbGljayhpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JhdGlvSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgX2xvb3AoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZ2l2ZW4gcmF0aW8gaGFzIGJlZW4gc2VsZWN0ZWRcbiAgICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uUmF0aW9DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJhdGlvQ2xpY2soaXRlbSkge1xuICAgICAgdGhpcy5fdW5zZWxlY3RBbGxSYXRpb3MoKTtcbiAgICAgIHRoaXMuX3NlbGVjdFJhdGlvKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVuc2VsZWN0cyBhbGwgcmF0aW8gY29udHJvbCBpdGVtc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdW5zZWxlY3RBbGxSYXRpb3MnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5zZWxlY3RBbGxSYXRpb3MoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3JhdGlvSXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9yYXRpb0l0ZW1zW2ldO1xuICAgICAgICBfbGliVXRpbHMyWydkZWZhdWx0J10uY2xhc3NMaXN0KGl0ZW0pLnJlbW92ZSgnaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGdpdmVuIHJhdGlvIGNvbnRyb2wgaXRlbVxuICAgICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gaXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2VsZWN0UmF0aW8nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VsZWN0UmF0aW8oaXRlbSkge1xuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5hZGQoJ2ltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tYWN0aXZlJyk7XG4gICAgICB2YXIgcmF0aW8gPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1yYXRpbycpO1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1pZGVudGlmaWVyJyk7XG4gICAgICB0aGlzLl9zZXRSYXRpbyhpZGVudGlmaWVyLCByYXRpbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZ2l2ZW4gcmF0aW9cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWRlbnRpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByYXRpb1xuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVzaXplXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zZXRSYXRpbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRSYXRpbyhpZGVudGlmaWVyLCByYXRpbykge1xuICAgICAgdmFyIHJlc2l6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiB8fCBhcmd1bWVudHNbMl0gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBhcmd1bWVudHNbMl07XG5cbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG4gICAgICB0aGlzLl9zZWxlY3RlZFJhdGlvID0gaWRlbnRpZmllcjtcblxuICAgICAgaWYgKHJhdGlvID09PSAnKicpIHtcbiAgICAgICAgdGhpcy5fcmF0aW8gPSBudWxsO1xuICAgICAgICB0aGlzLl9zdGFydCA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMC4xLCAwLjEpO1xuICAgICAgICB0aGlzLl9lbmQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAuOSwgMC45KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYXRpbyA9PT0gJ29yaWdpbmFsJykge1xuICAgICAgICAgIHRoaXMuX3JhdGlvID0gY2FudmFzU2l6ZS54IC8gY2FudmFzU2l6ZS55O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhdGlvID0gcGFyc2VGbG9hdChyYXRpbyk7XG4gICAgICAgICAgdGhpcy5fcmF0aW8gPSByYXRpbztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNpemUpIHtcbiAgICAgICAgICBpZiAoY2FudmFzU2l6ZS54IC8gY2FudmFzU2l6ZS55IDw9IHRoaXMuX3JhdGlvKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydC54ID0gMC4xO1xuICAgICAgICAgICAgdGhpcy5fZW5kLnggPSAwLjk7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gMSAvIGNhbnZhc1NpemUueSAqIChjYW52YXNTaXplLnggLyB0aGlzLl9yYXRpbyAqIDAuOCk7XG4gICAgICAgICAgICB0aGlzLl9zdGFydC55ID0gKDEgLSBoZWlnaHQpIC8gMjtcbiAgICAgICAgICAgIHRoaXMuX2VuZC55ID0gMSAtIHRoaXMuX3N0YXJ0Lnk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0LnkgPSAwLjE7XG4gICAgICAgICAgICB0aGlzLl9lbmQueSA9IDAuOTtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IDEgLyBjYW52YXNTaXplLnggKiAodGhpcy5fcmF0aW8gKiBjYW52YXNTaXplLnkgKiAwLjgpO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQueCA9ICgxIC0gd2lkdGgpIC8gMjtcbiAgICAgICAgICAgIHRoaXMuX2VuZC54ID0gMSAtIHRoaXMuX3N0YXJ0Lng7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3VwZGF0ZURPTSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGNyb3BwaW5nIGRpdnMgZm9yIHRoZSBjdXJyZW50IG9wZXJhdGlvbiBzZXR0aW5nc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURPTSgpIHtcbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG4gICAgICB2YXIgc3RhcnRBYnNvbHV0ZSA9IHRoaXMuX3N0YXJ0LmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB2YXIgZW5kQWJzb2x1dGUgPSB0aGlzLl9lbmQuY2xvbmUoKS5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIHZhciBzaXplID0gZW5kQWJzb2x1dGUuY2xvbmUoKS5zdWJ0cmFjdChzdGFydEFic29sdXRlKTtcblxuICAgICAgdmFyIHRvcCA9IE1hdGgubWF4KDEsIHN0YXJ0QWJzb2x1dGUueSk7XG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWF4KDEsIHN0YXJ0QWJzb2x1dGUueCk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLm1heCgxLCBzaXplLngpO1xuICAgICAgdmFyIGhlaWdodCA9IE1hdGgubWF4KDEsIHNpemUueSk7XG5cbiAgICAgIC8vIHdpZHRocyBhcmUgZGVmaW5lZCBieSB0b3AgbGVmdCBhbmQgdG9wIGNlbnRlciBhcmVhc1xuICAgICAgdGhpcy5fYXJlYXMudG9wTGVmdC5zdHlsZS53aWR0aCA9IGxlZnQgKyAncHgnO1xuICAgICAgdGhpcy5fYXJlYXMudG9wQ2VudGVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXG4gICAgICAvLyBoZWlnaHRzIGFyZSBkZWZpbmVkIGJ5IHRvcCBsZWZ0IGFuZCBjZW50ZXIgbGVmdCBhcmVhc1xuICAgICAgdGhpcy5fYXJlYXMudG9wTGVmdC5zdHlsZS5oZWlnaHQgPSB0b3AgKyAncHgnO1xuICAgICAgdGhpcy5fYXJlYXMuY2VudGVyTGVmdC5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXG4gICAgICAvLyBkZWZpbmUgaGVpZ2h0IG9uIGNlbnRlciBkaXYgdG8gbWFrZSBzdXJlIHRoZSBrbm9icyBhcmUgcG9zaXRpb25lZFxuICAgICAgLy8gY29ycmVjdGx5IChidWcgaW4gSUUxMClcbiAgICAgIHRoaXMuX2tub2JzQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUga25vYiBkcmFnZ2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlS25vYnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS25vYnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIChpZGVudGlmaWVyKSB7XG4gICAgICAgIHZhciBrbm9iID0gX3RoaXMzLl9rbm9ic1tpZGVudGlmaWVyXTtcbiAgICAgICAga25vYi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIF90aGlzMy5fb25Lbm9iRG93bihlLCBrbm9iKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGtub2IuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgX3RoaXMzLl9vbktub2JEb3duKGUsIGtub2IpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGlkZW50aWZpZXIgaW4gdGhpcy5fa25vYnMpIHtcbiAgICAgICAgX2xvb3AyKGlkZW50aWZpZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcHJlc3NlcyBhIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHBhcmFtIHtET01FbGVtZW50fSBrbm9iXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbktub2JEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS25vYkRvd24oZSwga25vYikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgdGhpcy5fY3VycmVudEtub2IgPSBrbm9iO1xuICAgICAgdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgdmFsdWVzXG4gICAgICB0aGlzLl9zdGFydEJlZm9yZURyYWcgPSB0aGlzLl9zdGFydC5jbG9uZSgpO1xuICAgICAgdGhpcy5fZW5kQmVmb3JlRHJhZyA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbktub2JEcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Lbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZSB0aGUgdXNlciBkcmFncyBhIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbktub2JEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS25vYkRyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdmFyIG1vdXNlRGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuICAgICAgdmFyIGNvcm5lciA9IHRoaXMuX2N1cnJlbnRLbm9iLmdldEF0dHJpYnV0ZSgnZGF0YS1jb3JuZXInKTtcbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG5cbiAgICAgIHZhciBhYnNvbHV0ZVN0YXJ0ID0gdGhpcy5fc3RhcnRCZWZvcmVEcmFnLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB2YXIgYWJzb2x1dGVFbmQgPSB0aGlzLl9lbmRCZWZvcmVEcmFnLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHZhciB3aWR0aCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBoZWlnaHQgPSB1bmRlZmluZWQsXG4gICAgICAgICAgbWF4aW11bSA9IHVuZGVmaW5lZCxcbiAgICAgICAgICBtaW5pbXVtID0gdW5kZWZpbmVkO1xuXG4gICAgICBzd2l0Y2ggKGNvcm5lcikge1xuICAgICAgICBjYXNlICd0b3AtbGVmdCc6XG4gICAgICAgICAgYWJzb2x1dGVTdGFydC5hZGQobW91c2VEaWZmKTtcbiAgICAgICAgICBtYXhpbXVtID0gYWJzb2x1dGVFbmQuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9taW5pbXVtU2l6ZSk7XG4gICAgICAgICAgYWJzb2x1dGVTdGFydC5jbGFtcChudWxsLCBtYXhpbXVtKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndG9wLXJpZ2h0JzpcbiAgICAgICAgICBhYnNvbHV0ZUVuZC54ICs9IG1vdXNlRGlmZi54O1xuICAgICAgICAgIGFic29sdXRlU3RhcnQueSArPSBtb3VzZURpZmYueTtcbiAgICAgICAgICBhYnNvbHV0ZUVuZC54ID0gTWF0aC5tYXgoYWJzb2x1dGVTdGFydC54ICsgdGhpcy5fbWluaW11bVNpemUueCwgYWJzb2x1dGVFbmQueCk7XG4gICAgICAgICAgYWJzb2x1dGVTdGFydC55ID0gTWF0aC5taW4oYWJzb2x1dGVFbmQueSAtIHRoaXMuX21pbmltdW1TaXplLnksIGFic29sdXRlU3RhcnQueSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgICAgYWJzb2x1dGVFbmQuYWRkKG1vdXNlRGlmZik7XG4gICAgICAgICAgbWluaW11bSA9IGFic29sdXRlU3RhcnQuY2xvbmUoKS5hZGQodGhpcy5fbWluaW11bVNpemUpO1xuICAgICAgICAgIGFic29sdXRlRW5kLmNsYW1wKG1pbmltdW0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgYWJzb2x1dGVTdGFydC54ICs9IG1vdXNlRGlmZi54O1xuICAgICAgICAgIGFic29sdXRlRW5kLnkgKz0gbW91c2VEaWZmLnk7XG4gICAgICAgICAgYWJzb2x1dGVTdGFydC54ID0gTWF0aC5taW4oYWJzb2x1dGVFbmQueCAtIHRoaXMuX21pbmltdW1TaXplLngsIGFic29sdXRlU3RhcnQueCk7XG4gICAgICAgICAgYWJzb2x1dGVFbmQueSA9IE1hdGgubWF4KGFic29sdXRlU3RhcnQueSArIHRoaXMuX21pbmltdW1TaXplLnksIGFic29sdXRlRW5kLnkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGFydC5jb3B5KGFic29sdXRlU3RhcnQpLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICAgIHRoaXMuX2VuZC5jb3B5KGFic29sdXRlRW5kKS5kaXZpZGUoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHRoaXMuX3N0YXJ0LmNsYW1wKDAsIDEpO1xuICAgICAgdGhpcy5fZW5kLmNsYW1wKDAsIDEpO1xuXG4gICAgICAvKipcbiAgICAgICAqIENhbGN1bGF0ZSBib3VuZGFyaWVzXG4gICAgICAgKi9cbiAgICAgIGlmICh0aGlzLl9yYXRpbyAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGNvcm5lcikge1xuICAgICAgICAgIGNhc2UgJ3RvcC1sZWZ0JzpcbiAgICAgICAgICAgIHdpZHRoID0gKHRoaXMuX2VuZC54IC0gdGhpcy5fc3RhcnQueCkgKiBjYW52YXNTaXplLng7XG4gICAgICAgICAgICBoZWlnaHQgPSB3aWR0aCAvIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQueSA9IHRoaXMuX2VuZC55IC0gaGVpZ2h0IC8gY2FudmFzU2l6ZS55O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5fc3RhcnQueSA8PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3N0YXJ0LnkgPSAwO1xuICAgICAgICAgICAgICBoZWlnaHQgPSAodGhpcy5fZW5kLnkgLSB0aGlzLl9zdGFydC55KSAqIGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgdGhpcy5fc3RhcnQueCA9IHRoaXMuX2VuZC54IC0gd2lkdGggLyBjYW52YXNTaXplLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd0b3AtcmlnaHQnOlxuICAgICAgICAgICAgd2lkdGggPSAodGhpcy5fZW5kLnggLSB0aGlzLl9zdGFydC54KSAqIGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgIGhlaWdodCA9IHdpZHRoIC8gdGhpcy5fcmF0aW87XG4gICAgICAgICAgICB0aGlzLl9zdGFydC55ID0gdGhpcy5fZW5kLnkgLSBoZWlnaHQgLyBjYW52YXNTaXplLnk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGFydC55IDw9IDApIHtcbiAgICAgICAgICAgICAgdGhpcy5fc3RhcnQueSA9IDA7XG4gICAgICAgICAgICAgIGhlaWdodCA9ICh0aGlzLl9lbmQueSAtIHRoaXMuX3N0YXJ0LnkpICogY2FudmFzU2l6ZS55O1xuICAgICAgICAgICAgICB3aWR0aCA9IGhlaWdodCAqIHRoaXMuX3JhdGlvO1xuICAgICAgICAgICAgICB0aGlzLl9lbmQueCA9IHRoaXMuX3N0YXJ0LnggKyB3aWR0aCAvIGNhbnZhc1NpemUueDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2JvdHRvbS1yaWdodCc6XG4gICAgICAgICAgICB3aWR0aCA9ICh0aGlzLl9lbmQueCAtIHRoaXMuX3N0YXJ0LngpICogY2FudmFzU2l6ZS54O1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2VuZC55ID0gdGhpcy5fc3RhcnQueSArIGhlaWdodCAvIGNhbnZhc1NpemUueTtcblxuICAgICAgICAgICAgLy8gSWYgYm91bmRhcmllcyBhcmUgZXhjZWVkZWQsIGNhbGN1bGF0ZSB3aWR0aCBieSBtYXhpbXVtIGhlaWdodFxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZC55ID49IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSAxO1xuICAgICAgICAgICAgICBoZWlnaHQgPSAodGhpcy5fZW5kLnkgLSB0aGlzLl9zdGFydC55KSAqIGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgdGhpcy5fZW5kLnggPSB0aGlzLl9zdGFydC54ICsgd2lkdGggLyBjYW52YXNTaXplLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdib3R0b20tbGVmdCc6XG4gICAgICAgICAgICB3aWR0aCA9ICh0aGlzLl9lbmQueCAtIHRoaXMuX3N0YXJ0LngpICogY2FudmFzU2l6ZS54O1xuICAgICAgICAgICAgaGVpZ2h0ID0gd2lkdGggLyB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgIHRoaXMuX2VuZC55ID0gdGhpcy5fc3RhcnQueSArIGhlaWdodCAvIGNhbnZhc1NpemUueTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZC55ID49IDEpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZW5kLnkgPSAxO1xuICAgICAgICAgICAgICBoZWlnaHQgPSAodGhpcy5fZW5kLnkgLSB0aGlzLl9zdGFydC55KSAqIGNhbnZhc1NpemUueTtcbiAgICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgKiB0aGlzLl9yYXRpbztcbiAgICAgICAgICAgICAgdGhpcy5fc3RhcnQueCA9IHRoaXMuX2VuZC54IC0gd2lkdGggLyBjYW52YXNTaXplLng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl91cGRhdGVET00oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGUgdGhlIHVzZXIgcmVsZWFzZXMgYSBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Lbm9iVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Lbm9iVXAoKSB7XG4gICAgICB0aGlzLl9jdXJyZW50S25vYiA9IG51bGw7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbktub2JEcmFnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Lbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNlbnRlciBkcmFnZ2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlS25vYnNDb250YWluZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS25vYnNDb250YWluZXIoKSB7XG4gICAgICB0aGlzLl9rbm9ic0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkNlbnRlckRvd24pO1xuICAgICAgdGhpcy5fa25vYnNDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uQ2VudGVyRG93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBjZW50ZXIgYXJlYVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQ2VudGVyRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNlbnRlckRvd24oZSkge1xuICAgICAgdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcblxuICAgICAgLy8gUmVtZW1iZXIgdGhlIGN1cnJlbnQgdmFsdWVzXG4gICAgICB0aGlzLl9zdGFydEJlZm9yZURyYWcgPSB0aGlzLl9zdGFydC5jbG9uZSgpO1xuICAgICAgdGhpcy5fZW5kQmVmb3JlRHJhZyA9IHRoaXMuX2VuZC5jbG9uZSgpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkNlbnRlckRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25DZW50ZXJEcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkNlbnRlclVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25DZW50ZXJVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBwcmVzc2VzIHRoZSBjZW50ZXIgYXJlYSBhbmQgbW92ZXMgaGlzIG1vdXNlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25DZW50ZXJEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ2VudGVyRHJhZyhlKSB7XG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdmFyIG1vdXNlRGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcblxuICAgICAgLy8gR2V0IHRoZSBjcm9wIHNpemVcbiAgICAgIHZhciBjcm9wU2l6ZSA9IHRoaXMuX2VuZEJlZm9yZURyYWcuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9zdGFydEJlZm9yZURyYWcpO1xuICAgICAgdmFyIGFic29sdXRlQ3JvcFNpemUgPSBjcm9wU2l6ZS5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuXG4gICAgICAvLyBHZXQgdGhlIGFic29sdXRlIGluaXRpYWwgdmFsdWVzXG4gICAgICB2YXIgYWJzb2x1dGVTdGFydCA9IHRoaXMuX3N0YXJ0QmVmb3JlRHJhZy5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgdmFyIGFic29sdXRlRW5kID0gdGhpcy5fZW5kQmVmb3JlRHJhZy5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuXG4gICAgICAvLyBBZGQgdGhlIG1vdXNlIHBvc2l0aW9uIGRpZmZlcmVuY2VcbiAgICAgIGFic29sdXRlU3RhcnQuYWRkKG1vdXNlRGlmZik7XG5cbiAgICAgIC8vIENsYW1wIHRoZSB2YWx1ZVxuICAgICAgdmFyIG1heFN0YXJ0ID0gY2FudmFzU2l6ZS5jbG9uZSgpLnN1YnRyYWN0KGFic29sdXRlQ3JvcFNpemUpO1xuICAgICAgYWJzb2x1dGVTdGFydC5jbGFtcChuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApLCBtYXhTdGFydCk7XG5cbiAgICAgIC8vIEVuZCBwb3NpdGlvbiBkb2VzIG5vdCBjaGFuZ2UgKHJlbGF0aXZlIHRvIHN0YXJ0KVxuICAgICAgYWJzb2x1dGVFbmQuY29weShhYnNvbHV0ZVN0YXJ0KS5hZGQoYWJzb2x1dGVDcm9wU2l6ZSk7XG5cbiAgICAgIC8vIFNldCB0aGUgZmluYWwgdmFsdWVzXG4gICAgICB0aGlzLl9zdGFydC5jb3B5KGFic29sdXRlU3RhcnQpLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICAgIHRoaXMuX2VuZC5jb3B5KGFic29sdXRlRW5kKS5kaXZpZGUoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZURPTSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgcmVsZWFzZXMgdGhlIGNlbnRlciBhcmVhXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25DZW50ZXJVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkNlbnRlclVwKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25DZW50ZXJEcmFnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uQ2VudGVyRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25DZW50ZXJVcCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uQ2VudGVyVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrKCkge1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnNldFpvb21MZXZlbCh0aGlzLl9pbml0aWFsWm9vbUxldmVsLCBmYWxzZSk7XG5cbiAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXQoe1xuICAgICAgICAgIHN0YXJ0OiB0aGlzLl9pbml0aWFsU3RhcnQsXG4gICAgICAgICAgZW5kOiB0aGlzLl9pbml0aWFsRW5kXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdWkucmVtb3ZlT3BlcmF0aW9uKCdjcm9wJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZG9uZSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkRvbmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb25lKCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICAgIHN0YXJ0OiB0aGlzLl9zdGFydCxcbiAgICAgICAgZW5kOiB0aGlzLl9lbmRcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnpvb21Ub0ZpdCh0cnVlKTtcblxuICAgICAgdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLl9vcGVyYXRpb24sIHtcbiAgICAgICAgc3RhcnQ6IHRoaXMuX2luaXRpYWxTdGFydC5jbG9uZSgpLFxuICAgICAgICBlbmQ6IHRoaXMuX2luaXRpYWxFbmQuY2xvbmUoKVxuICAgICAgfSwgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGEgdGhhdCBpcyBhdmFpbGFibGUgdG8gdGhlIHRlbXBsYXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2NvbnRleHQnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGNvbnRleHQgPSBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDcm9wQ29udHJvbC5wcm90b3R5cGUpLCAnY29udGV4dCcsIHRoaXMpO1xuICAgICAgY29udGV4dC5yYXRpb3MgPSB0aGlzLl9yYXRpb3M7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgc2VsZWN0ZWQgcmF0aW8gaWRlbnRpZmllclxuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzZWxlY3RlZFJhdGlvJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZFJhdGlvO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBDcm9wQ29udHJvbDtcbn0pKF9jb250cm9sMlsnZGVmYXVsdCddKTtcblxuQ3JvcENvbnRyb2wucHJvdG90eXBlLmlkZW50aWZpZXIgPSAnY3JvcCc7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IENyb3BDb250cm9sO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2NvbnRyb2xzL2Nyb3AtY29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwM1xuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xuXG52YXIgX2NvbnRyb2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udHJvbCk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgX2xpYlNpbXBsZVNsaWRlciA9IHJlcXVpcmUoJy4uL2xpYi9zaW1wbGUtc2xpZGVyJyk7XG5cbnZhciBfbGliU2ltcGxlU2xpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlNpbXBsZVNsaWRlcik7XG5cbnZhciBSYWRpYWxCbHVyQ29udHJvbCA9IChmdW5jdGlvbiAoX0NvbnRyb2wpIHtcbiAgX2luaGVyaXRzKFJhZGlhbEJsdXJDb250cm9sLCBfQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gUmFkaWFsQmx1ckNvbnRyb2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJhZGlhbEJsdXJDb250cm9sKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFJhZGlhbEJsdXJDb250cm9sLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIGNvbnRyb2wuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhSYWRpYWxCbHVyQ29udHJvbCwgW3tcbiAgICBrZXk6ICdpbml0JyxcblxuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciB0aGlzIGNvbnRyb2xcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBjb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1pY29uXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L2JsdXIvYmx1ci5wbmcnKSkrJ1wiIC8+PC9kaXY+PGRpdj4gJysoIGl0LnBhcnRpYWxzLnNsaWRlcikrJzwvZGl2PicrKCBpdC5wYXJ0aWFscy5kb25lQnV0dG9uKTtyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPSBjb250cm9sc1RlbXBsYXRlO1xuXG4gICAgICB2YXIgY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXJhZGlhbC1ibHVyLWNvbnRhaW5lclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXJhZGlhbC1ibHVyLWRvdFwiIGlkPVwiaW1nbHlraXQtcmFkaWFsLWJsdXItcG9zaXRpb25cIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1yYWRpYWwtYmx1ci1kb3RcIiBpZD1cImltZ2x5a2l0LXJhZGlhbC1ibHVyLWdyYWRpZW50XCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtcmFkaWFsLWJsdXItY2lyY2xlLWNvbnRhaW5lclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXJhZGlhbC1ibHVyLWNpcmNsZVwiPjwvZGl2PiA8L2Rpdj48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGNhbnZhc0NvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyID0gX2xpYlNpbXBsZVNsaWRlcjJbJ2RlZmF1bHQnXS50ZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyLmFkZGl0aW9uYWxDb250ZXh0ID0ge1xuICAgICAgICBpZDogJ2ltZ2x5a2l0LWJsdXItcmFkaXVzLXNsaWRlcidcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSA9ICEhdGhpcy5fdWkub3BlcmF0aW9uc1sncmFkaWFsLWJsdXInXTtcbiAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdyYWRpYWwtYmx1cicpO1xuXG4gICAgICAvLyBSZW1lbWJlciBpbml0aWFsIGlkZW50aXR5IHN0YXRlXG4gICAgICB0aGlzLl9pbml0aWFsU2V0dGluZ3MgPSB7XG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLl9vcGVyYXRpb24uZ2V0UG9zaXRpb24oKS5jbG9uZSgpLFxuICAgICAgICBncmFkaWVudFJhZGl1czogdGhpcy5fb3BlcmF0aW9uLmdldEdyYWRpZW50UmFkaXVzKCksXG4gICAgICAgIGJsdXJSYWRpdXM6IHRoaXMuX29wZXJhdGlvbi5nZXRCbHVyUmFkaXVzKClcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdXNlIGV2ZW50IGNhbGxiYWNrcyBib3VuZCB0byB0aGUgY2xhc3MgY29udGV4dFxuICAgICAgdGhpcy5fb25Qb3NpdGlvbktub2JEb3duID0gdGhpcy5fb25Qb3NpdGlvbktub2JEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcgPSB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUG9zaXRpb25Lbm9iVXAgPSB0aGlzLl9vblBvc2l0aW9uS25vYlVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdyYWRpZW50S25vYkRvd24gPSB0aGlzLl9vbkdyYWRpZW50S25vYkRvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZyA9IHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25HcmFkaWVudEtub2JVcCA9IHRoaXMuX29uR3JhZGllbnRLbm9iVXAuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5fcG9zaXRpb25Lbm9iID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LXJhZGlhbC1ibHVyLXBvc2l0aW9uJyk7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2IgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCcjaW1nbHlraXQtcmFkaWFsLWJsdXItZ3JhZGllbnQnKTtcbiAgICAgIHRoaXMuX2NpcmNsZSA9IHRoaXMuX2NhbnZhc0NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jYW52YXMtcmFkaWFsLWJsdXItY2lyY2xlJyk7XG4gICAgICB0aGlzLl9oYW5kbGVLbm9icygpO1xuICAgICAgdGhpcy5faW5pdFNsaWRlcnMoKTtcblxuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fdXBkYXRlRE9NKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgc2xpZGVyIGNvbnRyb2xzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0U2xpZGVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0U2xpZGVycygpIHtcbiAgICAgIHZhciBibHVyUmFkaXVzU2xpZGVyID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LWJsdXItcmFkaXVzLXNsaWRlcicpO1xuICAgICAgdGhpcy5fYmx1clJhZGl1c1NsaWRlciA9IG5ldyBfbGliU2ltcGxlU2xpZGVyMlsnZGVmYXVsdCddKGJsdXJSYWRpdXNTbGlkZXIsIHtcbiAgICAgICAgbWluVmFsdWU6IDAsXG4gICAgICAgIG1heFZhbHVlOiA0MFxuICAgICAgfSk7XG4gICAgICB0aGlzLl9ibHVyUmFkaXVzU2xpZGVyLm9uKCd1cGRhdGUnLCB0aGlzLl9vbkJsdXJSYWRpdXNVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9ibHVyUmFkaXVzU2xpZGVyLnNldFZhbHVlKHRoaXMuX2luaXRpYWxTZXR0aW5ncy5ibHVyUmFkaXVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB2YWx1ZSBvZiB0aGUgYmx1ciByYWRpdXMgc2xpZGVyIGhhcyBiZWVuIHVwZGF0ZWRcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmx1clJhZGl1c1VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJsdXJSYWRpdXNVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXRCbHVyUmFkaXVzKHZhbHVlKTtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodERvbmVCdXR0b24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrbm9iIGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVLbm9icycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVLbm9icygpIHtcbiAgICAgIC8vIEluaXRpYWxseSBzZXQgZ3JhZGllbnQga25vYiBwb3NpdGlvblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX29wZXJhdGlvbi5nZXRQb3NpdGlvbigpLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbiA9IHBvc2l0aW9uLmNsb25lKCkuYWRkKHRoaXMuX2luaXRpYWxTZXR0aW5ncy5ncmFkaWVudFJhZGl1cywgMCk7XG5cbiAgICAgIHRoaXMuX3Bvc2l0aW9uS25vYi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblBvc2l0aW9uS25vYkRvd24pO1xuICAgICAgdGhpcy5fcG9zaXRpb25Lbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vblBvc2l0aW9uS25vYkRvd24pO1xuICAgICAgdGhpcy5fZ3JhZGllbnRLbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uR3JhZGllbnRLbm9iRG93bik7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2IuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uR3JhZGllbnRLbm9iRG93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgZHJhZ2dpbmcgdGhlIHBvc2l0aW9uIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblBvc2l0aW9uS25vYkRvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qb3NpdGlvbktub2JEb3duKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcblxuICAgICAgdGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHRoaXMuX2luaXRpYWxQb3NpdGlvbiA9IHRoaXMuX29wZXJhdGlvbi5nZXRQb3NpdGlvbigpLmNsb25lKCk7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2JEaXN0YW5jZSA9IHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbFBvc2l0aW9uLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSkpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Qb3NpdGlvbktub2JEcmFnKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUG9zaXRpb25Lbm9iVXApO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblBvc2l0aW9uS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBzdGFydHMgZHJhZ3MgdGhlIHBvc2l0aW9uIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblBvc2l0aW9uS25vYkRyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qb3NpdGlvbktub2JEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB2YXIgZGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuXG4gICAgICB2YXIgbmV3UG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb24uY2xvbmUoKS5tdWx0aXBseShjYW52YXNTaXplKS5hZGQoZGlmZik7XG5cbiAgICAgIHZhciBtYXhQb3NpdGlvbiA9IGNhbnZhc1NpemUuY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9ncmFkaWVudEtub2JEaXN0YW5jZSk7XG4gICAgICBuZXdQb3NpdGlvbi5jbGFtcChuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApLCBtYXhQb3NpdGlvbik7XG5cbiAgICAgIHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uLmNvcHkobmV3UG9zaXRpb24pLmFkZCh0aGlzLl9ncmFkaWVudEtub2JEaXN0YW5jZSk7XG5cbiAgICAgIC8vIFRyYW5zbGF0ZSB0byAwLi4uMVxuICAgICAgbmV3UG9zaXRpb24uZGl2aWRlKGNhbnZhc1NpemUpO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb24uc2V0UG9zaXRpb24obmV3UG9zaXRpb24pO1xuICAgICAgdGhpcy5fdXBkYXRlRE9NKCk7XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgcG9zaXRpb24ga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uUG9zaXRpb25Lbm9iVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qb3NpdGlvbktub2JVcChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uUG9zaXRpb25Lbm9iRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Qb3NpdGlvbktub2JVcCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUG9zaXRpb25Lbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBwb3NpdGlvbiBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25HcmFkaWVudEtub2JEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uR3JhZGllbnRLbm9iRG93bihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB0aGlzLl9pbml0aWFsR3JhZGllbnRLbm9iUG9zaXRpb24gPSB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkdyYWRpZW50S25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25HcmFkaWVudEtub2JEcmFnKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uR3JhZGllbnRLbm9iVXApO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkdyYWRpZW50S25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGlsZSB0aGUgdXNlciBzdGFydHMgZHJhZ3MgdGhlIHBvc2l0aW9uIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkdyYWRpZW50S25vYkRyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HcmFkaWVudEtub2JEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB2YXIgZGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgbmV3IGdyYWRpZW50IGtub2IgcG9zaXRpb25cbiAgICAgIHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uID0gdGhpcy5faW5pdGlhbEdyYWRpZW50S25vYlBvc2l0aW9uLmNsb25lKCkuYWRkKGRpZmYpO1xuICAgICAgdGhpcy5fZ3JhZGllbnRLbm9iUG9zaXRpb24uY2xhbXAobmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLCAwKSwgY2FudmFzU2l6ZSk7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBkaXN0YW5jZSB0byBwb3NpdGlvblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fb3BlcmF0aW9uLmdldFBvc2l0aW9uKCkuY2xvbmUoKS5tdWx0aXBseShjYW52YXNTaXplKTtcbiAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QocG9zaXRpb24pO1xuICAgICAgdmFyIGdyYWRpZW50UmFkaXVzID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3RhbmNlLngsIDIpICsgTWF0aC5wb3coZGlzdGFuY2UueSwgMikpO1xuXG4gICAgICAvLyBVcGRhdGUgb3BlcmF0aW9uXG4gICAgICB0aGlzLl9vcGVyYXRpb24uc2V0R3JhZGllbnRSYWRpdXMoZ3JhZGllbnRSYWRpdXMpO1xuICAgICAgdGhpcy5fdXBkYXRlRE9NKCk7XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgcG9zaXRpb24ga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uR3JhZGllbnRLbm9iVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25HcmFkaWVudEtub2JVcChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkdyYWRpZW50S25vYkRyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25HcmFkaWVudEtub2JVcCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uR3JhZGllbnRLbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGtub2JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZURPTScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVET00oKSB7XG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fb3BlcmF0aW9uLmdldFBvc2l0aW9uKCkuY2xvbmUoKS5tdWx0aXBseShjYW52YXNTaXplKTtcblxuICAgICAgdGhpcy5fcG9zaXRpb25Lbm9iLnN0eWxlLmxlZnQgPSBwb3NpdGlvbi54ICsgJ3B4JztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uS25vYi5zdHlsZS50b3AgPSBwb3NpdGlvbi55ICsgJ3B4JztcblxuICAgICAgdGhpcy5fZ3JhZGllbnRLbm9iLnN0eWxlLmxlZnQgPSB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbi54ICsgJ3B4JztcbiAgICAgIHRoaXMuX2dyYWRpZW50S25vYi5zdHlsZS50b3AgPSB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbi55ICsgJ3B4JztcblxuICAgICAgdmFyIGNpcmNsZVNpemUgPSB0aGlzLl9vcGVyYXRpb24uZ2V0R3JhZGllbnRSYWRpdXMoKSAqIDI7XG4gICAgICB0aGlzLl9jaXJjbGUuc3R5bGUubGVmdCA9IHBvc2l0aW9uLnggKyAncHgnO1xuICAgICAgdGhpcy5fY2lyY2xlLnN0eWxlLnRvcCA9IHBvc2l0aW9uLnkgKyAncHgnO1xuICAgICAgdGhpcy5fY2lyY2xlLnN0eWxlLndpZHRoID0gY2lyY2xlU2l6ZSArICdweCc7XG4gICAgICB0aGlzLl9jaXJjbGUuc3R5bGUuaGVpZ2h0ID0gY2lyY2xlU2l6ZSArICdweCc7XG4gICAgICB0aGlzLl9jaXJjbGUuc3R5bGUubWFyZ2luTGVmdCA9ICctJyArIGNpcmNsZVNpemUgLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuX2NpcmNsZS5zdHlsZS5tYXJnaW5Ub3AgPSAnLScgKyBjaXJjbGVTaXplIC8gMiArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFjayBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2soKSB7XG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSkge1xuICAgICAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHRoaXMuX2luaXRpYWxTZXR0aW5ncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ3JhZGlhbC1ibHVyJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZG9uZSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRG9uZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoKSB7XG4gICAgICB0aGlzLl91aS5hZGRIaXN0b3J5KHRoaXMuX29wZXJhdGlvbiwge1xuICAgICAgICBwb3NpdGlvbjogdGhpcy5faW5pdGlhbFNldHRpbmdzLnBvc2l0aW9uLmNsb25lKCksXG4gICAgICAgIGdyYWRpZW50UmFkaXVzOiB0aGlzLl9pbml0aWFsU2V0dGluZ3MuZ3JhZGllbnRSYWRpdXMsXG4gICAgICAgIGJsdXJSYWRpdXM6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5ibHVyUmFkaXVzXG4gICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmFkaWFsQmx1ckNvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cblJhZGlhbEJsdXJDb250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3JhZGlhbC1ibHVyJztcblxuZXhwb3J0c1snZGVmYXVsdCddID0gUmFkaWFsQmx1ckNvbnRyb2w7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvY29udHJvbHMvcmFkaWFsLWJsdXItY29udHJvbC5qc1xuICoqIG1vZHVsZSBpZCA9IDEwNFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeCwgX3gyLCBfeDMpIHsgdmFyIF9hZ2FpbiA9IHRydWU7IF9mdW5jdGlvbjogd2hpbGUgKF9hZ2FpbikgeyB2YXIgb2JqZWN0ID0gX3gsIHByb3BlcnR5ID0gX3gyLCByZWNlaXZlciA9IF94MzsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeCA9IHBhcmVudDsgX3gyID0gcHJvcGVydHk7IF94MyA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfc2xpZGVyID0gcmVxdWlyZSgnLi9zbGlkZXInKTtcblxudmFyIF9zbGlkZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfc2xpZGVyKTtcblxudmFyIFNpbXBsZVNsaWRlciA9IChmdW5jdGlvbiAoX1NsaWRlcikge1xuICBfaW5oZXJpdHMoU2ltcGxlU2xpZGVyLCBfU2xpZGVyKTtcblxuICBmdW5jdGlvbiBTaW1wbGVTbGlkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpbXBsZVNsaWRlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihTaW1wbGVTbGlkZXIucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTaW1wbGVTbGlkZXIsIFt7XG4gICAga2V5OiAnX3NldFgnLFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc2xpZGVyIHBvc2l0aW9uIHRvIHRoZSBnaXZlbiBYIHZhbHVlIGFuZCByZXNpemVzXG4gICAgICogdGhlIGZpbGwgZGl2XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFgoeCkge1xuICAgICAgdGhpcy5feFBvc2l0aW9uID0geDtcblxuICAgICAgdGhpcy5fZG90RWxlbWVudC5zdHlsZS5sZWZ0ID0geCArICdweCc7XG4gICAgICB0aGlzLl9maWxsRWxlbWVudC5zdHlsZS53aWR0aCA9IHggKyAncHgnO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAndGVtcGxhdGUnLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBhcnRpYWwgdGVtcGxhdGUgc3RyaW5nXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlclwiIGlkPVwiJysoKHR5cGVvZiBpdC5pZCA9PT0gXCJ1bmRlZmluZWRcIj8nJzppdC5pZCkpKydcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1taW51c1wiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9zbGlkZXIvbWludXMucG5nJykgKSsnXCIgLz4gPC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zbGlkZXItc2xpZGVyXCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zbGlkZXItY29udGVudFwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtc2xpZGVyLWJhY2tncm91bmRcIj48L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1maWxsXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1zbGlkZXItZG90XCI+PC9kaXY+IDwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LXNsaWRlci1wbHVzXCI+IDxpbWcgc3JjPVwiJysoaXQuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3NsaWRlci9wbHVzLnBuZycpICkrJ1wiIC8+IDwvZGl2PjwvZGl2Pic7cmV0dXJuIG91dDtcbn07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbXBsZVNsaWRlcjtcbn0pKF9zbGlkZXIyWydkZWZhdWx0J10pO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBTaW1wbGVTbGlkZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL3NpbXBsZS1zbGlkZXIuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJTaW1wbGVTbGlkZXIgPSByZXF1aXJlKCcuLi9saWIvc2ltcGxlLXNsaWRlcicpO1xuXG52YXIgX2xpYlNpbXBsZVNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJTaW1wbGVTbGlkZXIpO1xuXG52YXIgVGlsdFNoaWZ0Q29udHJvbCA9IChmdW5jdGlvbiAoX0NvbnRyb2wpIHtcbiAgX2luaGVyaXRzKFRpbHRTaGlmdENvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBUaWx0U2hpZnRDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUaWx0U2hpZnRDb250cm9sKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRpbHRTaGlmdENvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKFRpbHRTaGlmdENvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtaWNvblwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9ibHVyL2JsdXIucG5nJykpKydcIiAvPjwvZGl2PjxkaXY+ICc7dmFyIHNsaWRlcklkID0gXCJpbWdseWtpdC1ibHVyLXJhZGl1cy1zbGlkZXJcIjtvdXQrPScgJysoIGl0LnBhcnRpYWxzLnNsaWRlcikrJzwvZGl2PicrKCBpdC5wYXJ0aWFscy5kb25lQnV0dG9uKTtyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NvbnRyb2xzVGVtcGxhdGUgPSBjb250cm9sc1RlbXBsYXRlO1xuXG4gICAgICB2YXIgY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXRpbHQtc2hpZnQtY29udGFpbmVyXCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtdGlsdC1zaGlmdC1kb3RcIiBkYXRhLW9wdGlvbj1cInBvc2l0aW9uXCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtdGlsdC1zaGlmdC1kb3RcIiBkYXRhLW9wdGlvbj1cImdyYWRpZW50XCI+PC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtdGlsdC1zaGlmdC1yZWN0LWNvbnRhaW5lclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXRpbHQtc2hpZnQtcmVjdFwiPjwvZGl2PiA8L2Rpdj48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGNhbnZhc0NvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyID0gX2xpYlNpbXBsZVNsaWRlcjJbJ2RlZmF1bHQnXS50ZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyLmFkZGl0aW9uYWxDb250ZXh0ID0geyBpZDogJ2ltZ2x5a2l0LWJsdXItcmFkaXVzLXNsaWRlcicgfTtcbiAgICAgIHRoaXMuX2N1cnJlbnRLbm9iID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRW50ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zWyd0aWx0LXNoaWZ0J107XG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLl91aS5nZXRPckNyZWF0ZU9wZXJhdGlvbigndGlsdC1zaGlmdCcpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsU2V0dGluZ3MgPSB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLl9vcGVyYXRpb24uZ2V0U3RhcnQoKS5jbG9uZSgpLFxuICAgICAgICBlbmQ6IHRoaXMuX29wZXJhdGlvbi5nZXRFbmQoKS5jbG9uZSgpLFxuICAgICAgICBncmFkaWVudFJhZGl1czogdGhpcy5fb3BlcmF0aW9uLmdldEdyYWRpZW50UmFkaXVzKCksXG4gICAgICAgIGJsdXJSYWRpdXM6IHRoaXMuX29wZXJhdGlvbi5nZXRCbHVyUmFkaXVzKClcbiAgICAgIH07XG5cbiAgICAgIC8vIE1vdXNlIGV2ZW50IGNhbGxiYWNrcyBib3VuZCB0byB0aGUgY2xhc3MgY29udGV4dFxuICAgICAgdGhpcy5fb25Qb3NpdGlvbktub2JEb3duID0gdGhpcy5fb25Qb3NpdGlvbktub2JEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcgPSB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUG9zaXRpb25Lbm9iVXAgPSB0aGlzLl9vblBvc2l0aW9uS25vYlVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkdyYWRpZW50S25vYkRvd24gPSB0aGlzLl9vbkdyYWRpZW50S25vYkRvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZyA9IHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25HcmFkaWVudEtub2JVcCA9IHRoaXMuX29uR3JhZGllbnRLbm9iVXAuYmluZCh0aGlzKTtcblxuICAgICAgLy8gRmluZCBET00gZWxlbWVudHNcbiAgICAgIHZhciBzZWxlY3RvciA9ICcuaW1nbHlraXQtY2FudmFzLXRpbHQtc2hpZnQtZG90JztcbiAgICAgIHRoaXMuX3Bvc2l0aW9uS25vYiA9IHRoaXMuX2NhbnZhc0NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IgKyAnW2RhdGEtb3B0aW9uPVxcJ3Bvc2l0aW9uXFwnXScpO1xuICAgICAgdGhpcy5fZ3JhZGllbnRLbm9iID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcihzZWxlY3RvciArICdbZGF0YS1vcHRpb249XFwnZ3JhZGllbnRcXCddJyk7XG4gICAgICB0aGlzLl9yZWN0ID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNhbnZhcy10aWx0LXNoaWZ0LXJlY3QnKTtcblxuICAgICAgLy8gSW5pdGlhbGl6YXRpb25cbiAgICAgIHRoaXMuX2luaXRTbGlkZXJzKCk7XG5cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX2hhbmRsZUtub2JzKCk7XG4gICAgICAgIF90aGlzLl91cGRhdGVET00oKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzbGlkZXIgY29udHJvbHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRTbGlkZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRTbGlkZXJzKCkge1xuICAgICAgdmFyIGJsdXJSYWRpdXNTbGlkZXIgPSB0aGlzLl9jb250cm9scy5xdWVyeVNlbGVjdG9yKCcjaW1nbHlraXQtYmx1ci1yYWRpdXMtc2xpZGVyJyk7XG4gICAgICB0aGlzLl9ibHVyUmFkaXVzU2xpZGVyID0gbmV3IF9saWJTaW1wbGVTbGlkZXIyWydkZWZhdWx0J10oYmx1clJhZGl1c1NsaWRlciwge1xuICAgICAgICBtaW5WYWx1ZTogMCxcbiAgICAgICAgbWF4VmFsdWU6IDQwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2JsdXJSYWRpdXNTbGlkZXIub24oJ3VwZGF0ZScsIHRoaXMuX29uQmx1clJhZGl1c1VwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuX2JsdXJSYWRpdXNTbGlkZXIuc2V0VmFsdWUodGhpcy5faW5pdGlhbFNldHRpbmdzLmJsdXJSYWRpdXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBibHVyIHJhZGl1cyBzbGlkZXIgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CbHVyUmFkaXVzVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmx1clJhZGl1c1VwZGF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldEJsdXJSYWRpdXModmFsdWUpO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgICAgdGhpcy5faGlnaGxpZ2h0RG9uZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGtub2IgZHJhZ2dpbmdcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUtub2JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtub2JzKCkge1xuICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgdGhpcy5fcG9zaXRpb25Lbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uUG9zaXRpb25Lbm9iRG93bik7XG4gICAgICB0aGlzLl9wb3NpdGlvbktub2IuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uUG9zaXRpb25Lbm9iRG93bik7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2IuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25HcmFkaWVudEtub2JEb3duKTtcbiAgICAgIHRoaXMuX2dyYWRpZW50S25vYi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25HcmFkaWVudEtub2JEb3duKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcbiAgICAgIHZhciBfaW5pdGlhbFNldHRpbmdzID0gdGhpcy5faW5pdGlhbFNldHRpbmdzO1xuICAgICAgdmFyIHN0YXJ0ID0gX2luaXRpYWxTZXR0aW5ncy5zdGFydDtcbiAgICAgIHZhciBlbmQgPSBfaW5pdGlhbFNldHRpbmdzLmVuZDtcblxuICAgICAgc3RhcnQgPSBzdGFydC5jbG9uZSgpLm11bHRpcGx5KGNhbnZhc1NpemUpO1xuICAgICAgZW5kID0gZW5kLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHZhciBkaXN0ID0gZW5kLmNsb25lKCkuc3VidHJhY3Qoc3RhcnQpO1xuICAgICAgdmFyIG1pZGRsZSA9IHN0YXJ0LmNsb25lKCkuYWRkKGRpc3QuY2xvbmUoKS5kaXZpZGUoMikpO1xuXG4gICAgICB2YXIgdG90YWxEaXN0ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpc3QueCwgMikgKyBNYXRoLnBvdyhkaXN0LnksIDIpKTtcbiAgICAgIHZhciBmYWN0b3IgPSBkaXN0LmNsb25lKCkuZGl2aWRlKHRvdGFsRGlzdCkuZGl2aWRlKDIpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBrbm9iIHBvc2l0aW9uIChtaWRkbGUgb2Ygc3RhcnQgYW5kIGVuZClcbiAgICAgIHRoaXMuX2tub2JQb3NpdGlvbiA9IG1pZGRsZS5jbG9uZSgpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgaW5pdGlhbCBncmFkaWVudCBrbm9iIHBvc2l0aW9uXG4gICAgICB2YXIgZ3JhZGllbnRSYWRpdXMgPSB0aGlzLl9pbml0aWFsU2V0dGluZ3MuZ3JhZGllbnRSYWRpdXM7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbiA9IG1pZGRsZS5jbG9uZSgpLmFkZCgtZ3JhZGllbnRSYWRpdXMgKiBmYWN0b3IueSwgZ3JhZGllbnRSYWRpdXMgKiBmYWN0b3IueCk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXJ0QW5kRW5kKCk7XG4gICAgICB0aGlzLl91cGRhdGVET00oKTtcblxuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyB1c2luZyB0aGUga25vYiBwb3NpdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3VwZGF0ZVN0YXJ0QW5kRW5kJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVN0YXJ0QW5kRW5kKCkge1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGRpc3RhbmNlIGJldHdlZW4gZ3JhZGllbnQgYW5kIHBvc2l0aW9uIGtub2JcbiAgICAgIHZhciBkaWZmID0gdGhpcy5fZ3JhZGllbnRLbm9iUG9zaXRpb24uY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9rbm9iUG9zaXRpb24pO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLl9rbm9iUG9zaXRpb24uY2xvbmUoKS5hZGQoLWRpZmYueSwgZGlmZi54KS5kaXZpZGUoY2FudmFzU2l6ZSk7XG4gICAgICB2YXIgZW5kID0gdGhpcy5fa25vYlBvc2l0aW9uLmNsb25lKCkuYWRkKGRpZmYueSwgLWRpZmYueCkuZGl2aWRlKGNhbnZhc1NpemUpO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgcG9zaXRpb24ga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uUG9zaXRpb25Lbm9iRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBvc2l0aW9uS25vYkRvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5faW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fa25vYlBvc2l0aW9uLmNsb25lKCk7XG4gICAgICB0aGlzLl9pbml0aWFsRGlzdGFuY2VUb0dyYWRpZW50S25vYiA9IHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbFBvc2l0aW9uKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Qb3NpdGlvbktub2JEcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uUG9zaXRpb25Lbm9iRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblBvc2l0aW9uS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Qb3NpdGlvbktub2JVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgcG9zaXRpb24ga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uUG9zaXRpb25Lbm9iRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblBvc2l0aW9uS25vYkRyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHZhciBkaWZmID0gbW91c2VQb3NpdGlvbi5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbik7XG5cbiAgICAgIHZhciBuZXdQb3NpdGlvbiA9IHRoaXMuX2luaXRpYWxQb3NpdGlvbi5jbG9uZSgpLmFkZChkaWZmKTtcbiAgICAgIHRoaXMuX2tub2JQb3NpdGlvbi5jb3B5KG5ld1Bvc2l0aW9uKTtcblxuICAgICAgdmFyIG1pblBvc2l0aW9uID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgpLnN1YnRyYWN0KHRoaXMuX2luaXRpYWxEaXN0YW5jZVRvR3JhZGllbnRLbm9iKTtcbiAgICAgIG1pblBvc2l0aW9uLmNsYW1wKG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMCwgMCkpO1xuXG4gICAgICB2YXIgbWF4UG9zaXRpb24gPSBjYW52YXNTaXplLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbERpc3RhbmNlVG9HcmFkaWVudEtub2IpO1xuICAgICAgbWF4UG9zaXRpb24uY2xhbXAobnVsbCwgY2FudmFzU2l6ZSk7XG5cbiAgICAgIHRoaXMuX2tub2JQb3NpdGlvbi5jbGFtcChtaW5Qb3NpdGlvbiwgbWF4UG9zaXRpb24pO1xuXG4gICAgICB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbi5jb3B5KHRoaXMuX2tub2JQb3NpdGlvbikuYWRkKHRoaXMuX2luaXRpYWxEaXN0YW5jZVRvR3JhZGllbnRLbm9iKTtcblxuICAgICAgdGhpcy5fdXBkYXRlU3RhcnRBbmRFbmQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZURPTSgpO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIHBvc2l0aW9uIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblBvc2l0aW9uS25vYlVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUG9zaXRpb25Lbm9iVXAoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vblBvc2l0aW9uS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Qb3NpdGlvbktub2JEcmFnKTtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUG9zaXRpb25Lbm9iVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblBvc2l0aW9uS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0YXJ0cyBkcmFnZ2luZyB0aGUgZ3JhZGllbnQga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uR3JhZGllbnRLbm9iRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdyYWRpZW50S25vYkRvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5faW5pdGlhbEdyYWRpZW50S25vYlBvc2l0aW9uID0gdGhpcy5fZ3JhZGllbnRLbm9iUG9zaXRpb24uY2xvbmUoKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25HcmFkaWVudEtub2JEcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkdyYWRpZW50S25vYlVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25HcmFkaWVudEtub2JVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgZ3JhZGllbnQga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uR3JhZGllbnRLbm9iRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdyYWRpZW50S25vYkRyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHZhciBkaWZmID0gbW91c2VQb3NpdGlvbi5zdWJ0cmFjdCh0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbik7XG5cbiAgICAgIHRoaXMuX2dyYWRpZW50S25vYlBvc2l0aW9uLmNvcHkodGhpcy5faW5pdGlhbEdyYWRpZW50S25vYlBvc2l0aW9uKS5hZGQoZGlmZik7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2JQb3NpdGlvbi5jbGFtcChuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKDAsIDApLCBjYW52YXNTaXplKTtcblxuICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5fZ3JhZGllbnRLbm9iUG9zaXRpb24uY2xvbmUoKS5zdWJ0cmFjdCh0aGlzLl9rbm9iUG9zaXRpb24pO1xuICAgICAgdmFyIG5ld0dyYWRpZW50UmFkaXVzID0gMiAqIE1hdGguc3FydChNYXRoLnBvdyhkaXN0YW5jZS54LCAyKSArIE1hdGgucG93KGRpc3RhbmNlLnksIDIpKTtcblxuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldEdyYWRpZW50UmFkaXVzKG5ld0dyYWRpZW50UmFkaXVzKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVN0YXJ0QW5kRW5kKCk7XG4gICAgICB0aGlzLl91cGRhdGVET00oKTtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBncmFkaWVudCBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25HcmFkaWVudEtub2JVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkdyYWRpZW50S25vYlVwKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25HcmFkaWVudEtub2JEcmFnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uR3JhZGllbnRLbm9iRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkdyYWRpZW50S25vYlVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25HcmFkaWVudEtub2JVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUga25vYlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlRE9NJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZURPTSgpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX2tub2JQb3NpdGlvbjtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uS25vYi5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9wb3NpdGlvbktub2Iuc3R5bGUudG9wID0gcG9zaXRpb24ueSArICdweCc7XG5cbiAgICAgIHZhciBncmFkaWVudFBvc2l0aW9uID0gdGhpcy5fZ3JhZGllbnRLbm9iUG9zaXRpb247XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2Iuc3R5bGUubGVmdCA9IGdyYWRpZW50UG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9ncmFkaWVudEtub2Iuc3R5bGUudG9wID0gZ3JhZGllbnRQb3NpdGlvbi55ICsgJ3B4JztcblxuICAgICAgLy8gUmVzaXplIHJlY3RhbmdsZSB0byB3b3JzdCBjYXNlIHNpemVcbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG4gICAgICB2YXIgZ3JhZGllbnRSYWRpdXMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0R3JhZGllbnRSYWRpdXMoKTtcbiAgICAgIHZhciByZWN0U2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oTWF0aC5zcXJ0KE1hdGgucG93KGNhbnZhc1NpemUueCwgMikgKyBNYXRoLnBvdyhjYW52YXNTaXplLnksIDIpKSAqIDIsIGdyYWRpZW50UmFkaXVzKTtcblxuICAgICAgdGhpcy5fcmVjdC5zdHlsZS53aWR0aCA9IHJlY3RTaXplLnggKyAncHgnO1xuICAgICAgdGhpcy5fcmVjdC5zdHlsZS5oZWlnaHQgPSByZWN0U2l6ZS55ICsgJ3B4JztcbiAgICAgIHRoaXMuX3JlY3Quc3R5bGUubWFyZ2luTGVmdCA9ICctJyArIHJlY3RTaXplLnggLyAyICsgJ3B4JztcbiAgICAgIHRoaXMuX3JlY3Quc3R5bGUubWFyZ2luVG9wID0gJy0nICsgcmVjdFNpemUueSAvIDIgKyAncHgnO1xuICAgICAgdGhpcy5fcmVjdC5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9yZWN0LnN0eWxlLnRvcCA9IHBvc2l0aW9uLnkgKyAncHgnO1xuXG4gICAgICAvLyBSb3RhdGUgcmVjdGFuZ2xlXG4gICAgICB2YXIgZGlzdCA9IGdyYWRpZW50UG9zaXRpb24uY2xvbmUoKS5zdWJ0cmFjdChwb3NpdGlvbik7XG4gICAgICB2YXIgZGVncmVlcyA9IE1hdGguYXRhbjIoZGlzdC54LCBkaXN0LnkpICogKDE4MCAvIE1hdGguUEkpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9ICdyb3RhdGUoJyArICgtZGVncmVlcykudG9GaXhlZCgyKSArICdkZWcpJztcbiAgICAgIHRoaXMuX3JlY3Quc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgdGhpcy5fcmVjdC5zdHlsZVsnLW1vei10cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX3JlY3Quc3R5bGVbJy1tcy10cmFuc2Zvcm0nXSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMuX3JlY3Quc3R5bGVbJy13ZWJraXQtdHJhbnNmb3JtJ10gPSB0cmFuc2Zvcm07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgYmFjayBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQmFjaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2soKSB7XG4gICAgICBpZiAodGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZSkge1xuICAgICAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHRoaXMuX2luaXRpYWxTZXR0aW5ncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ3RpbHQtc2hpZnQnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBkb25lIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Eb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9uZSgpIHtcbiAgICAgIHRoaXMuX3VpLmFkZEhpc3RvcnkodGhpcy5fb3BlcmF0aW9uLCB7XG4gICAgICAgIHN0YXJ0OiB0aGlzLl9pbml0aWFsU2V0dGluZ3Muc3RhcnQuY2xvbmUoKSxcbiAgICAgICAgZW5kOiB0aGlzLl9pbml0aWFsU2V0dGluZ3MuZW5kLmNsb25lKCksXG4gICAgICAgIGJsdXJSYWRpdXM6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5ibHVyUmFkaXVzLFxuICAgICAgICBncmFkaWVudFJhZGl1czogdGhpcy5faW5pdGlhbFNldHRpbmdzLmdyYWRpZW50UmFkaXVzXG4gICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGlsdFNoaWZ0Q29udHJvbDtcbn0pKF9jb250cm9sMlsnZGVmYXVsdCddKTtcblxuVGlsdFNoaWZ0Q29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9ICd0aWx0LXNoaWZ0JztcblxuZXhwb3J0c1snZGVmYXVsdCddID0gVGlsdFNoaWZ0Q29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy90aWx0LXNoaWZ0LWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYlNpbXBsZVNsaWRlciA9IHJlcXVpcmUoJy4uL2xpYi9zaW1wbGUtc2xpZGVyJyk7XG5cbnZhciBfbGliU2ltcGxlU2xpZGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlNpbXBsZVNsaWRlcik7XG5cbnZhciBfbGliQ29sb3JQaWNrZXIgPSByZXF1aXJlKCcuLi9saWIvY29sb3ItcGlja2VyJyk7XG5cbnZhciBfbGliQ29sb3JQaWNrZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliQ29sb3JQaWNrZXIpO1xuXG52YXIgRnJhbWVzQ29udHJvbCA9IChmdW5jdGlvbiAoX0NvbnRyb2wpIHtcbiAgX2luaGVyaXRzKEZyYW1lc0NvbnRyb2wsIF9Db250cm9sKTtcblxuICBmdW5jdGlvbiBGcmFtZXNDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGcmFtZXNDb250cm9sKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEZyYW1lc0NvbnRyb2wucHJvdG90eXBlKSwgJ2NvbnN0cnVjdG9yJywgdGhpcykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHVuaXF1ZSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIHRoaXMgY29udHJvbC5cbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG5cbiAgX2NyZWF0ZUNsYXNzKEZyYW1lc0NvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2PiAnKyggaXQucGFydGlhbHMuc2xpZGVyKSsnPC9kaXY+PGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWJ1dHRvblwiPiAnKyggaXQucGFydGlhbHMuY29sb3JQaWNrZXIpKyc8L2Rpdj4nKyggaXQucGFydGlhbHMuZG9uZUJ1dHRvbik7cmV0dXJuIG91dDtcbn07XG4gICAgICB0aGlzLl9jb250cm9sc1RlbXBsYXRlID0gY29udHJvbHNUZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuc2xpZGVyID0gX2xpYlNpbXBsZVNsaWRlcjJbJ2RlZmF1bHQnXS50ZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuY29sb3JQaWNrZXIgPSBfbGliQ29sb3JQaWNrZXIyWydkZWZhdWx0J10udGVtcGxhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNvbnRyb2xzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNvbnRyb2xzKCkge1xuICAgICAgdGhpcy5fcGFydGlhbFRlbXBsYXRlcy5jb2xvclBpY2tlci5hZGRpdGlvbmFsQ29udGV4dCA9IHsgbGFiZWw6IHRoaXMuX3VpLnRyYW5zbGF0ZSgnY29udHJvbHMuZnJhbWVzLmNvbG9yJykgfTtcblxuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoRnJhbWVzQ29udHJvbC5wcm90b3R5cGUpLCAnX3JlbmRlckNvbnRyb2xzJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRW50ZXIoKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLmZyYW1lcztcbiAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdmcmFtZXMnKTtcblxuICAgICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSB7XG4gICAgICAgIHRoaWNrbmVzczogdGhpcy5fb3BlcmF0aW9uLmdldFRoaWNrbmVzcygpLFxuICAgICAgICBjb2xvcjogdGhpcy5fb3BlcmF0aW9uLmdldENvbG9yKClcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5yZW5kZXIoKTtcblxuICAgICAgLy8gSW5pdCBzbGlkZXJcbiAgICAgIHZhciBzbGlkZXJFbGVtZW50ID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNsaWRlcicpO1xuICAgICAgdGhpcy5fc2xpZGVyID0gbmV3IF9saWJTaW1wbGVTbGlkZXIyWydkZWZhdWx0J10oc2xpZGVyRWxlbWVudCwge1xuICAgICAgICBtaW5WYWx1ZTogMC4wLFxuICAgICAgICBtYXhWYWx1ZTogMC41XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NsaWRlci5vbigndXBkYXRlJywgdGhpcy5fb25UaGlja25lc3NVcGRhdGUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLl9zbGlkZXIuc2V0VmFsdWUodGhpcy5faW5pdGlhbE9wdGlvbnMudGhpY2tuZXNzKTtcblxuICAgICAgLy8gSW5pdCBjb2xvcnBpY2tlclxuICAgICAgdmFyIGNvbG9yUGlja2VyRWxlbWVudCA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb2xvci1waWNrZXInKTtcbiAgICAgIHRoaXMuX2NvbG9yUGlja2VyID0gbmV3IF9saWJDb2xvclBpY2tlcjJbJ2RlZmF1bHQnXSh0aGlzLl91aSwgY29sb3JQaWNrZXJFbGVtZW50KTtcbiAgICAgIHRoaXMuX2NvbG9yUGlja2VyLm9uKCd1cGRhdGUnLCB0aGlzLl9vbkNvbG9yVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fY29sb3JQaWNrZXIuc2V0VmFsdWUodGhpcy5faW5pdGlhbE9wdGlvbnMuY29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrKCkge1xuICAgICAgaWYgKHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUpIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldCh0aGlzLl9pbml0aWFsT3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ2ZyYW1lcycpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHRoaWNrbmVzcyBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25UaGlja25lc3NVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UaGlja25lc3NVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXRUaGlja25lc3ModmFsdWUpO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuICAgICAgdGhpcy5faGlnaGxpZ2h0RG9uZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkNvbG9yVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29sb3JVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXRDb2xvcih2YWx1ZSk7XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG4gICAgICB0aGlzLl9oaWdobGlnaHREb25lQnV0dG9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZG9uZSBidXR0b24gaGFzIGJlZW4gY2xpY2tlZFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRG9uZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoKSB7XG4gICAgICB0aGlzLl91aS5hZGRIaXN0b3J5KHRoaXMuX29wZXJhdGlvbiwge1xuICAgICAgICBjb2xvcjogdGhpcy5faW5pdGlhbE9wdGlvbnMuY29sb3IsXG4gICAgICAgIHRoaWNrbmVzczogdGhpcy5faW5pdGlhbE9wdGlvbnMudGhpY2tuZXNzXG4gICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRnJhbWVzQ29udHJvbDtcbn0pKF9jb250cm9sMlsnZGVmYXVsdCddKTtcblxuRnJhbWVzQ29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdmcmFtZXMnO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBGcmFtZXNDb250cm9sO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2NvbnRyb2xzL2ZyYW1lcy1jb250cm9sLmpzXG4gKiogbW9kdWxlIGlkID0gMTA3XG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCIvKiBnbG9iYWwgX19ET1RKU19URU1QTEFURSwgSW1hZ2UgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3NsaWNlZFRvQXJyYXkgPSAoZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVsncmV0dXJuJ10pIF9pWydyZXR1cm4nXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH0gcmV0dXJuIGZ1bmN0aW9uIChhcnIsIGkpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyByZXR1cm4gYXJyOyB9IGVsc2UgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkgeyByZXR1cm4gc2xpY2VJdGVyYXRvcihhcnIsIGkpOyB9IGVsc2UgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlJyk7IH0gfTsgfSkoKTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2xpYkV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9ldmVudC1lbWl0dGVyJyk7XG5cbnZhciBfbGliRXZlbnRFbWl0dGVyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkV2ZW50RW1pdHRlcik7XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBfbGliQ29sb3IgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvY29sb3InKTtcblxudmFyIF9saWJDb2xvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJDb2xvcik7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgQ29sb3JQaWNrZXIgPSAoZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgX2luaGVyaXRzKENvbG9yUGlja2VyLCBfRXZlbnRFbWl0dGVyKTtcblxuICBmdW5jdGlvbiBDb2xvclBpY2tlcih1aSwgZWxlbWVudCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb2xvclBpY2tlcik7XG5cbiAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihDb2xvclBpY2tlci5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fdWkgPSB1aTtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl92aXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy5fbG9hZGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLl9vdmVybGF5ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY29sb3ItcGlja2VyLW92ZXJsYXknKTtcbiAgICB0aGlzLl9jdXJyZW50Q29sb3JDYW52YXMgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb2xvci1waWNrZXItY29sb3InKTtcblxuICAgIHRoaXMuX2FscGhhQ2FudmFzID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuaW1nbHlraXQtY29sb3ItcGlja2VyLWFscGhhJyk7XG4gICAgdGhpcy5fYWxwaGFLbm9iID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY29sb3ItcGlja2VyLWFscGhhLWNvbnRhaW5lciAuaW1nbHlraXQtdHJhbnNwYXJlbnQta25vYicpO1xuXG4gICAgdGhpcy5faHVlQ2FudmFzID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdjYW52YXMuaW1nbHlraXQtY29sb3ItcGlja2VyLWh1ZScpO1xuICAgIHRoaXMuX2h1ZUtub2IgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb2xvci1waWNrZXItaHVlLWNvbnRhaW5lciAuaW1nbHlraXQtdHJhbnNwYXJlbnQta25vYicpO1xuXG4gICAgdGhpcy5fc2F0dXJhdGlvbkNhbnZhcyA9IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcignY2FudmFzLmltZ2x5a2l0LWNvbG9yLXBpY2tlci1zYXR1cmF0aW9uJyk7XG4gICAgdGhpcy5fc2F0dXJhdGlvbktub2IgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb2xvci1waWNrZXItc2F0dXJhdGlvbi1jb250YWluZXIgLmltZ2x5a2l0LXRyYW5zcGFyZW50LWtub2InKTtcblxuICAgIHRoaXMuX3RyYW5zcGFyZW5jeUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgdGhpcy5fdHJhbnNwYXJlbmN5SW1hZ2Uuc3JjID0gdWkuaGVscGVycy5hc3NldFBhdGgoJ3VpL25pZ2h0L3RyYW5zcGFyZW5jeS5wbmcnKTtcbiAgICB0aGlzLl90cmFuc3BhcmVuY3lJbWFnZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fb25UcmFuc3BhcmVuY3lJbWFnZUxvYWQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLl9vbkFscGhhQ2FudmFzRG93biA9IHRoaXMuX29uQWxwaGFDYW52YXNEb3duLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25BbHBoYUNhbnZhc0RyYWcgPSB0aGlzLl9vbkFscGhhQ2FudmFzRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uQWxwaGFDYW52YXNVcCA9IHRoaXMuX29uQWxwaGFDYW52YXNVcC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSHVlQ2FudmFzRG93biA9IHRoaXMuX29uSHVlQ2FudmFzRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSHVlQ2FudmFzRHJhZyA9IHRoaXMuX29uSHVlQ2FudmFzRHJhZy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uSHVlQ2FudmFzVXAgPSB0aGlzLl9vbkh1ZUNhbnZhc1VwLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNEb3duID0gdGhpcy5fb25TYXR1cmF0aW9uQ2FudmFzRG93bi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc0RyYWcgPSB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNEcmFnLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fb25TYXR1cmF0aW9uQ2FudmFzVXAgPSB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNVcC5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5fb25FbGVtZW50Q2xpY2sgPSB0aGlzLl9vbkVsZW1lbnRDbGljay5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5faGFuZGxlVG9nZ2xlKCk7XG4gICAgdGhpcy5faGFuZGxlQWxwaGFLbm9iKCk7XG4gICAgdGhpcy5faGFuZGxlSHVlS25vYigpO1xuICAgIHRoaXMuX2hhbmRsZVNhdHVyYXRpb25Lbm9iKCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ29sb3JQaWNrZXIsIFt7XG4gICAga2V5OiAnX29uVHJhbnNwYXJlbmN5SW1hZ2VMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVHJhbnNwYXJlbmN5SW1hZ2VMb2FkKCkge1xuICAgICAgdGhpcy5fbG9hZGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlbmRlcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBwYXJ0aWFsIHRlbXBsYXRlIHN0cmluZ1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlVG9nZ2xlJyxcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHRvZ2dsaW5nIG9mIHRoZSBvdmVybGF5XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVRvZ2dsZSgpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9vbkVsZW1lbnRDbGljayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgZWxlbWVudCBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbGVtZW50Q2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FbGVtZW50Q2xpY2soZSkge1xuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLl9lbGVtZW50IHx8IGUudGFyZ2V0ID09PSB0aGlzLl9jdXJyZW50Q29sb3JDYW52YXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Zpc2libGUpIHtcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2hpZGUnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICB0aGlzLmVtaXQoJ3Nob3cnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBjb2xvciBwaWNrZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ2hpZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdCh0aGlzLl9vdmVybGF5KS5yZW1vdmUoJ2ltZ2x5a2l0LXZpc2libGUnKTtcbiAgICAgIHRoaXMuX3Zpc2libGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgY29sb3IgcGlja2VyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdzaG93JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QodGhpcy5fb3ZlcmxheSkuYWRkKCdpbWdseWtpdC12aXNpYmxlJyk7XG4gICAgICB0aGlzLl92aXNpYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBnaXZlbiB2YWx1ZVxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnc2V0VmFsdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXG4gICAgICB2YXIgX3ZhbHVlJHRvSFNWID0gdGhpcy5fdmFsdWUudG9IU1YoKTtcblxuICAgICAgdmFyIF92YWx1ZSR0b0hTVjIgPSBfc2xpY2VkVG9BcnJheShfdmFsdWUkdG9IU1YsIDMpO1xuXG4gICAgICB2YXIgaCA9IF92YWx1ZSR0b0hTVjJbMF07XG4gICAgICB2YXIgcyA9IF92YWx1ZSR0b0hTVjJbMV07XG4gICAgICB2YXIgdiA9IF92YWx1ZSR0b0hTVjJbMl07XG5cbiAgICAgIHRoaXMuX2hzdkNvbG9yID0geyBoOiBoLCBzOiBzLCB2OiB2IH07XG4gICAgICB0aGlzLl9wb3NpdGlvbktub2JzKCk7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBrbm9iIHBvc2l0aW9ucyB0byByZXByZXNlbnQgdGhlIGN1cnJlbnQgSFNWIGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19wb3NpdGlvbktub2JzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uS25vYnMoKSB7XG4gICAgICB0aGlzLl9wb3NpdGlvbkFscGhhS25vYigpO1xuICAgICAgdGhpcy5fcG9zaXRpb25IdWVLbm9iKCk7XG4gICAgICB0aGlzLl9wb3NpdGlvblNhdHVyYXRpb25Lbm9iKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb25zIHRoZSBhbHBoYSBrbm9iIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBhbHBoYSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcG9zaXRpb25BbHBoYUtub2InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcG9zaXRpb25BbHBoYUtub2IoKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fYWxwaGFDYW52YXM7XG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgdmFyIGxlZnQgPSB0aGlzLl92YWx1ZS5hICogY2FudmFzU2l6ZS54O1xuICAgICAgdGhpcy5fYWxwaGFLbm9iLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbnMgdGhlIGh1ZSBrbm9iIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBodWUgdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3Bvc2l0aW9uSHVlS25vYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3NpdGlvbkh1ZUtub2IoKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5faHVlQ2FudmFzO1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHZhciB0b3AgPSB0aGlzLl9oc3ZDb2xvci5oICogY2FudmFzU2l6ZS55O1xuICAgICAgdGhpcy5faHVlS25vYi5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9ucyB0aGUgc2F0dXJhdGlvbiBrbm9iIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzYXR1cmF0aW9uIHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19wb3NpdGlvblNhdHVyYXRpb25Lbm9iJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc2l0aW9uU2F0dXJhdGlvbktub2IoKSB7XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fc2F0dXJhdGlvbkNhbnZhcztcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICB2YXIgbGVmdCA9IHRoaXMuX2hzdkNvbG9yLnMgKiBjYW52YXNTaXplLng7XG4gICAgICB0aGlzLl9zYXR1cmF0aW9uS25vYi5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgICB2YXIgdG9wID0gKDEgLSB0aGlzLl9oc3ZDb2xvci52KSAqIGNhbnZhc1NpemUueTtcbiAgICAgIHRoaXMuX3NhdHVyYXRpb25Lbm9iLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyBhbmQgcmVuZGVycyBhbGwgY29udHJvbHMgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHZhbHVlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2FkZWQpIHJldHVybjtcbiAgICAgIHRoaXMuX3JlbmRlckN1cnJlbnRDb2xvcigpO1xuICAgICAgdGhpcy5fcmVuZGVyQWxwaGEoKTtcbiAgICAgIHRoaXMuX3JlbmRlckh1ZSgpO1xuICAgICAgdGhpcy5fcmVuZGVyU2F0dXJhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjb2xvciBvbiB0aGUgY29udHJvbHMgY2FudmFzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJDdXJyZW50Q29sb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ3VycmVudENvbG9yKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2N1cnJlbnRDb2xvckNhbnZhcztcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKHRoaXMuX3RyYW5zcGFyZW5jeUltYWdlLCAncmVwZWF0Jyk7XG4gICAgICBjb250ZXh0LnJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuX3ZhbHVlLnRvUkdCQSgpO1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgdHJhbnNwYXJlbmN5IGNhbnZhcyB3aXRoIHRoZSBjdXJyZW50IGNvbG9yXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJBbHBoYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJBbHBoYSgpIHtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9hbHBoYUNhbnZhcztcbiAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgIHZhciBwYXR0ZXJuID0gY29udGV4dC5jcmVhdGVQYXR0ZXJuKHRoaXMuX3RyYW5zcGFyZW5jeUltYWdlLCAncmVwZWF0Jyk7XG4gICAgICBjb250ZXh0LnJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIGNvbnRleHQuZmlsbCgpO1xuXG4gICAgICB2YXIgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG5cbiAgICAgIHZhciBjb2xvciA9IHRoaXMuX3ZhbHVlLmNsb25lKCk7XG4gICAgICBjb2xvci5hID0gMDtcbiAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCBjb2xvci50b1JHQkEoKSk7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgdGhpcy5fdmFsdWUudG9IZXgoKSk7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGdyYWRpZW50O1xuICAgICAgY29udGV4dC5maWxsKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgaHVlIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVySHVlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckh1ZSgpIHtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9odWVDYW52YXM7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICB2YXIgY29sb3IgPSBuZXcgX2xpYkNvbG9yMlsnZGVmYXVsdCddKCk7XG4gICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGNhbnZhcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICB2YXIgcmF0aW8gPSB5IC8gY2FudmFzLmhlaWdodDtcbiAgICAgICAgY29sb3IuZnJvbUhTVihyYXRpbywgMSwgMSk7XG5cbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvUkdCQSgpO1xuICAgICAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb250ZXh0Lm1vdmVUbygwLCB5KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oY2FudmFzLndpZHRoLCB5KTtcbiAgICAgICAgY29udGV4dC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSBzYXR1cmF0aW9uIGNhbnZhc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyU2F0dXJhdGlvbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJTYXR1cmF0aW9uKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX3NhdHVyYXRpb25DYW52YXM7XG4gICAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICB2YXIgaW1hZ2VEYXRhID0gY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgdmFyIGNvbG9yID0gbmV3IF9saWJDb2xvcjJbJ2RlZmF1bHQnXSgxLCAwLCAwLCAxKTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgY2FudmFzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IChjYW52YXMuaGVpZ2h0IC0geSkgLyBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGNhbnZhcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgdmFyIHNhdHVyYXRpb24gPSB4IC8gY2FudmFzLndpZHRoO1xuICAgICAgICAgIGNvbG9yLmZyb21IU1YodGhpcy5faHN2Q29sb3IuaCwgc2F0dXJhdGlvbiwgdmFsdWUpO1xuICAgICAgICAgIHZhciByID0gY29sb3IucjtcbiAgICAgICAgICB2YXIgZyA9IGNvbG9yLmc7XG4gICAgICAgICAgdmFyIGIgPSBjb2xvci5iO1xuICAgICAgICAgIHZhciBhID0gY29sb3IuYTtcblxuICAgICAgICAgIHZhciBpbmRleCA9ICh5ICogY2FudmFzLndpZHRoICsgeCkgKiA0O1xuXG4gICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbaW5kZXhdID0gciAqIDI1NTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDFdID0gZyAqIDI1NTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDJdID0gYiAqIDI1NTtcbiAgICAgICAgICBpbWFnZURhdGEuZGF0YVtpbmRleCArIDNdID0gYSAqIDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWdnaW5nIG9mIHRoZSBhbHBoYSBrbm9iXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVBbHBoYUtub2InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlQWxwaGFLbm9iKCkge1xuICAgICAgdGhpcy5fYWxwaGFDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fb25BbHBoYUNhbnZhc0Rvd24pO1xuICAgICAgdGhpcy5fYWxwaGFDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uQWxwaGFDYW52YXNEb3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgYWxwaGEga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQWxwaGFDYW52YXNEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQWxwaGFDYW52YXNEb3duKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdGhpcy5fb25BbHBoYUNhbnZhc0RyYWcoZSk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uQWxwaGFDYW52YXNEcmFnKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uQWxwaGFDYW52YXNEcmFnKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uQWxwaGFDYW52YXNVcCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uQWxwaGFDYW52YXNVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBkcmFncyB0aGUgYWxwaGEga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uQWxwaGFDYW52YXNEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQWxwaGFDYW52YXNEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHJlbGF0aXZlIG1vdXNlIHBvc2l0aW9uIG9uIGNhbnZhc1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX2FscGhhQ2FudmFzO1xuICAgICAgdmFyIGNhbnZhc1NpemUgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuXG4gICAgICB2YXIgX2NhbnZhcyRnZXRCb3VuZGluZ0NsaWVudFJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgIHZhciBsZWZ0ID0gX2NhbnZhcyRnZXRCb3VuZGluZ0NsaWVudFJlY3QubGVmdDtcbiAgICAgIHZhciB0b3AgPSBfY2FudmFzJGdldEJvdW5kaW5nQ2xpZW50UmVjdC50b3A7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGxlZnQsIHRvcCk7XG4gICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3Qob2Zmc2V0KTtcbiAgICAgIHJlbGF0aXZlUG9zaXRpb24uY2xhbXAobmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLCAwKSwgY2FudmFzU2l6ZSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBrbm9iIGNzcyBwb3NpdGlvbmluZ1xuICAgICAgdGhpcy5fYWxwaGFLbm9iLnN0eWxlLmxlZnQgPSByZWxhdGl2ZVBvc2l0aW9uLnggKyAncHgnO1xuXG4gICAgICAvLyBVcGRhdGUgYWxwaGEgdmFsdWVcbiAgICAgIHRoaXMuX3ZhbHVlLmEgPSByZWxhdGl2ZVBvc2l0aW9uLnggLyBjYW52YXNTaXplLng7XG4gICAgICB0aGlzLl91cGRhdGVDb2xvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RvcHMgZHJhZ2dpbmcgdGhlIGFscGhhIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkFscGhhQ2FudmFzVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25BbHBoYUNhbnZhc1VwKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25BbHBoYUNhbnZhc0RyYWcpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25BbHBoYUNhbnZhc0RyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25BbHBoYUNhbnZhc1VwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25BbHBoYUNhbnZhc1VwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBkcmFnZ2luZyBvZiB0aGUgaHVlIGtub2JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUh1ZUtub2InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlSHVlS25vYigpIHtcbiAgICAgIHRoaXMuX2h1ZUNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkh1ZUNhbnZhc0Rvd24pO1xuICAgICAgdGhpcy5faHVlQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbkh1ZUNhbnZhc0Rvd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBjYW52YXMga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uSHVlQ2FudmFzRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkh1ZUNhbnZhc0Rvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9vbkh1ZUNhbnZhc0RyYWcoZSk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uSHVlQ2FudmFzRHJhZyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkh1ZUNhbnZhc0RyYWcpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25IdWVDYW52YXNVcCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uSHVlQ2FudmFzVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGh1ZSBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25IdWVDYW52YXNEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uSHVlQ2FudmFzRHJhZyhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9odWVDYW52YXM7XG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIHJlbGF0aXZlIG1vdXNlIHBvc2l0aW9uIG9uIGNhbnZhc1xuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcblxuICAgICAgdmFyIF9jYW52YXMkZ2V0Qm91bmRpbmdDbGllbnRSZWN0MiA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgdmFyIGxlZnQgPSBfY2FudmFzJGdldEJvdW5kaW5nQ2xpZW50UmVjdDIubGVmdDtcbiAgICAgIHZhciB0b3AgPSBfY2FudmFzJGdldEJvdW5kaW5nQ2xpZW50UmVjdDIudG9wO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShsZWZ0LCB0b3ApO1xuICAgICAgdmFyIHJlbGF0aXZlUG9zaXRpb24gPSBtb3VzZVBvc2l0aW9uLnN1YnRyYWN0KG9mZnNldCk7XG4gICAgICByZWxhdGl2ZVBvc2l0aW9uLmNsYW1wKG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMCwgMCksIGNhbnZhc1NpemUpO1xuXG4gICAgICAvLyBVcGRhdGUgc2F0dXJhaXRvbiBrbm9iIGNzcyBwb3NpdGlvbmluZ1xuICAgICAgdGhpcy5faHVlS25vYi5zdHlsZS50b3AgPSByZWxhdGl2ZVBvc2l0aW9uLnkgKyAncHgnO1xuXG4gICAgICAvLyBVcGRhdGUgc2F0dXJhdGlvbiBhbmQgdmFsdWVcbiAgICAgIHJlbGF0aXZlUG9zaXRpb24uZGl2aWRlKGNhbnZhc1NpemUpO1xuICAgICAgdGhpcy5faHN2Q29sb3IuaCA9IHJlbGF0aXZlUG9zaXRpb24ueTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgYWxwaGEga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uSHVlQ2FudmFzVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25IdWVDYW52YXNVcCgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uSHVlQ2FudmFzRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkh1ZUNhbnZhc0RyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25IdWVDYW52YXNVcCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uSHVlQ2FudmFzVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGRyYWdnaW5nIG9mIHRoZSBzYXR1cmF0aW9uIGtub2JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZVNhdHVyYXRpb25Lbm9iJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVNhdHVyYXRpb25Lbm9iKCkge1xuICAgICAgdGhpcy5fc2F0dXJhdGlvbkNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNEb3duKTtcbiAgICAgIHRoaXMuX3NhdHVyYXRpb25DYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc0Rvd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSBzYXR1cmF0aW9uIGNhbnZhc1xuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uU2F0dXJhdGlvbkNhbnZhc0Rvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25TYXR1cmF0aW9uQ2FudmFzRG93bihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc0RyYWcoZSk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc0RyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25TYXR1cmF0aW9uQ2FudmFzRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNVcCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc1VwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBzYXR1cmF0aW9uIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblNhdHVyYXRpb25DYW52YXNEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uU2F0dXJhdGlvbkNhbnZhc0RyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fc2F0dXJhdGlvbkNhbnZhcztcbiAgICAgIHZhciBjYW52YXNTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgcmVsYXRpdmUgbW91c2UgcG9zaXRpb24gb24gY2FudmFzXG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuXG4gICAgICB2YXIgX2NhbnZhcyRnZXRCb3VuZGluZ0NsaWVudFJlY3QzID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICB2YXIgbGVmdCA9IF9jYW52YXMkZ2V0Qm91bmRpbmdDbGllbnRSZWN0My5sZWZ0O1xuICAgICAgdmFyIHRvcCA9IF9jYW52YXMkZ2V0Qm91bmRpbmdDbGllbnRSZWN0My50b3A7XG5cbiAgICAgIHZhciBvZmZzZXQgPSBuZXcgX2xpYk1hdGhWZWN0b3IyMlsnZGVmYXVsdCddKGxlZnQsIHRvcCk7XG4gICAgICB2YXIgcmVsYXRpdmVQb3NpdGlvbiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3Qob2Zmc2V0KTtcbiAgICAgIHJlbGF0aXZlUG9zaXRpb24uY2xhbXAoMCwgY2FudmFzLndpZHRoKTtcblxuICAgICAgLy8gVXBkYXRlIHNhdHVyYWl0b24ga25vYiBjc3MgcG9zaXRpb25pbmdcbiAgICAgIHRoaXMuX3NhdHVyYXRpb25Lbm9iLnN0eWxlLmxlZnQgPSByZWxhdGl2ZVBvc2l0aW9uLnggKyAncHgnO1xuICAgICAgdGhpcy5fc2F0dXJhdGlvbktub2Iuc3R5bGUudG9wID0gcmVsYXRpdmVQb3NpdGlvbi55ICsgJ3B4JztcblxuICAgICAgLy8gVXBkYXRlIHNhdHVyYXRpb24gYW5kIHZhbHVlXG4gICAgICByZWxhdGl2ZVBvc2l0aW9uLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICAgIHRoaXMuX2hzdkNvbG9yLnMgPSByZWxhdGl2ZVBvc2l0aW9uLng7XG4gICAgICB0aGlzLl9oc3ZDb2xvci52ID0gMSAtIHJlbGF0aXZlUG9zaXRpb24ueTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNvbG9yKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBzdG9wcyBkcmFnZ2luZyB0aGUgc2F0dXJhdGlvbiBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25TYXR1cmF0aW9uQ2FudmFzVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25TYXR1cmF0aW9uQ2FudmFzVXAoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNEcmFnKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uU2F0dXJhdGlvbkNhbnZhc0RyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25TYXR1cmF0aW9uQ2FudmFzVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vblNhdHVyYXRpb25DYW52YXNVcCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgYXR0YWNoZWQgY29sb3IsIGVtaXRzIHRoZSBgdXBkYXRlYCBldmVudCBhbmQgdHJpZ2dlcnNcbiAgICAgKiBhIHJlbmRlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfdXBkYXRlQ29sb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQ29sb3IoKSB7XG4gICAgICB0aGlzLl92YWx1ZS5mcm9tSFNWKHRoaXMuX2hzdkNvbG9yLmgsIHRoaXMuX2hzdkNvbG9yLnMsIHRoaXMuX2hzdkNvbG9yLnYpO1xuICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLl92YWx1ZSk7XG4gICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ3RlbXBsYXRlJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbG9yLXBpY2tlclwiIGlkPVwiJysoKHR5cGVvZiBpdC5pZCA9PT0gXCJ1bmRlZmluZWRcIj8nJzppdC5pZCkpKydcIj4gPGNhbnZhcyBjbGFzcz1cImltZ2x5a2l0LWNvbG9yLXBpY2tlci1jb2xvclwiIHdpZHRoPVwiMzRcIiBoZWlnaHQ9XCIzNFwiPjwvY2FudmFzPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtaXRlbS1sYWJlbFwiPicrKCh0eXBlb2YgaXQubGFiZWwgPT09IFwidW5kZWZpbmVkXCI/Jyc6aXQubGFiZWwpKSsnPC9kaXY+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb2xvci1waWNrZXItb3ZlcmxheVwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY29sb3ItcGlja2VyLWFscGhhLWNvbnRhaW5lclwiPiA8Y2FudmFzIGNsYXNzPVwiaW1nbHlraXQtY29sb3ItcGlja2VyLWFscGhhXCIgd2lkdGg9XCIyMDBcIiBoZWlnaHQ9XCIzMFwiPjwvY2FudmFzPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtdHJhbnNwYXJlbnQta25vYlwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbG9yLXBpY2tlci1zYXR1cmF0aW9uLWNvbnRhaW5lclwiPiA8Y2FudmFzIGNsYXNzPVwiaW1nbHlraXQtY29sb3ItcGlja2VyLXNhdHVyYXRpb25cIiB3aWR0aD1cIjE2MFwiIGhlaWdodD1cIjE2MFwiPjwvY2FudmFzPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtdHJhbnNwYXJlbnQta25vYlwiPjwvZGl2PiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbG9yLXBpY2tlci1odWUtY29udGFpbmVyXCI+IDxjYW52YXMgY2xhc3M9XCJpbWdseWtpdC1jb2xvci1waWNrZXItaHVlXCIgd2lkdGg9XCIzMFwiIGhlaWdodD1cIjE2MFwiPjwvY2FudmFzPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtdHJhbnNwYXJlbnQta25vYlwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+PC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29sb3JQaWNrZXI7XG59KShfbGliRXZlbnRFbWl0dGVyMlsnZGVmYXVsdCddKTtcblxuZXhwb3J0c1snZGVmYXVsdCddID0gQ29sb3JQaWNrZXI7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vdWkvbmlnaHQvbGliL2NvbG9yLXBpY2tlci5qc1xuICoqIG1vZHVsZSBpZCA9IDEwOFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwiLyogZ2xvYmFsIF9fRE9USlNfVEVNUExBVEUgKi9cbi8qXG4gKiBQaG90byBFZGl0b3IgU0RLIC0gcGhvdG9lZGl0b3JzZGsuY29tXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtMjAxNSA5ZWxlbWVudHMgR21iSFxuICpcbiAqIFJlbGVhc2VkIHVuZGVyIEF0dHJpYnV0aW9uLU5vbkNvbW1lcmNpYWwgMy4wIFVucG9ydGVkXG4gKiBodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9saWNlbnNlcy9ieS1uYy8zLjAvXG4gKlxuICogRm9yIGNvbW1lcmNpYWwgdXNlLCBwbGVhc2UgY29udGFjdCB1cyBhdCBjb250YWN0QDllbGVtZW50cy5jb21cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gKGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmICgndmFsdWUnIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KSgpO1xuXG52YXIgX2dldCA9IGZ1bmN0aW9uIGdldChfeDIsIF94MywgX3g0KSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94MiwgcHJvcGVydHkgPSBfeDMsIHJlY2VpdmVyID0gX3g0OyBfYWdhaW4gPSBmYWxzZTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgb2JqZWN0ID0gRnVuY3Rpb24ucHJvdG90eXBlOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBwcm9wZXJ0eSk7IGlmIChkZXNjID09PSB1bmRlZmluZWQpIHsgdmFyIHBhcmVudCA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAocGFyZW50ID09PSBudWxsKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gZWxzZSB7IF94MiA9IHBhcmVudDsgX3gzID0gcHJvcGVydHk7IF94NCA9IHJlY2VpdmVyOyBfYWdhaW4gPSB0cnVlOyBkZXNjID0gcGFyZW50ID0gdW5kZWZpbmVkOyBjb250aW51ZSBfZnVuY3Rpb247IH0gfSBlbHNlIGlmICgndmFsdWUnIGluIGRlc2MpIHsgcmV0dXJuIGRlc2MudmFsdWU7IH0gZWxzZSB7IHZhciBnZXR0ZXIgPSBkZXNjLmdldDsgaWYgKGdldHRlciA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiB1bmRlZmluZWQ7IH0gcmV0dXJuIGdldHRlci5jYWxsKHJlY2VpdmVyKTsgfSB9IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24nKTsgfSB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09ICdmdW5jdGlvbicgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90ICcgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfY29udHJvbCA9IHJlcXVpcmUoJy4vY29udHJvbCcpO1xuXG52YXIgX2NvbnRyb2wyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY29udHJvbCk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvbWF0aC92ZWN0b3IyJyk7XG5cbnZhciBfbGliTWF0aFZlY3RvcjIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliTWF0aFZlY3RvcjIpO1xuXG52YXIgX2xpYlV0aWxzID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL3V0aWxzJyk7XG5cbnZhciBfbGliVXRpbHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbGliVXRpbHMpO1xuXG52YXIgU3RpY2tlcnNDb250cm9sID0gKGZ1bmN0aW9uIChfQ29udHJvbCkge1xuICBfaW5oZXJpdHMoU3RpY2tlcnNDb250cm9sLCBfQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gU3RpY2tlcnNDb250cm9sKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGlja2Vyc0NvbnRyb2wpO1xuXG4gICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoU3RpY2tlcnNDb250cm9sLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIGNvbnRyb2wuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhTdGlja2Vyc0NvbnRyb2wsIFt7XG4gICAga2V5OiAnaW5pdCcsXG5cbiAgICAvKipcbiAgICAgKiBFbnRyeSBwb2ludCBmb3IgdGhpcyBjb250cm9sXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgICB2YXIgY29udHJvbHNUZW1wbGF0ZSA9IGZ1bmN0aW9uKGl0XG4vKiovKSB7XG52YXIgb3V0PSc8ZGl2PiA8dWwgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1saXN0IGltZ2x5LWNvbnRyb2xzLWxpc3Qtd2l0aC1idXR0b25zXCI+ICc7IGZvcih2YXIgaWRlbnRpZmllciBpbiBpdC5zdGlja2VycykgeyBvdXQrPScgJzsgdmFyIHN0aWNrZXJQYXRoID0gaXQuc3RpY2tlcnNbaWRlbnRpZmllcl07IG91dCs9JyAnOyB2YXIgZW5hYmxlZCA9IGl0LmFjdGl2ZVN0aWNrZXIgPT09IGlkZW50aWZpZXI7IG91dCs9JyA8bGkgZGF0YS1pZGVudGlmaWVyPVwiJysoIGlkZW50aWZpZXIpKydcIic7aWYoZW5hYmxlZCl7b3V0Kz0nIGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmVcIic7fW91dCs9Jz4gPGNhbnZhcyBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tY2FudmFzXCIgZGF0YS1pbWFnZT1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKHN0aWNrZXJQYXRoKSkrJ1wiPjwvY2FudmFzPiA8L2xpPiAnOyB9IG91dCs9JyA8L3VsPjwvZGl2PicrKCBpdC5wYXJ0aWFscy5kb25lQnV0dG9uICk7cmV0dXJuIG91dDtcbn07XG4gICAgICB0aGlzLl9jb250cm9sc1RlbXBsYXRlID0gY29udHJvbHNUZW1wbGF0ZTtcblxuICAgICAgdmFyIGNhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPSBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1zdGlja2Vycy1jb250YWluZXJcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy1zdGlja2Vyc1wiPiA8aW1nIGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXN0aWNrZXItaW1hZ2VcIiAvPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQta25vYlwiPjwvZGl2PiA8L2Rpdj48L2Rpdj4nO3JldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY2FudmFzQ29udHJvbHNUZW1wbGF0ZSA9IGNhbnZhc0NvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIHJlZ2lzdGVyZWQgc3RpY2tlcnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgY2xhc3M+fVxuICAgICAgICovXG4gICAgICB0aGlzLl9hdmFpbGFibGVTdGlja2VycyA9IHt9O1xuICAgICAgdGhpcy5fc3RpY2tlcnMgPSB7fTtcbiAgICAgIHRoaXMuX2FkZERlZmF1bHRTdGlja2VycygpO1xuICAgICAgdGhpcy5zZWxlY3RTdGlja2VycyhudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgdGhlIGRlZmF1bHQgc3RpY2tlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2FkZERlZmF1bHRTdGlja2VycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGREZWZhdWx0U3RpY2tlcnMoKSB7XG4gICAgICB0aGlzLmFkZFN0aWNrZXIoJ2dsYXNzZXMtbmVyZCcsICdzdGlja2Vycy9zdGlja2VyLWdsYXNzZXMtbmVyZC5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignZ2xhc3Nlcy1ub3JtYWwnLCAnc3RpY2tlcnMvc3RpY2tlci1nbGFzc2VzLW5vcm1hbC5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignZ2xhc3Nlcy1zaHV0dGVyLWdyZWVuJywgJ3N0aWNrZXJzL3N0aWNrZXItZ2xhc3Nlcy1zaHV0dGVyLWdyZWVuLnBuZycpO1xuICAgICAgdGhpcy5hZGRTdGlja2VyKCdnbGFzc2VzLXNodXR0ZXIteWVsbG93JywgJ3N0aWNrZXJzL3N0aWNrZXItZ2xhc3Nlcy1zaHV0dGVyLXllbGxvdy5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignZ2xhc3Nlcy1zdW4nLCAnc3RpY2tlcnMvc3RpY2tlci1nbGFzc2VzLXN1bi5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignaGF0LWNhcCcsICdzdGlja2Vycy9zdGlja2VyLWhhdC1jYXAucG5nJyk7XG4gICAgICB0aGlzLmFkZFN0aWNrZXIoJ2hhdC1jeWxpbmRlcicsICdzdGlja2Vycy9zdGlja2VyLWhhdC1jeWxpbmRlci5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignaGF0LXBhcnR5JywgJ3N0aWNrZXJzL3N0aWNrZXItaGF0LXBhcnR5LnBuZycpO1xuICAgICAgdGhpcy5hZGRTdGlja2VyKCdoYXQtc2hlcmlmZicsICdzdGlja2Vycy9zdGlja2VyLWhhdC1zaGVyaWZmLnBuZycpO1xuICAgICAgdGhpcy5hZGRTdGlja2VyKCdoZWFydCcsICdzdGlja2Vycy9zdGlja2VyLWhlYXJ0LnBuZycpO1xuICAgICAgdGhpcy5hZGRTdGlja2VyKCdtdXN0YWNoZS1sb25nJywgJ3N0aWNrZXJzL3N0aWNrZXItbXVzdGFjaGUtbG9uZy5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignbXVzdGFjaGUxJywgJ3N0aWNrZXJzL3N0aWNrZXItbXVzdGFjaGUxLnBuZycpO1xuICAgICAgdGhpcy5hZGRTdGlja2VyKCdtdXN0YWNoZTInLCAnc3RpY2tlcnMvc3RpY2tlci1tdXN0YWNoZTIucG5nJyk7XG4gICAgICB0aGlzLmFkZFN0aWNrZXIoJ211c3RhY2hlMycsICdzdGlja2Vycy9zdGlja2VyLW11c3RhY2hlMy5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcigncGlwZScsICdzdGlja2Vycy9zdGlja2VyLXBpcGUucG5nJyk7XG4gICAgICB0aGlzLmFkZFN0aWNrZXIoJ3Nub3dmbGFrZScsICdzdGlja2Vycy9zdGlja2VyLXNub3dmbGFrZS5wbmcnKTtcbiAgICAgIHRoaXMuYWRkU3RpY2tlcignc3RhcicsICdzdGlja2Vycy9zdGlja2VyLXN0YXIucG5nJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIHRoZSBzdGlja2VyIHdpdGggdGhlIGdpdmVuIGlkZW50aWZpZXIgYW5kIHBhdGhcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnYWRkU3RpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFN0aWNrZXIoaWRlbnRpZmllciwgcGF0aCkge1xuICAgICAgdGhpcy5fYXZhaWxhYmxlU3RpY2tlcnNbaWRlbnRpZmllcl0gPSBwYXRoO1xuICAgICAgdGhpcy5fc3RpY2tlcnNbaWRlbnRpZmllcl0gPSB0aGlzLl9hdmFpbGFibGVTdGlja2Vyc1tpZGVudGlmaWVyXTtcblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJDb250cm9scygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlbGVjdHMgdGhlIHN0aWNrZXJzXG4gICAgICogQHBhcmFtIHtTZWxlY3Rvcn0gc2VsZWN0b3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ3NlbGVjdFN0aWNrZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0U3RpY2tlcnMoc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuX3N0aWNrZXJzID0ge307XG5cbiAgICAgIHZhciBzdGlja2VySWRlbnRpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLl9hdmFpbGFibGVTdGlja2Vycyk7XG5cbiAgICAgIHZhciBzZWxlY3RlZFN0aWNrZXJzID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLnNlbGVjdChzdGlja2VySWRlbnRpZmllcnMsIHNlbGVjdG9yKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRTdGlja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IHNlbGVjdGVkU3RpY2tlcnNbaV07XG4gICAgICAgIHRoaXMuX3N0aWNrZXJzW2lkZW50aWZpZXJdID0gdGhpcy5fYXZhaWxhYmxlU3RpY2tlcnNbaWRlbnRpZmllcl07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgdGhpcy5fcmVuZGVyQ29udHJvbHMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRW50ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLnN0aWNrZXJzO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5fdWkuZ2V0T3JDcmVhdGVPcGVyYXRpb24oJ3N0aWNrZXJzJyk7XG5cbiAgICAgIC8vIERvbid0IHJlbmRlciBpbml0aWFsbHlcbiAgICAgIHRoaXMuX3VpLnJlbW92ZU9wZXJhdGlvbignc3RpY2tlcnMnKTtcblxuICAgICAgdGhpcy5faW5pdGlhbFNldHRpbmdzID0ge1xuICAgICAgICBzdGlja2VyOiB0aGlzLl9vcGVyYXRpb24uZ2V0U3RpY2tlcigpLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5fb3BlcmF0aW9uLmdldFBvc2l0aW9uKCkuY2xvbmUoKSxcbiAgICAgICAgc2l6ZTogdGhpcy5fb3BlcmF0aW9uLmdldFNpemUoKS5jbG9uZSgpXG4gICAgICB9O1xuXG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuXG4gICAgICB0aGlzLl9zaXplID0gdGhpcy5faW5pdGlhbFNldHRpbmdzLnNpemUuY2xvbmUoKTtcbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5faW5pdGlhbFNldHRpbmdzLnBvc2l0aW9uLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSk7XG5cbiAgICAgIC8vIFJlbWVtYmVyIHpvb20gbGV2ZWwgYW5kIHpvb20gdG8gZml0IHRoZSBjYW52YXNcbiAgICAgIHRoaXMuX2luaXRpYWxab29tTGV2ZWwgPSB0aGlzLl91aS5jYW52YXMuem9vbUxldmVsO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnpvb21Ub0ZpdCgpO1xuXG4gICAgICAvLyBGaW5kIERPTSBlbGVtZW50c1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWNhbnZhcy1zdGlja2VycycpO1xuICAgICAgdGhpcy5fc3RpY2tlckltYWdlID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignaW1nJyk7XG4gICAgICB0aGlzLl9zdGlja2VySW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3N0aWNrZXJTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXShfdGhpcy5fc3RpY2tlckltYWdlLndpZHRoLCBfdGhpcy5fc3RpY2tlckltYWdlLmhlaWdodCk7XG4gICAgICAgIF90aGlzLl9vblN0aWNrZXJMb2FkKCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2tub2IgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCdkaXYuaW1nbHlraXQta25vYicpO1xuXG4gICAgICAvLyBNb3VzZSBldmVudCBjYWxsYmFja3MgYm91bmQgdG8gdGhlIGNsYXNzIGNvbnRleHRcbiAgICAgIHRoaXMuX29uSW1hZ2VEb3duID0gdGhpcy5fb25JbWFnZURvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uSW1hZ2VEcmFnID0gdGhpcy5fb25JbWFnZURyYWcuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uSW1hZ2VVcCA9IHRoaXMuX29uSW1hZ2VVcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Lbm9iRG93biA9IHRoaXMuX29uS25vYkRvd24uYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uS25vYkRyYWcgPSB0aGlzLl9vbktub2JEcmFnLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbktub2JVcCA9IHRoaXMuX29uS25vYlVwLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMuX3JlbmRlckxpc3RJdGVtcygpO1xuICAgICAgdGhpcy5faGFuZGxlTGlzdEl0ZW1zKCk7XG4gICAgICB0aGlzLl9oYW5kbGVJbWFnZSgpO1xuICAgICAgdGhpcy5faGFuZGxlS25vYigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIHN0aWNrZXJzIG9uIHRoZSBsaXN0IGl0ZW0gY2FudmFzIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJMaXN0SXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyTGlzdEl0ZW1zKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjYW52YXNJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpIGNhbnZhcycpO1xuICAgICAgdGhpcy5fY2FudmFzSXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjYW52YXNJdGVtcyk7XG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBjYW52YXMgPSBfdGhpczIuX2NhbnZhc0l0ZW1zW2ldO1xuICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGg7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0O1xuXG4gICAgICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHZhciBpbWFnZSA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW1hZ2UnKTtcbiAgICAgICAgdmFyIGltYWdlRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcblxuICAgICAgICB2YXIgY2FudmFzU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcblxuICAgICAgICBpbWFnZUVsLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGltYWdlU2l6ZSA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oaW1hZ2VFbC53aWR0aCwgaW1hZ2VFbC5oZWlnaHQpO1xuICAgICAgICAgIHZhciBuZXdTaXplID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLnJlc2l6ZVZlY3RvclRvRml0KGltYWdlU2l6ZSwgY2FudmFzU2l6ZSk7XG5cbiAgICAgICAgICB2YXIgb2Zmc2V0ID0gY2FudmFzU2l6ZS5jbG9uZSgpLmRpdmlkZSgyKS5zdWJ0cmFjdChuZXdTaXplLmNsb25lKCkuZGl2aWRlKDIpKTtcblxuICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlRWwsIDAsIDAsIGltYWdlU2l6ZS54LCBpbWFnZVNpemUueSwgb2Zmc2V0LngsIG9mZnNldC55LCBuZXdTaXplLngsIG5ld1NpemUueSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGltYWdlRWwuc3JjID0gaW1hZ2U7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NhbnZhc0l0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGxpc3QgaXRlbSBjbGljayBldmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUxpc3RJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVMaXN0SXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XG4gICAgICB0aGlzLl9saXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgICAvLyBMaXN0ZW4gdG8gY2xpY2sgZXZlbnRzXG5cbiAgICAgIHZhciBfbG9vcDIgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSBfdGhpczMuX2xpc3RJdGVtc1tpXTtcbiAgICAgICAgdmFyIGlkZW50aWZpZXIgPSBsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWRlbnRpZmllcicpO1xuICAgICAgICBsaXN0SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczMuX29uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghX3RoaXMzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlICYmIGkgPT09IDAgfHwgX3RoaXMzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlICYmIF90aGlzMy5fc3RpY2tlcnNbaWRlbnRpZmllcl0gPT09IF90aGlzMy5faW5pdGlhbFNldHRpbmdzLnN0aWNrZXIpIHtcbiAgICAgICAgICBfdGhpczMuX29uTGlzdEl0ZW1DbGljayhsaXN0SXRlbSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBfbG9vcDIoaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzaXplcyBhbmQgcG9zaXRpb25zIHRoZSBzdGlja2VyIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBzZXR0aW5nc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfYXBwbHlTZXR0aW5ncycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hcHBseVNldHRpbmdzKCkge1xuICAgICAgdmFyIHJhdGlvID0gdGhpcy5fc3RpY2tlclNpemUueSAvIHRoaXMuX3N0aWNrZXJTaXplLng7XG4gICAgICB0aGlzLl9zaXplLnkgPSB0aGlzLl9zaXplLnggKiByYXRpbztcblxuICAgICAgdGhpcy5fc3RpY2tlckltYWdlLnN0eWxlLndpZHRoID0gdGhpcy5fc2l6ZS54ICsgJ3B4JztcbiAgICAgIHRoaXMuX3N0aWNrZXJJbWFnZS5zdHlsZS5oZWlnaHQgPSB0aGlzLl9zaXplLnkgKyAncHgnO1xuICAgICAgdGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSB0aGlzLl9wb3NpdGlvbi54ICsgJ3B4JztcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS50b3AgPSB0aGlzLl9wb3NpdGlvbi55ICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGhpdHMgdGhlIGJhY2sgYnV0dG9uXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFjaygpIHtcbiAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCdzdGlja2VycycpO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHRoaXMuX2luaXRpYWxTZXR0aW5ncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ3N0aWNrZXJzJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl91aS5jYW52YXMuc2V0Wm9vbUxldmVsKHRoaXMuX2luaXRpYWxab29tTGV2ZWwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGRvbmUgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Eb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9uZSgpIHtcbiAgICAgIC8vIE1hcCB0aGUgcG9zaXRpb24gYW5kIHNpemUgb3B0aW9ucyB0byAwLi4uMSB2YWx1ZXNcbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbi5jbG9uZSgpLmRpdmlkZShjYW52YXNTaXplKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZS5jbG9uZSgpLmRpdmlkZShjYW52YXNTaXplKTtcblxuICAgICAgdGhpcy5fdWkuY2FudmFzLnNldFpvb21MZXZlbCh0aGlzLl9pbml0aWFsWm9vbUxldmVsLCBmYWxzZSk7XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBvcGVyYXRpb24gYW5kIHJlbmRlciBpdFxuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5fdWkuZ2V0T3JDcmVhdGVPcGVyYXRpb24oJ3N0aWNrZXJzJyk7XG4gICAgICB0aGlzLl9vcGVyYXRpb24uc2V0KHtcbiAgICAgICAgc3RpY2tlcjogdGhpcy5fYXZhaWxhYmxlU3RpY2tlcnNbdGhpcy5fc3RpY2tlcl0sXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgc2l6ZTogc2l6ZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl91aS5jYW52YXMucmVuZGVyKCk7XG5cbiAgICAgIHRoaXMuX3VpLmFkZEhpc3RvcnkodGhpcywge1xuICAgICAgICBzdGlja2VyOiB0aGlzLl9pbml0aWFsU2V0dGluZ3Muc3RpY2tlcixcbiAgICAgICAgcG9zaXRpb246IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5wb3NpdGlvbi5jbG9uZSgpLFxuICAgICAgICBzaXplOiB0aGlzLl9pbml0aWFsU2V0dGluZ3Muc2l6ZS5jbG9uZSgpXG4gICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBrbm9iIGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVLbm9iJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZUtub2IoKSB7XG4gICAgICB0aGlzLl9rbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uS25vYkRvd24pO1xuICAgICAgdGhpcy5fa25vYi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Lbm9iRG93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbktub2JEb3duJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS25vYkRvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5faW5pdGlhbFNpemUgPSB0aGlzLl9zaXplLmNsb25lKCk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Lbm9iRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbktub2JVcCk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Lbm9iRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbktub2JEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHZhciBkaWZmID0gbW91c2VQb3NpdGlvbi5jbG9uZSgpLnN1YnRyYWN0KHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uKTtcblxuICAgICAgdmFyIHNpemUgPSB0aGlzLl9pbml0aWFsU2l6ZS5jbG9uZSgpO1xuICAgICAgdmFyIHJhdGlvID0gdGhpcy5fc3RpY2tlckltYWdlLmhlaWdodCAvIHRoaXMuX3N0aWNrZXJJbWFnZS53aWR0aDtcbiAgICAgIHNpemUueCArPSBkaWZmLng7XG4gICAgICBzaXplLnkgPSBzaXplLnggKiByYXRpbztcblxuICAgICAgdGhpcy5fc2l6ZS5jb3B5KHNpemUpO1xuXG4gICAgICB0aGlzLl9hcHBseVNldHRpbmdzKCk7XG4gICAgICB0aGlzLl9oaWdobGlnaHREb25lQnV0dG9uKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uS25vYlVwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uS25vYlVwKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Lbm9iRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbktub2JEcmFnKTtcblxuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Lbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGltYWdlIGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVJbWFnZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVJbWFnZSgpIHtcbiAgICAgIHRoaXMuX3N0aWNrZXJJbWFnZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vbkltYWdlRG93bik7XG4gICAgICB0aGlzLl9zdGlja2VySW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uSW1hZ2VEb3duKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgaW1hZ2VcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkltYWdlRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkltYWdlRG93bihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB0aGlzLl9pbml0aWFsUG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbi5jbG9uZSgpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkltYWdlRHJhZyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkltYWdlRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkltYWdlVXApO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkltYWdlVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIGltYWdlXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25JbWFnZURyYWcnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25JbWFnZURyYWcoZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdmFyIGRpZmYgPSBtb3VzZVBvc2l0aW9uLmNsb25lKCkuc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9pbml0aWFsUG9zaXRpb24uY2xvbmUoKTtcbiAgICAgIHBvc2l0aW9uLmFkZChkaWZmKTtcblxuICAgICAgdGhpcy5fcG9zaXRpb24uY29weShwb3NpdGlvbik7XG5cbiAgICAgIHRoaXMuX2FwcGx5U2V0dGluZ3MoKTtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodERvbmVCdXR0b24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIHRoZSBpbWFnZVxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uSW1hZ2VVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkltYWdlVXAoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9vbkltYWdlRHJhZyk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vbkltYWdlRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbkltYWdlVXApO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9vbkltYWdlVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIGFzIHNvb24gYXMgdGhlIHN0aWNrZXIgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblN0aWNrZXJMb2FkJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uU3RpY2tlckxvYWQoKSB7XG4gICAgICB0aGlzLl9zaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9zdGlja2VySW1hZ2Uud2lkdGgsIHRoaXMuX3N0aWNrZXJJbWFnZS5oZWlnaHQpO1xuXG4gICAgICBpZiAodHlwZW9mIHRoaXMuX3Bvc2l0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FwcGx5U2V0dGluZ3MoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGNsaWNrZWQgYSBsaXN0IGl0ZW1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTGlzdEl0ZW1DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkxpc3RJdGVtQ2xpY2soaXRlbSkge1xuICAgICAgdmFyIG1hbnVhbGx5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGFyZ3VtZW50c1sxXTtcblxuICAgICAgdGhpcy5fZGVhY3RpdmF0ZUFsbEl0ZW1zKCk7XG5cbiAgICAgIHZhciBpZGVudGlmaWVyID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaWRlbnRpZmllcicpO1xuICAgICAgdmFyIHN0aWNrZXJQYXRoID0gdGhpcy5fYXZhaWxhYmxlU3RpY2tlcnNbaWRlbnRpZmllcl07XG4gICAgICBzdGlja2VyUGF0aCA9IHRoaXMuX2tpdC5nZXRBc3NldFBhdGgoc3RpY2tlclBhdGgpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9zdGlja2VySW1hZ2UuYXR0cmlidXRlcy5yZW1vdmVOYW1lZEl0ZW0oJ3N0eWxlJyk7XG4gICAgICB9IGNhdGNoIChlKSB7fVxuXG4gICAgICB0aGlzLl9zdGlja2VyID0gaWRlbnRpZmllcjtcbiAgICAgIHRoaXMuX3N0aWNrZXJJbWFnZS5zcmMgPSBzdGlja2VyUGF0aDtcblxuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5hZGQoJ2ltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tYWN0aXZlJyk7XG5cbiAgICAgIGlmIChtYW51YWxseSkge1xuICAgICAgICB0aGlzLl9oaWdobGlnaHREb25lQnV0dG9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgYWxsIGxpc3QgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2RlYWN0aXZhdGVBbGxJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlQWxsSXRlbXMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSB0aGlzLl9saXN0SXRlbXNbaV07XG4gICAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QobGlzdEl0ZW0pLnJlbW92ZSgnaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIGF2YWlsYWJsZSB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFN0aWNrZXJzQ29udHJvbC5wcm90b3R5cGUpLCAnY29udGV4dCcsIHRoaXMpO1xuICAgICAgY29udGV4dC5zdGlja2VycyA9IHRoaXMuX3N0aWNrZXJzO1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0aWNrZXJzQ29udHJvbDtcbn0pKF9jb250cm9sMlsnZGVmYXVsdCddKTtcblxuU3RpY2tlcnNDb250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3N0aWNrZXJzJztcblxuZXhwb3J0c1snZGVmYXVsdCddID0gU3RpY2tlcnNDb250cm9sO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2NvbnRyb2xzL3N0aWNrZXJzLWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxMDlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gyLCBfeDMsIF94NCkgeyB2YXIgX2FnYWluID0gdHJ1ZTsgX2Z1bmN0aW9uOiB3aGlsZSAoX2FnYWluKSB7IHZhciBvYmplY3QgPSBfeDIsIHByb3BlcnR5ID0gX3gzLCByZWNlaXZlciA9IF94NDsgX2FnYWluID0gZmFsc2U7IGlmIChvYmplY3QgPT09IG51bGwpIG9iamVjdCA9IEZ1bmN0aW9uLnByb3RvdHlwZTsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcGVydHkpOyBpZiAoZGVzYyA9PT0gdW5kZWZpbmVkKSB7IHZhciBwYXJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKHBhcmVudCA9PT0gbnVsbCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IGVsc2UgeyBfeDIgPSBwYXJlbnQ7IF94MyA9IHByb3BlcnR5OyBfeDQgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYkNvbG9yUGlja2VyID0gcmVxdWlyZSgnLi4vbGliL2NvbG9yLXBpY2tlcicpO1xuXG52YXIgX2xpYkNvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yUGlja2VyKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMiA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9tYXRoL3ZlY3RvcjInKTtcblxudmFyIF9saWJNYXRoVmVjdG9yMjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJNYXRoVmVjdG9yMik7XG5cbnZhciBfbGliVXRpbHMgPSByZXF1aXJlKCcuLi8uLi8uLi9saWIvdXRpbHMnKTtcblxudmFyIF9saWJVdGlsczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJVdGlscyk7XG5cbnZhciBUZXh0Q29udHJvbCA9IChmdW5jdGlvbiAoX0NvbnRyb2wpIHtcbiAgX2luaGVyaXRzKFRleHRDb250cm9sLCBfQ29udHJvbCk7XG5cbiAgZnVuY3Rpb24gVGV4dENvbnRyb2woKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRDb250cm9sKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRDb250cm9sLnByb3RvdHlwZSksICdjb25zdHJ1Y3RvcicsIHRoaXMpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICAvKipcbiAgICogQSB1bmlxdWUgc3RyaW5nIHRoYXQgaWRlbnRpZmllcyB0aGlzIGNvbnRyb2wuXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuXG4gIF9jcmVhdGVDbGFzcyhUZXh0Q29udHJvbCwgW3tcbiAgICBrZXk6ICdpbml0JyxcblxuICAgIC8qKlxuICAgICAqIEVudHJ5IHBvaW50IGZvciB0aGlzIGNvbnRyb2xcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAgIHZhciBjb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXY+IDx1bCBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWxpc3QgaW1nbHktY29udHJvbHMtbGlzdC13aXRoLWJ1dHRvbnNcIj4gJzt2YXIgYXJyMT1pdC5mb250cztpZihhcnIxKXt2YXIgdmFsdWUsaW5kZXg9LTEsbDE9YXJyMS5sZW5ndGgtMTt3aGlsZShpbmRleDxsMSl7dmFsdWU9YXJyMVtpbmRleCs9MV07b3V0Kz0nIDxsaSBkYXRhLW5hbWU9XCInKyggdmFsdWUubmFtZSkrJ1wiIGRhdGEtd2VpZ2h0PVwiJysoIHZhbHVlLndlaWdodCkrJ1wiPiA8Y2FudmFzIGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtaXRlbS1jYW52YXNcIj48L2NhbnZhcz4gPC9saT4gJzt9IH0gb3V0Kz0nIDwvdWw+PC9kaXY+PGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWJ1dHRvblwiPiAnKyggaXQucGFydGlhbHMuZmdDb2xvclBpY2tlcikrJzwvZGl2PjxkaXYgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1idXR0b25cIj4gJysoIGl0LnBhcnRpYWxzLmJnQ29sb3JQaWNrZXIpKyc8L2Rpdj4nKyggaXQucGFydGlhbHMuZG9uZUJ1dHRvbik7cmV0dXJuIG91dDtcbn07XG4gICAgICB0aGlzLl9jb250cm9sc1RlbXBsYXRlID0gY29udHJvbHNUZW1wbGF0ZTtcblxuICAgICAgdmFyIGNhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPSBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy10ZXh0LWNvbnRhaW5lclwiPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQtY2FudmFzLXRleHRcIj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNyb3NzaGFpclwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9jcm9zc2hhaXIucG5nJykpKydcIiAvPiA8L2Rpdj4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNhbnZhcy10ZXh0LXRleHRhcmVhXCI+IDx0ZXh0YXJlYT48L3RleHRhcmVhPiA8ZGl2IGNsYXNzPVwiaW1nbHlraXQta25vYlwiPjwvZGl2PiA8L2Rpdj4gPC9kaXY+PC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPSBjYW52YXNDb250cm9sc1RlbXBsYXRlO1xuXG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLmZnQ29sb3JQaWNrZXIgPSBfbGliQ29sb3JQaWNrZXIyWydkZWZhdWx0J10udGVtcGxhdGU7XG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLmZnQ29sb3JQaWNrZXIuYWRkaXRpb25hbENvbnRleHQgPSB7XG4gICAgICAgIGlkOiAnaW1nbHlraXQtdGV4dC1mb3JlZ3JvdW5kLWNvbG9yLXBpY2tlcidcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuYmdDb2xvclBpY2tlciA9IF9saWJDb2xvclBpY2tlcjJbJ2RlZmF1bHQnXS50ZW1wbGF0ZTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuYmdDb2xvclBpY2tlci5hZGRpdGlvbmFsQ29udGV4dCA9IHtcbiAgICAgICAgaWQ6ICdpbWdseWtpdC10ZXh0LWJhY2tncm91bmQtY29sb3ItcGlja2VyJ1xuICAgICAgfTtcblxuICAgICAgdGhpcy5fZm9udHMgPSBbXTtcbiAgICAgIHRoaXMuX2FkZEZvbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnX3JlbmRlckNvbnRyb2xzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlckNvbnRyb2xzKCkge1xuICAgICAgdGhpcy5fcGFydGlhbFRlbXBsYXRlcy5mZ0NvbG9yUGlja2VyLmFkZGl0aW9uYWxDb250ZXh0LmxhYmVsID0gdGhpcy5fdWkudHJhbnNsYXRlKCdjb250cm9scy50ZXh0LmZvcmVncm91bmQnKTtcbiAgICAgIHRoaXMuX3BhcnRpYWxUZW1wbGF0ZXMuYmdDb2xvclBpY2tlci5hZGRpdGlvbmFsQ29udGV4dC5sYWJlbCA9IHRoaXMuX3VpLnRyYW5zbGF0ZSgnY29udHJvbHMudGV4dC5iYWNrZ3JvdW5kJyk7XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihUZXh0Q29udHJvbC5wcm90b3R5cGUpLCAnX3JlbmRlckNvbnRyb2xzJywgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoaXMgY29udHJvbCBpcyBhY3RpdmF0ZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkVudGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRW50ZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLnRleHQ7XG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLl91aS5nZXRPckNyZWF0ZU9wZXJhdGlvbigndGV4dCcpO1xuXG4gICAgICAvLyBEb24ndCByZW5kZXIgaW5pdGlhbGx5XG4gICAgICB0aGlzLl91aS5yZW1vdmVPcGVyYXRpb24oJ3RleHQnKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcblxuICAgICAgdGhpcy5faW5pdGlhbFNldHRpbmdzID0ge1xuICAgICAgICBsaW5lSGVpZ2h0OiB0aGlzLl9vcGVyYXRpb24uZ2V0TGluZUhlaWdodCgpLFxuICAgICAgICBmb250U2l6ZTogdGhpcy5fb3BlcmF0aW9uLmdldEZvbnRTaXplKCksXG4gICAgICAgIGZvbnRGYW1pbHk6IHRoaXMuX29wZXJhdGlvbi5nZXRGb250RmFtaWx5KCksXG4gICAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuX29wZXJhdGlvbi5nZXRGb250V2VpZ2h0KCksXG4gICAgICAgIGNvbG9yOiB0aGlzLl9vcGVyYXRpb24uZ2V0Q29sb3IoKSxcbiAgICAgICAgcG9zaXRpb246IHRoaXMuX29wZXJhdGlvbi5nZXRQb3NpdGlvbigpLFxuICAgICAgICB0ZXh0OiB0aGlzLl9vcGVyYXRpb24uZ2V0VGV4dCgpIHx8ICcnLFxuICAgICAgICBtYXhXaWR0aDogdGhpcy5fb3BlcmF0aW9uLmdldE1heFdpZHRoKCksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5fb3BlcmF0aW9uLmdldEJhY2tncm91bmRDb2xvcigpXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl9zZXR0aW5ncyA9IHtcbiAgICAgICAgbGluZUhlaWdodDogdGhpcy5faW5pdGlhbFNldHRpbmdzLmxpbmVIZWlnaHQsXG4gICAgICAgIGZvbnRTaXplOiB0aGlzLl9pbml0aWFsU2V0dGluZ3MuZm9udFNpemUsXG4gICAgICAgIGZvbnRGYW1pbHk6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5mb250RmFtaWx5LFxuICAgICAgICBmb250V2VpZ2h0OiB0aGlzLl9pbml0aWFsU2V0dGluZ3MuZm9udFdlaWdodCxcbiAgICAgICAgY29sb3I6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5jb2xvci5jbG9uZSgpLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5faW5pdGlhbFNldHRpbmdzLnBvc2l0aW9uLmNsb25lKCkubXVsdGlwbHkoY2FudmFzU2l6ZSksXG4gICAgICAgIHRleHQ6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy50ZXh0LFxuICAgICAgICBtYXhXaWR0aDogdGhpcy5faW5pdGlhbFNldHRpbmdzLm1heFdpZHRoICogY2FudmFzU2l6ZS54LFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5iYWNrZ3JvdW5kQ29sb3IuY2xvbmUoKVxuICAgICAgfTtcblxuICAgICAgLy8gUmVtZW1iZXIgem9vbSBsZXZlbCBhbmQgem9vbSB0byBmaXQgdGhlIGNhbnZhc1xuICAgICAgdGhpcy5faW5pdGlhbFpvb21MZXZlbCA9IHRoaXMuX3VpLmNhbnZhcy56b29tTGV2ZWw7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NhbnZhc0NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jYW52YXMtdGV4dCcpO1xuICAgICAgdGhpcy5fdGV4dGFyZWEgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpO1xuICAgICAgdGhpcy5fdGV4dGFyZWEuZm9jdXMoKTtcblxuICAgICAgdGhpcy5fbW92ZUtub2IgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY3Jvc3NoYWlyJyk7XG4gICAgICB0aGlzLl9yZXNpemVLbm9iID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LWtub2InKTtcblxuICAgICAgLy8gSWYgdGhlIHRleHQgaGFzIGJlZW4gZWRpdGVkIGJlZm9yZSwgc3VidHJhY3QgdGhlIGtub2Igd2lkdGggYW5kIHBhZGRpbmdcbiAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uLnggLT0gMjtcbiAgICAgICAgdGhpcy5fc2V0dGluZ3MucG9zaXRpb24ueSAtPSAyO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vblRleHRhcmVhS2V5VXAgPSB0aGlzLl9vblRleHRhcmVhS2V5VXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uUmVzaXplS25vYkRvd24gPSB0aGlzLl9vblJlc2l6ZUtub2JEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vblJlc2l6ZUtub2JEcmFnID0gdGhpcy5fb25SZXNpemVLbm9iRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25SZXNpemVLbm9iVXAgPSB0aGlzLl9vblJlc2l6ZUtub2JVcC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3ZlS25vYkRvd24gPSB0aGlzLl9vbk1vdmVLbm9iRG93bi5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3ZlS25vYkRyYWcgPSB0aGlzLl9vbk1vdmVLbm9iRHJhZy5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5fb25Nb3ZlS25vYlVwID0gdGhpcy5fb25Nb3ZlS25vYlVwLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkZvcmVncm91bmRDb2xvclVwZGF0ZSA9IHRoaXMuX29uRm9yZWdyb3VuZENvbG9yVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbkJhY2tncm91bmRDb2xvclVwZGF0ZSA9IHRoaXMuX29uQmFja2dyb3VuZENvbG9yVXBkYXRlLmJpbmQodGhpcyk7XG5cbiAgICAgIHRoaXMuX2luaXRDb2xvclBpY2tlcnMoKTtcbiAgICAgIHRoaXMuX3JlbmRlckxpc3RJdGVtcygpO1xuICAgICAgdGhpcy5faGFuZGxlTGlzdEl0ZW1zKCk7XG4gICAgICB0aGlzLl9oYW5kbGVUZXh0YXJlYSgpO1xuICAgICAgdGhpcy5faGFuZGxlUmVzaXplS25vYigpO1xuICAgICAgdGhpcy5faGFuZGxlTW92ZUtub2IoKTtcblxuICAgICAgLy8gUmVzaXplIGFzeW5jaHJvbm91c2x5IHRvIHJlbmRlciBhIGZyYW1lXG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMuX3Jlc2l6ZVRleHRhcmVhKCk7XG4gICAgICB9LCAxKTtcblxuICAgICAgdGhpcy5fdWkuY2FudmFzLnpvb21Ub0ZpdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpcy5fYXBwbHlTZXR0aW5ncygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbG9yIHBpY2tlcnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2luaXRDb2xvclBpY2tlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdENvbG9yUGlja2VycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgZm9yZWdyb3VuZENvbG9yUGlja2VyID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LXRleHQtZm9yZWdyb3VuZC1jb2xvci1waWNrZXInKTtcbiAgICAgIHRoaXMuX2ZvcmVncm91bmRDb2xvclBpY2tlciA9IG5ldyBfbGliQ29sb3JQaWNrZXIyWydkZWZhdWx0J10odGhpcy5fdWksIGZvcmVncm91bmRDb2xvclBpY2tlcik7XG4gICAgICB0aGlzLl9mb3JlZ3JvdW5kQ29sb3JQaWNrZXIuc2V0VmFsdWUodGhpcy5fb3BlcmF0aW9uLmdldENvbG9yKCkpO1xuICAgICAgdGhpcy5fZm9yZWdyb3VuZENvbG9yUGlja2VyLm9uKCd1cGRhdGUnLCB0aGlzLl9vbkZvcmVncm91bmRDb2xvclVwZGF0ZSk7XG4gICAgICB0aGlzLl9mb3JlZ3JvdW5kQ29sb3JQaWNrZXIub24oJ3Nob3cnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5fYmFja2dyb3VuZENvbG9yUGlja2VyLmhpZGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYmFja2dyb3VuZENvbG9yUGlja2VyID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LXRleHQtYmFja2dyb3VuZC1jb2xvci1waWNrZXInKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclBpY2tlciA9IG5ldyBfbGliQ29sb3JQaWNrZXIyWydkZWZhdWx0J10odGhpcy5fdWksIGJhY2tncm91bmRDb2xvclBpY2tlcik7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kQ29sb3JQaWNrZXIuc2V0VmFsdWUodGhpcy5fb3BlcmF0aW9uLmdldEJhY2tncm91bmRDb2xvcigpKTtcbiAgICAgIHRoaXMuX2JhY2tncm91bmRDb2xvclBpY2tlci5vbigndXBkYXRlJywgdGhpcy5fb25CYWNrZ3JvdW5kQ29sb3JVcGRhdGUpO1xuICAgICAgdGhpcy5fYmFja2dyb3VuZENvbG9yUGlja2VyLm9uKCdzaG93JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuX2ZvcmVncm91bmRDb2xvclBpY2tlci5oaWRlKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIHRoZSB0ZXh0IG9uIHRoZSBsaXN0IGl0ZW0gY2FudmFzIGVsZW1lbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19yZW5kZXJMaXN0SXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyTGlzdEl0ZW1zKCkge1xuICAgICAgdmFyIGNhbnZhc0l0ZW1zID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvckFsbCgnbGkgY2FudmFzJyk7XG4gICAgICB0aGlzLl9jYW52YXNJdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGNhbnZhc0l0ZW1zKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jYW52YXNJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzSXRlbXNbaV07XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5vZmZzZXRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQ7XG5cbiAgICAgICAgdmFyIGxpc3RJdGVtID0gY2FudmFzLnBhcmVudE5vZGU7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdmFyIGZvbnRGYW1pbHkgPSBsaXN0SXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtbmFtZScpO1xuICAgICAgICB2YXIgZm9udFdlaWdodCA9IGxpc3RJdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS13ZWlnaHQnKTtcblxuICAgICAgICBjb250ZXh0LmZvbnQgPSBmb250V2VpZ2h0ICsgJyAzMHB4ICcgKyBmb250RmFtaWx5O1xuICAgICAgICBjb250ZXh0LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG5cbiAgICAgICAgY29udGV4dC5maWxsVGV4dChmb250RmFtaWx5LnN1YnN0cigwLCAyKSwgY2FudmFzLndpZHRoIC8gMiwgY2FudmFzLmhlaWdodCAvIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGxpc3QgaXRlbSBjbGljayBldmVudHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hhbmRsZUxpc3RJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVMaXN0SXRlbXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGxpc3RJdGVtcyA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJyk7XG4gICAgICB0aGlzLl9saXN0SXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0SXRlbXMpO1xuXG4gICAgICAvLyBMaXN0ZW4gdG8gY2xpY2sgZXZlbnRzXG5cbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciBsaXN0SXRlbSA9IF90aGlzMy5fbGlzdEl0ZW1zW2ldO1xuICAgICAgICB2YXIgbmFtZSA9IGxpc3RJdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJyk7XG4gICAgICAgIGxpc3RJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMy5fb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFfdGhpczMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgJiYgaSA9PT0gMCB8fCBfdGhpczMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmUgJiYgbmFtZSA9PT0gX3RoaXMzLl9pbml0aWFsU2V0dGluZ3MuZm9udEZhbWlseSkge1xuICAgICAgICAgIF90aGlzMy5fb25MaXN0SXRlbUNsaWNrKGxpc3RJdGVtLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIF9sb29wKGkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIHRleHQgYXJlYSBrZXkgZXZlbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVUZXh0YXJlYScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVUZXh0YXJlYSgpIHtcbiAgICAgIHRoaXMuX3RleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fb25UZXh0YXJlYUtleVVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHJlbGVhc2VzIGEga2V5IGluc2lkZSB0aGUgdGV4dCBhcmVhXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblRleHRhcmVhS2V5VXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UZXh0YXJlYUtleVVwKCkge1xuICAgICAgdGhpcy5fcmVzaXplVGV4dGFyZWEoKTtcbiAgICAgIHRoaXMuX3NldHRpbmdzLnRleHQgPSB0aGlzLl90ZXh0YXJlYS52YWx1ZTtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodERvbmVCdXR0b24oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNpemVzIHRoZSB0ZXh0IGFyZWEgdG8gZml0IHRoZSB0ZXh0IGluc2lkZSBvZiBpdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzaXplVGV4dGFyZWEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzaXplVGV4dGFyZWEoKSB7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5fdGV4dGFyZWEuc2Nyb2xsVG9wO1xuXG4gICAgICBpZiAoIXNjcm9sbFRvcCkge1xuICAgICAgICB2YXIgX3Njcm9sbEhlaWdodCA9IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIF9zY3JvbGxIZWlnaHQgPSB0aGlzLl90ZXh0YXJlYS5zY3JvbGxIZWlnaHQ7XG4gICAgICAgICAgaGVpZ2h0ID0gdGhpcy5fdGV4dGFyZWEub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAgIHRoaXMuX3RleHRhcmVhLnN0eWxlLmhlaWdodCA9IGhlaWdodCAtIDUgKyAncHgnO1xuICAgICAgICB9IHdoaWxlIChfc2Nyb2xsSGVpZ2h0ICYmIF9zY3JvbGxIZWlnaHQgIT09IHRoaXMuX3RleHRhcmVhLnNjcm9sbEhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzY3JvbGxIZWlnaHQgPSB0aGlzLl90ZXh0YXJlYS5zY3JvbGxIZWlnaHQ7XG4gICAgICB0aGlzLl90ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSBzY3JvbGxIZWlnaHQgKyAyMCArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgbW92ZSBrbm9iIGRyYWdnaW5nXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVNb3ZlS25vYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVNb3ZlS25vYigpIHtcbiAgICAgIHRoaXMuX21vdmVLbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW92ZUtub2JEb3duKTtcbiAgICAgIHRoaXMuX21vdmVLbm9iLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9vbk1vdmVLbm9iRG93bik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgdGhlIG1vdmUga25vYlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Nb3ZlS25vYkRvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3ZlS25vYkRvd24oZSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsTW91c2VQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpO1xuICAgICAgdGhpcy5faW5pdGlhbFBvc2l0aW9uID0gdGhpcy5fc2V0dGluZ3MucG9zaXRpb24uY2xvbmUoKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlS25vYkRyYWcpO1xuXG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3ZlS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3ZlS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3ZlIGtub2JcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTW92ZUtub2JEcmFnJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uTW92ZUtub2JEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcblxuICAgICAgdmFyIG1vdXNlUG9zaXRpb24gPSBfbGliVXRpbHMyWydkZWZhdWx0J10uZ2V0RXZlbnRQb3NpdGlvbihlKTtcbiAgICAgIHZhciBkaWZmID0gbW91c2VQb3NpdGlvbi5jbG9uZSgpLnN1YnRyYWN0KHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uKTtcblxuICAgICAgdmFyIG1pblBvc2l0aW9uID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSgwLCAwKTtcbiAgICAgIHZhciBjb250YWluZXJTaXplID0gbmV3IF9saWJNYXRoVmVjdG9yMjJbJ2RlZmF1bHQnXSh0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGgsIHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQpO1xuICAgICAgdmFyIG1heFBvc2l0aW9uID0gY2FudmFzU2l6ZS5jbG9uZSgpLnN1YnRyYWN0KGNvbnRhaW5lclNpemUpO1xuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5faW5pdGlhbFBvc2l0aW9uLmNsb25lKCkuYWRkKGRpZmYpLmNsYW1wKG1pblBvc2l0aW9uLCBtYXhQb3NpdGlvbik7XG5cbiAgICAgIHRoaXMuX3NldHRpbmdzLnBvc2l0aW9uID0gcG9zaXRpb247XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudG9wID0gcG9zaXRpb24ueSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgbW92ZSBrbm9iXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdmVLbm9iVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3ZlS25vYlVwKCkge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3ZlS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25Nb3ZlS25vYkRyYWcpO1xuXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fb25Nb3ZlS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3ZlS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSByZXNpemUga25vYiBkcmFnZ2luZ1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfaGFuZGxlUmVzaXplS25vYicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVSZXNpemVLbm9iKCkge1xuICAgICAgdGhpcy5fcmVzaXplS25vYi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9vblJlc2l6ZUtub2JEb3duKTtcbiAgICAgIHRoaXMuX3Jlc2l6ZUtub2IuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX29uUmVzaXplS25vYkRvd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzIHRoZSByZXNpemUga25vYlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uUmVzaXplS25vYkRvd24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemVLbm9iRG93bihlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIHRoaXMuX2luaXRpYWxNb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB0aGlzLl9pbml0aWFsTWF4V2lkdGggPSB0aGlzLl9zZXR0aW5ncy5tYXhXaWR0aDtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fb25SZXNpemVLbm9iRHJhZyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9vblJlc2l6ZUtub2JEcmFnKTtcblxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX29uUmVzaXplS25vYlVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25SZXNpemVLbm9iVXApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgZHJhZ3MgdGhlIHJlc2l6ZSBrbm9iXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25SZXNpemVLbm9iRHJhZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZUtub2JEcmFnKGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgdmFyIGNhbnZhc1NpemUgPSB0aGlzLl91aS5jYW52YXMuc2l6ZTtcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gX2xpYlV0aWxzMlsnZGVmYXVsdCddLmdldEV2ZW50UG9zaXRpb24oZSk7XG4gICAgICB2YXIgZGlmZiA9IG1vdXNlUG9zaXRpb24uc3VidHJhY3QodGhpcy5faW5pdGlhbE1vdXNlUG9zaXRpb24pO1xuXG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9zZXR0aW5ncy5wb3NpdGlvbi5jbG9uZSgpO1xuICAgICAgdmFyIG1heFdpZHRoQWxsb3dlZCA9IGNhbnZhc1NpemUueCAtIHBvc2l0aW9uLng7XG5cbiAgICAgIHZhciBtYXhXaWR0aCA9IHRoaXMuX2luaXRpYWxNYXhXaWR0aCArIGRpZmYueDtcbiAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgoMTAwLCBNYXRoLm1pbihtYXhXaWR0aEFsbG93ZWQsIG1heFdpZHRoKSk7XG4gICAgICB0aGlzLl9zZXR0aW5ncy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgdGhpcy5fdGV4dGFyZWEuc3R5bGUud2lkdGggPSBtYXhXaWR0aCArICdweCc7XG5cbiAgICAgIHRoaXMuX3Jlc2l6ZVRleHRhcmVhKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciByZWxlYXNlcyB0aGUgcmVzaXplIGtub2JcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vblJlc2l6ZUtub2JVcCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblJlc2l6ZUtub2JVcCgpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uUmVzaXplS25vYkRyYWcpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fb25SZXNpemVLbm9iRHJhZyk7XG5cbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vblJlc2l6ZUtub2JVcCk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX29uUmVzaXplS25vYlVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHNlbGVjdHMgYW5vdGhlciBjb2xvciB1c2luZ1xuICAgICAqIHRoZSBjb2xvciBwaWNrZXIuXG4gICAgICogQHBhcmFtIHtDb2xvcn0gdmFsdWVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uRm9yZWdyb3VuZENvbG9yVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRm9yZWdyb3VuZENvbG9yVXBkYXRlKHZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXR0aW5ncy5jb2xvciA9IHZhbHVlO1xuICAgICAgdGhpcy5fYXBwbHlTZXR0aW5ncygpO1xuICAgICAgdGhpcy5faGlnaGxpZ2h0RG9uZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhbm90aGVyIGNvbG9yIHVzaW5nXG4gICAgICogdGhlIGNvbG9yIHBpY2tlci5cbiAgICAgKiBAcGFyYW0ge0NvbG9yfSB2YWx1ZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrZ3JvdW5kQ29sb3JVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrZ3JvdW5kQ29sb3JVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX3NldHRpbmdzLmJhY2tncm91bmRDb2xvciA9IHZhbHVlO1xuICAgICAgdGhpcy5fYXBwbHlTZXR0aW5ncygpO1xuICAgICAgdGhpcy5faGlnaGxpZ2h0RG9uZUJ1dHRvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0eWxlcyB0aGUgdGV4dGFyZWEgdG8gcmVwcmVzZW50IHRoZSBjdXJyZW50IHNldHRpbmdzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hcHBseVNldHRpbmdzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FwcGx5U2V0dGluZ3MoKSB7XG4gICAgICB2YXIgdGV4dGFyZWEgPSB0aGlzLl90ZXh0YXJlYTtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuX3NldHRpbmdzO1xuXG4gICAgICB2YXIgY2FudmFzU2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuICAgICAgdmFyIGFjdHVhbEZvbnRTaXplID0gc2V0dGluZ3MuZm9udFNpemUgKiBjYW52YXNTaXplLnk7XG5cbiAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5sZWZ0ID0gc2V0dGluZ3MucG9zaXRpb24ueCArICdweCc7XG4gICAgICB0aGlzLl9jb250YWluZXIuc3R5bGUudG9wID0gc2V0dGluZ3MucG9zaXRpb24ueSArICdweCc7XG5cbiAgICAgIHRleHRhcmVhLnZhbHVlID0gc2V0dGluZ3MudGV4dDtcbiAgICAgIHRleHRhcmVhLnN0eWxlLmZvbnRGYW1pbHkgPSBzZXR0aW5ncy5mb250RmFtaWx5O1xuICAgICAgdGV4dGFyZWEuc3R5bGUuZm9udFNpemUgPSBhY3R1YWxGb250U2l6ZSArICdweCc7XG4gICAgICB0ZXh0YXJlYS5zdHlsZS5mb250V2VpZ2h0ID0gc2V0dGluZ3MuZm9udFdlaWdodDtcbiAgICAgIHRleHRhcmVhLnN0eWxlLmxpbmVIZWlnaHQgPSBzZXR0aW5ncy5saW5lSGVpZ2h0O1xuICAgICAgdGV4dGFyZWEuc3R5bGUuY29sb3IgPSBzZXR0aW5ncy5jb2xvci50b1JHQkEoKTtcbiAgICAgIHRleHRhcmVhLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHNldHRpbmdzLmJhY2tncm91bmRDb2xvci50b1JHQkEoKTtcbiAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gc2V0dGluZ3MubWF4V2lkdGggKyAncHgnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHVzZXIgY2xpY2tlZCBhIGxpc3QgaXRlbVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25MaXN0SXRlbUNsaWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uTGlzdEl0ZW1DbGljayhpdGVtKSB7XG4gICAgICB2YXIgbWFudWFsbHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICB0aGlzLl9kZWFjdGl2YXRlQWxsSXRlbXMoKTtcblxuICAgICAgdmFyIG5hbWUgPSBpdGVtLmdldEF0dHJpYnV0ZSgnZGF0YS1uYW1lJyk7XG4gICAgICB2YXIgd2VpZ2h0ID0gaXRlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtd2VpZ2h0Jyk7XG4gICAgICB0aGlzLl9zZXR0aW5ncy5mb250RmFtaWx5ID0gbmFtZTtcbiAgICAgIHRoaXMuX3NldHRpbmdzLmZvbnRXZWlnaHQgPSB3ZWlnaHQ7XG5cbiAgICAgIHRoaXMuX2FwcGx5U2V0dGluZ3MoKTtcblxuICAgICAgX2xpYlV0aWxzMlsnZGVmYXVsdCddLmNsYXNzTGlzdChpdGVtKS5hZGQoJ2ltZ2x5a2l0LWNvbnRyb2xzLWl0ZW0tYWN0aXZlJyk7XG5cbiAgICAgIGlmIChtYW51YWxseSkge1xuICAgICAgICB0aGlzLl9oaWdobGlnaHREb25lQnV0dG9uKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVhY3RpdmF0ZXMgYWxsIGxpc3QgaXRlbXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2RlYWN0aXZhdGVBbGxJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZWFjdGl2YXRlQWxsSXRlbXMoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xpc3RJdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlzdEl0ZW0gPSB0aGlzLl9saXN0SXRlbXNbaV07XG4gICAgICAgIF9saWJVdGlsczJbJ2RlZmF1bHQnXS5jbGFzc0xpc3QobGlzdEl0ZW0pLnJlbW92ZSgnaW1nbHlraXQtY29udHJvbHMtaXRlbS1hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBkZWZhdWx0IGZvbnRzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19hZGRGb250cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRGb250cygpIHtcbiAgICAgIHRoaXMuYWRkRm9udCgnSGVsdmV0aWNhJywgJ25vcm1hbCcpO1xuICAgICAgdGhpcy5hZGRGb250KCdWZXJkYW5hJywgJ25vcm1hbCcpO1xuICAgICAgdGhpcy5hZGRGb250KCdUaW1lcyBOZXcgUm9tYW4nLCAnbm9ybWFsJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZvbnQgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBhbmQgd2VpZ2h0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gd2VpZ2h0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRGb250JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRm9udChuYW1lLCB3ZWlnaHQpIHtcbiAgICAgIHRoaXMuX2ZvbnRzLnB1c2goeyBuYW1lOiBuYW1lLCB3ZWlnaHQ6IHdlaWdodCB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBkb25lIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25Eb25lJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9uZSgpIHtcbiAgICAgIHZhciBjYW52YXNTaXplID0gdGhpcy5fdWkuY2FudmFzLnNpemU7XG4gICAgICB2YXIgcGFkZGluZyA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oMiwgMik7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9zZXR0aW5ncy5wb3NpdGlvbi5jbG9uZSgpLmFkZChwYWRkaW5nKS5kaXZpZGUoY2FudmFzU2l6ZSk7XG5cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5zZXRab29tTGV2ZWwodGhpcy5faW5pdGlhbFpvb21MZXZlbCwgZmFsc2UpO1xuXG4gICAgICB0aGlzLl9vcGVyYXRpb24gPSB0aGlzLl91aS5nZXRPckNyZWF0ZU9wZXJhdGlvbigndGV4dCcpO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldCh7XG4gICAgICAgIGZvbnRTaXplOiB0aGlzLl9zZXR0aW5ncy5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseTogdGhpcy5fc2V0dGluZ3MuZm9udEZhbWlseSxcbiAgICAgICAgZm9udFdlaWdodDogdGhpcy5fc2V0dGluZ3MuZm9udFdlaWdodCxcbiAgICAgICAgY29sb3I6IHRoaXMuX3NldHRpbmdzLmNvbG9yLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoaXMuX3NldHRpbmdzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLFxuICAgICAgICB0ZXh0OiB0aGlzLl9zZXR0aW5ncy50ZXh0LFxuICAgICAgICBtYXhXaWR0aDogdGhpcy5fc2V0dGluZ3MubWF4V2lkdGggLyBjYW52YXNTaXplLnhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fdWkuY2FudmFzLnJlbmRlcigpO1xuXG4gICAgICB0aGlzLl91aS5hZGRIaXN0b3J5KHRoaXMsIHtcbiAgICAgICAgZm9udEZhbWlseTogdGhpcy5faW5pdGlhbFNldHRpbmdzLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRXZWlnaHQ6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy5mb250V2VpZ2h0LFxuICAgICAgICBjb2xvcjogdGhpcy5faW5pdGlhbFNldHRpbmdzLmNvbG9yLmNsb25lKCksXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhpcy5faW5pdGlhbFNldHRpbmdzLmJhY2tncm91bmRDb2xvci5jbG9uZSgpLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5faW5pdGlhbFNldHRpbmdzLnBvc2l0aW9uLmNsb25lKCksXG4gICAgICAgIHRleHQ6IHRoaXMuX2luaXRpYWxTZXR0aW5ncy50ZXh0LFxuICAgICAgICBtYXhXaWR0aDogdGhpcy5faW5pdGlhbFNldHRpbmdzLm1heFdpZHRoXG4gICAgICB9LCB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25CYWNrJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQmFjaygpIHtcbiAgICAgIGlmICh0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlKSB7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbiA9IHRoaXMuX3VpLmdldE9yQ3JlYXRlT3BlcmF0aW9uKCd0ZXh0Jyk7XG4gICAgICAgIHRoaXMuX29wZXJhdGlvbi5zZXQodGhpcy5faW5pdGlhbFNldHRpbmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3VpLnJlbW92ZU9wZXJhdGlvbigndGV4dCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5fdWkuY2FudmFzLnNldFpvb21MZXZlbCh0aGlzLl9pbml0aWFsWm9vbUxldmVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YSB0aGF0IGlzIGF2YWlsYWJsZSB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY29udGV4dCA9IF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKFRleHRDb250cm9sLnByb3RvdHlwZSksICdjb250ZXh0JywgdGhpcyk7XG4gICAgICBjb250ZXh0LmZvbnRzID0gdGhpcy5fZm9udHM7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dENvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cblRleHRDb250cm9sLnByb3RvdHlwZS5pZGVudGlmaWVyID0gJ3RleHQnO1xuXG5leHBvcnRzWydkZWZhdWx0J10gPSBUZXh0Q29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy90ZXh0LWNvbnRyb2wuanNcbiAqKiBtb2R1bGUgaWQgPSAxMTBcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qIGdsb2JhbCBfX0RPVEpTX1RFTVBMQVRFICovXG4vKlxuICogUGhvdG8gRWRpdG9yIFNESyAtIHBob3RvZWRpdG9yc2RrLmNvbVxuICogQ29weXJpZ2h0IChjKSAyMDEzLTIwMTUgOWVsZW1lbnRzIEdtYkhcbiAqXG4gKiBSZWxlYXNlZCB1bmRlciBBdHRyaWJ1dGlvbi1Ob25Db21tZXJjaWFsIDMuMCBVbnBvcnRlZFxuICogaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbGljZW5zZXMvYnktbmMvMy4wL1xuICpcbiAqIEZvciBjb21tZXJjaWFsIHVzZSwgcGxlYXNlIGNvbnRhY3QgdXMgYXQgY29udGFjdEA5ZWxlbWVudHMuY29tXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBnZXQoX3gsIF94MiwgX3gzKSB7IHZhciBfYWdhaW4gPSB0cnVlOyBfZnVuY3Rpb246IHdoaWxlIChfYWdhaW4pIHsgdmFyIG9iamVjdCA9IF94LCBwcm9wZXJ0eSA9IF94MiwgcmVjZWl2ZXIgPSBfeDM7IF9hZ2FpbiA9IGZhbHNlOyBpZiAob2JqZWN0ID09PSBudWxsKSBvYmplY3QgPSBGdW5jdGlvbi5wcm90b3R5cGU7IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTsgaWYgKGRlc2MgPT09IHVuZGVmaW5lZCkgeyB2YXIgcGFyZW50ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChwYXJlbnQgPT09IG51bGwpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfSBlbHNlIHsgX3ggPSBwYXJlbnQ7IF94MiA9IHByb3BlcnR5OyBfeDMgPSByZWNlaXZlcjsgX2FnYWluID0gdHJ1ZTsgZGVzYyA9IHBhcmVudCA9IHVuZGVmaW5lZDsgY29udGludWUgX2Z1bmN0aW9uOyB9IH0gZWxzZSBpZiAoJ3ZhbHVlJyBpbiBkZXNjKSB7IHJldHVybiBkZXNjLnZhbHVlOyB9IGVsc2UgeyB2YXIgZ2V0dGVyID0gZGVzYy5nZXQ7IGlmIChnZXR0ZXIgPT09IHVuZGVmaW5lZCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9IHJldHVybiBnZXR0ZXIuY2FsbChyZWNlaXZlcik7IH0gfSB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSAnZnVuY3Rpb24nICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCAnICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgX2NvbnRyb2wgPSByZXF1aXJlKCcuL2NvbnRyb2wnKTtcblxudmFyIF9jb250cm9sMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NvbnRyb2wpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyID0gcmVxdWlyZSgnLi4vLi4vLi4vbGliL21hdGgvdmVjdG9yMicpO1xuXG52YXIgX2xpYk1hdGhWZWN0b3IyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYk1hdGhWZWN0b3IyKTtcblxudmFyIF9saWJVdGlscyA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi91dGlscycpO1xuXG52YXIgX2xpYlV0aWxzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYlV0aWxzKTtcblxudmFyIF9saWJTaW1wbGVTbGlkZXIgPSByZXF1aXJlKCcuLi9saWIvc2ltcGxlLXNsaWRlcicpO1xuXG52YXIgX2xpYlNpbXBsZVNsaWRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9saWJTaW1wbGVTbGlkZXIpO1xuXG52YXIgX2xpYkNvbG9yUGlja2VyID0gcmVxdWlyZSgnLi4vbGliL2NvbG9yLXBpY2tlcicpO1xuXG52YXIgX2xpYkNvbG9yUGlja2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yUGlja2VyKTtcblxudmFyIF9saWJDb2xvciA9IHJlcXVpcmUoJy4uLy4uLy4uL2xpYi9jb2xvcicpO1xuXG52YXIgX2xpYkNvbG9yMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2xpYkNvbG9yKTtcblxudmFyIEJydXNoQ29udHJvbCA9IChmdW5jdGlvbiAoX0NvbnRyb2wpIHtcbiAgX2luaGVyaXRzKEJydXNoQ29udHJvbCwgX0NvbnRyb2wpO1xuXG4gIGZ1bmN0aW9uIEJydXNoQ29udHJvbCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJ1c2hDb250cm9sKTtcblxuICAgIF9nZXQoT2JqZWN0LmdldFByb3RvdHlwZU9mKEJydXNoQ29udHJvbC5wcm90b3R5cGUpLCAnY29uc3RydWN0b3InLCB0aGlzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgdW5pcXVlIHN0cmluZyB0aGF0IGlkZW50aWZpZXMgdGhpcyBjb250cm9sLlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cblxuICBfY3JlYXRlQ2xhc3MoQnJ1c2hDb250cm9sLCBbe1xuICAgIGtleTogJ2luaXQnLFxuXG4gICAgLyoqXG4gICAgICogRW50cnkgcG9pbnQgZm9yIHRoaXMgY29udHJvbFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgdmFyIGNvbnRyb2xzVGVtcGxhdGUgPSBmdW5jdGlvbihpdFxuLyoqLykge1xudmFyIG91dD0nJztpZihpdC5kaXNwbGF5VGhpY2tuZXNzKXtvdXQrPScgPGRpdj4gJysoIGl0LnBhcnRpYWxzLnNsaWRlcikrJyA8L2Rpdj4nO31lbHNle291dCs9JyA8ZGl2PiA8dWwgY2xhc3M9XCJpbWdseWtpdC1jb250cm9scy1saXN0IGltZ2x5a2l0LWNvbnRyb2xzLWxpc3Qtb3ZlcmZsb3dcIj4gPGxpIGNsYXNzPVwiaW1nbHlraXQtY29udHJvbHMtaXRlbS0td2l0aC1sYWJlbFwiIGlkPVwiaW1nbHlraXQtdGhpY2tuZXNzLWJ1dHRvblwiPiA8aW1nIHNyYz1cIicrKGl0LmhlbHBlcnMuYXNzZXRQYXRoKCd1aS9uaWdodC9icnVzaC90aGlja25lc3NAMngucG5nJykgKSsnXCIgLz4gPGRpdiBjbGFzcz1cImltZ2x5a2l0LWNvbnRyb2xzLWxhYmVsXCI+VGhpY2tuZXNzPC9kaXY+IDwvbGk+IDxsaT4gJysoIGl0LnBhcnRpYWxzLmNvbG9yUGlja2VyKSsnIDwvbGk+IDwvdWw+IDwvZGl2Pic7fXJldHVybiBvdXQ7XG59O1xuICAgICAgdGhpcy5fY29udHJvbHNUZW1wbGF0ZSA9IGNvbnRyb2xzVGVtcGxhdGU7XG5cbiAgICAgIHZhciBjYW52YXNDb250cm9sc1RlbXBsYXRlID0gZnVuY3Rpb24oaXRcbi8qKi8pIHtcbnZhciBvdXQ9JzxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtYnJ1c2gtY29udGFpbmVyXCI+IDxkaXYgY2xhc3M9XCJpbWdseWtpdC1jYW52YXMtYnJ1c2hcIj4gPGNhbnZhcz48L2NhbnZhcz4gPC9kaXY+IDxkaXYgaWQ9XCJpbWdseWtpdC1icnVzaC1jdXJzb3JcIj4gPC9kaXY+PC9kaXY+JztyZXR1cm4gb3V0O1xufTtcbiAgICAgIHRoaXMuX2NhbnZhc0NvbnRyb2xzVGVtcGxhdGUgPSBjYW52YXNDb250cm9sc1RlbXBsYXRlO1xuXG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLnNsaWRlciA9IF9saWJTaW1wbGVTbGlkZXIyWydkZWZhdWx0J10udGVtcGxhdGU7XG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLmNvbG9yUGlja2VyID0gX2xpYkNvbG9yUGlja2VyMlsnZGVmYXVsdCddLnRlbXBsYXRlO1xuXG4gICAgICB0aGlzLl9kaXNwbGF5VGhpY2tuZXNzID0gZmFsc2U7XG4gICAgICB0aGlzLl9wYWludGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNvbnRyb2xzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVuZGVyQ29udHJvbHMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVuZGVyQ29udHJvbHMoKSB7XG4gICAgICB0aGlzLl9wYXJ0aWFsVGVtcGxhdGVzLmNvbG9yUGlja2VyLmFkZGl0aW9uYWxDb250ZXh0ID0geyBsYWJlbDogdGhpcy5fdWkudHJhbnNsYXRlKCdjb250cm9scy5icnVzaC5jb2xvcicpIH07XG4gICAgICBfZ2V0KE9iamVjdC5nZXRQcm90b3R5cGVPZihCcnVzaENvbnRyb2wucHJvdG90eXBlKSwgJ19yZW5kZXJDb250cm9scycsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGlzIGNvbnRyb2wgaXMgYWN0aXZhdGVkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25FbnRlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkVudGVyKCkge1xuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJ1c2hDb250cm9sLnByb3RvdHlwZSksICdfb25FbnRlcicsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgICB0aGlzLl9oYW5kbGVUaGlja25lc3NCdXR0b24oKTtcbiAgICAgIHRoaXMuX3NldHVwQ2FudmFzKCk7XG4gICAgICB0aGlzLl9zZXR1cE9wZXJhdGlvbigpO1xuICAgICAgdGhpcy5fc2V0dXBPcHRpb25zKCk7XG4gICAgICB0aGlzLl9iaW5kRXZlbnRIYW5kbGVycygpO1xuICAgICAgdGhpcy5fc2V0dXBDb250YWluZXIoKTtcbiAgICAgIHRoaXMuX3NldHVwU2xpZGVyKCk7XG4gICAgICB0aGlzLl9pbml0Q3VycmVudFZhbHVlcygpO1xuICAgICAgdGhpcy5fc2V0dXBDb2xvclBpY2tlcigpO1xuXG4gICAgICB0aGlzLl9pbml0aWFsWm9vbUxldmVsID0gdGhpcy5fdWkuY2FudmFzLnpvb21MZXZlbDtcbiAgICAgIHRoaXMuX3VpLmNhbnZhcy56b29tVG9GaXQoKTtcblxuICAgICAgdGhpcy5fc2V0dXBDdXJzb3IoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSB0aGlja25lc3MgYnV0dG9uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19oYW5kbGVUaGlja25lc3NCdXR0b24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVGhpY2tuZXNzQnV0dG9uKCkge1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlUaGlja25lc3MpIHJldHVybjtcblxuICAgICAgdGhpcy5fdGhpY2tuZXNzQnV0dG9uID0gdGhpcy5fY29udHJvbHNDb250YWluZXIucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LXRoaWNrbmVzcy1idXR0b24nKTtcbiAgICAgIHRoaXMuX3RoaWNrbmVzc0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX29uVGhpY2tuZXNzQnV0dG9uQ2xpY2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBjYWxsZWQgd2hlbiB0aGUgdGhpY2tuZXNzIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uVGhpY2tuZXNzQnV0dG9uQ2xpY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UaGlja25lc3NCdXR0b25DbGljayhlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9kaXNwbGF5VGhpY2tuZXNzID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW50ZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBpbml0YWwgdmFsdWVzIGZvciB0aGlja25lc3MgYW5kIGNvbG9yLlxuICAgICAqIEl0IHdpbGwgcmV0cmlldmUgdGhlbSBmcm9tIHRoZSBvcHRlcmF0aW9uIHVubGVzcyBpdCBoYXMgbm8gdmFsdWVzIHlldC5cbiAgICAgKiBJbiB0aGF0IGNhc2UgaXQgd2lsbCBkZWZhdWx0IHNvbWUgdmFsZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19pbml0Q3VycmVudFZhbHVlcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0Q3VycmVudFZhbHVlcygpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaGlja25lc3MgPSB0aGlzLl9jdXJyZW50VGhpY2tuZXNzIHx8IHRoaXMuX29wZXJhdGlvbi5nZXRMYXN0VGhpY2tuZXNzKCk7XG4gICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSB0aGlzLl9jdXJyZW50Q29sb3IgfHwgdGhpcy5fb3BlcmF0aW9uLmdldExhc3RDb2xvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIGN1cnNvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NldHVwQ3Vyc29yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQ3Vyc29yKCkge1xuICAgICAgdGhpcy5fY3Vyc29yID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignI2ltZ2x5a2l0LWJydXNoLWN1cnNvcicpO1xuICAgICAgdGhpcy5fc2V0Q3Vyc29yU2l6ZSh0aGlzLl9jdXJyZW50VGhpY2tuZXNzICogdGhpcy5fZ2V0TG9uZ2VyU2lkZVNpemUoKSk7XG4gICAgICB0aGlzLl9zZXRDdXJzb3JDb2xvcih0aGlzLl9jdXJyZW50Q29sb3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGluaXRpdGFsIG9wdGlvbnMgdXBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zZXR1cE9wdGlvbnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBPcHRpb25zKCkge1xuICAgICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSB7XG4gICAgICAgIHBhdGhzOiB0aGlzLl9vcGVyYXRpb24uZ2V0UGF0aHMoKS5zbGljZSgwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjYW52YXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NldHVwQ2FudmFzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwQ2FudmFzKCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuX3VpLmNhbnZhcztcblxuICAgICAgdGhpcy5fY2FudmFzID0gdGhpcy5fY2FudmFzQ29udHJvbHMucXVlcnlTZWxlY3RvcignY2FudmFzJyk7XG4gICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBjYW52YXMuc2l6ZS54O1xuICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGNhbnZhcy5zaXplLnk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgb3BlcmF0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0dXBPcGVyYXRpb24nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBPcGVyYXRpb24oKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlID0gISF0aGlzLl91aS5vcGVyYXRpb25zLmJydXNoO1xuICAgICAgdGhpcy5fb3BlcmF0aW9uID0gdGhpcy5fdWkuZ2V0T3JDcmVhdGVPcGVyYXRpb24oJ2JydXNoJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgY29udGFpbmVyLCBhZGRzIGV2ZW50cywgZXRjXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0dXBDb250YWluZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0dXBDb250YWluZXIoKSB7XG4gICAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9jYW52YXNDb250cm9scy5xdWVyeVNlbGVjdG9yKCcuaW1nbHlraXQtY2FudmFzLWJydXNoLWNvbnRhaW5lcicpO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duKTtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgdGhpcy5fb25Nb3VzZURvd24pO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXApO1xuICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fb25Nb3VzZVVwKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX29uTW91c2VNb3ZlKTtcbiAgICAgIHRoaXMuX2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgdGhpcy5fb25Nb3VzZUxlYXZlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBCaW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfYmluZEV2ZW50SGFuZGxlcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICB0aGlzLl9vbk1vdXNlRG93biA9IHRoaXMuX29uTW91c2VEb3duLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9vbk1vdXNlVXAgPSB0aGlzLl9vbk1vdXNlVXAuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VNb3ZlID0gdGhpcy5fb25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX29uTW91c2VMZWF2ZSA9IHRoaXMuX29uTW91c2VMZWF2ZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgdGhlIHNsaWRlciB1c2VkIHRvIGNoYW5nZSB0aGUgYnJ1c2ggc2l6ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3NldHVwU2xpZGVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwU2xpZGVyKCkge1xuICAgICAgaWYgKCF0aGlzLl9kaXNwbGF5VGhpY2tuZXNzKSByZXR1cm47XG5cbiAgICAgIHZhciBzbGlkZXJFbGVtZW50ID0gdGhpcy5fY29udHJvbHMucXVlcnlTZWxlY3RvcignLmltZ2x5a2l0LXNsaWRlcicpO1xuICAgICAgdGhpcy5fc2xpZGVyID0gbmV3IF9saWJTaW1wbGVTbGlkZXIyWydkZWZhdWx0J10oc2xpZGVyRWxlbWVudCwge1xuICAgICAgICBtaW5WYWx1ZTogMC4wMSxcbiAgICAgICAgbWF4VmFsdWU6IDAuMlxuICAgICAgfSk7XG4gICAgICB0aGlzLl9vblRoaWNrbmVzc1VwZGF0ZSA9IHRoaXMuX29uVGhpY2tuZXNzVXBkYXRlLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9zbGlkZXIub24oJ3VwZGF0ZScsIHRoaXMuX29uVGhpY2tuZXNzVXBkYXRlKTtcbiAgICAgIHRoaXMuX3NsaWRlci5zZXRWYWx1ZSh0aGlzLl9jdXJyZW50VGhpY2tuZXNzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHRoZSBjb2xvciBwaWNrZXIgdXNlZCB0byBjaGFuZ2UgdGhlIGJydXNoIGNvbG9yXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfc2V0dXBDb2xvclBpY2tlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXR1cENvbG9yUGlja2VyKCkge1xuICAgICAgaWYgKHRoaXMuX2Rpc3BsYXlUaGlja25lc3MpIHJldHVybjtcblxuICAgICAgdmFyIGNvbG9yUGlja2VyRWxlbWVudCA9IHRoaXMuX2NvbnRyb2xzLnF1ZXJ5U2VsZWN0b3IoJy5pbWdseWtpdC1jb2xvci1waWNrZXInKTtcbiAgICAgIHRoaXMuX2NvbG9yUGlja2VyID0gbmV3IF9saWJDb2xvclBpY2tlcjJbJ2RlZmF1bHQnXSh0aGlzLl91aSwgY29sb3JQaWNrZXJFbGVtZW50KTtcbiAgICAgIHRoaXMuX2NvbG9yUGlja2VyLm9uKCd1cGRhdGUnLCB0aGlzLl9vbkNvbG9yVXBkYXRlLmJpbmQodGhpcykpO1xuICAgICAgdGhpcy5fY29sb3JQaWNrZXIuc2V0VmFsdWUodGhpcy5fY3VycmVudENvbG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSBiYWNrIGJ1dHRvbiBoYXMgYmVlbiBjbGlja2VkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2tCdXR0b25DbGljaycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkJhY2tCdXR0b25DbGljaygpIHtcbiAgICAgIGlmICh0aGlzLl9kaXNwbGF5VGhpY2tuZXNzKSB7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXlUaGlja25lc3MgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50ZXIoKTtcbiAgICAgIH1cblxuICAgICAgX2dldChPYmplY3QuZ2V0UHJvdG90eXBlT2YoQnJ1c2hDb250cm9sLnByb3RvdHlwZSksICdfb25CYWNrQnV0dG9uQ2xpY2snLCB0aGlzKS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGJhY2sgYnV0dG9uIGhhcyBiZWVuIGNsaWNrZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkJhY2snLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25CYWNrKCkge1xuICAgICAgaWYgKCF0aGlzLl9vcGVyYXRpb25FeGlzdGVkQmVmb3JlICYmICF0aGlzLl9vcGVyYXRpb24uZ2V0UGF0aHMoKS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdWkucmVtb3ZlT3BlcmF0aW9uKCdicnVzaCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fb3BlcmF0aW9uLmRpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3VpLmNhbnZhcy5zZXRab29tTGV2ZWwodGhpcy5faW5pdGlhbFpvb21MZXZlbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzZXRzIHRoZSBvcGVyYXRpb24gb3B0aW9ucyB0byB0aGUgaW5pdGlhbCBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVzZXRPcGVyYXRpb25TZXR0aW5ncycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldE9wZXJhdGlvblNldHRpbmdzKCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnNldFBhdGhzKHRoaXMuX2luaXRpYWxPcHRpb25zLnBhdGhzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIHByZXNzZXMgdGhlIG1vdXNlIGJ1dHRvbi5cbiAgICAgKiBIZXJlIHRoZSBwYWludGluZyBwaGFzZSBpcyBzdGFydGVkXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdXNlRG93bicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlRG93bihlKSB7XG4gICAgICB2YXIgcGF0aHMgPSB0aGlzLl9vcGVyYXRpb24uZ2V0UGF0aHMoKS5zbGljZSgwKTtcbiAgICAgIHRoaXMuX29wZXJhdGlvbkV4aXN0ZWRCZWZvcmVEcmF3ID0gISFwYXRocy5sZW5ndGg7XG4gICAgICB0aGlzLl9vcHRpb25zQmVmb3JlRHJhdyA9IHsgcGF0aHM6IHBhdGhzIH07XG5cbiAgICAgIGlmIChfbGliVXRpbHMyWydkZWZhdWx0J10uaXNUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgIHRoaXMuX3Nob3dDdXJzb3IoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0YXJ0UGFpbnQoZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogc3RhcnQgcGFpbnRpbmdcbiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zdGFydFBhaW50JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UGFpbnQoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IHRoaXMuX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbkZyb21FdmVudChldmVudCk7XG4gICAgICB0aGlzLl9wYWludGluZyA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2N1cnJlbnRQYXRoID0gdGhpcy5fb3BlcmF0aW9uLmNyZWF0ZVBhdGgodGhpcy5fY3VycmVudFRoaWNrbmVzcywgdGhpcy5fY3VycmVudENvbG9yKTtcbiAgICAgIHRoaXMuX2N1cnJlbnRQYXRoLmFkZENvbnRyb2xQb2ludChtb3VzZVBvc2l0aW9uKTtcblxuICAgICAgdGhpcy5fcmVkcmF3UGF0aCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHRoZSB0aGUgdXNlcnMgcmVsZWFzZXMgdGhlIG1vdXNlIGJ1dHRvbi5cbiAgICAgKiBIZXJlIHRoZSBwYWludGluZyBwaGFzZSBpcyBzdG9wcGVkXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdXNlVXAnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Nb3VzZVVwKGUpIHtcbiAgICAgIGlmIChfbGliVXRpbHMyWydkZWZhdWx0J10uaXNUb3VjaEV2ZW50KGUpKSB7XG4gICAgICAgIHRoaXMuX2hpZGVDdXJzb3IoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N0b3BQYWludCgpO1xuICAgICAgdGhpcy5fdWkuYWRkSGlzdG9yeSh0aGlzLCB7XG4gICAgICAgIHBhdGhzOiB0aGlzLl9vcHRpb25zQmVmb3JlRHJhdy5wYXRoc1xuICAgICAgfSwgdGhpcy5fb3BlcmF0aW9uRXhpc3RlZEJlZm9yZURyYXcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3BzIHRoZSBwYWludCBwaGFzZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX3N0b3BQYWludCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdG9wUGFpbnQoKSB7XG4gICAgICB0aGlzLl9wYWludGluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZHJhd3MgdGhlIGN1cnJlbnQgcGF0aFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfcmVkcmF3UGF0aCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWRyYXdQYXRoKCkge1xuICAgICAgdGhpcy5fb3BlcmF0aW9uLnJlbmRlckJydXNoQ2FudmFzKHRoaXMuX2NhbnZhcywgdGhpcy5fY2FudmFzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGRyYWdzIHRoZSBtb3VzZS5cbiAgICAgKiBJZiB0aGlzIGhhcHBlbmRzIHdoaWxlIHRoZSBtb3VzZSBidXR0b24gaXMgcHJlc3NlZCxcbiAgICAgKiB0aGUgdmlzaXRlZCBwb2ludHMgZ2V0IGFkZGVkIHRvIHRoZSBwYXRoXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbk1vdXNlTW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlTW92ZShlKSB7XG4gICAgICB2YXIgbW91c2VQb3NpdGlvbiA9IHRoaXMuX2dldFJlbGF0aXZlTW91c2VQb3NpdGlvbkZyb21FdmVudChlKTtcbiAgICAgIGlmICghX2xpYlV0aWxzMlsnZGVmYXVsdCddLmlzVG91Y2hFdmVudChlKSkge1xuICAgICAgICB0aGlzLl9tb3ZlQ3Vyc29yVG8obW91c2VQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3Nob3dDdXJzb3IoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wYWludGluZykge1xuICAgICAgICB0aGlzLl9jdXJyZW50UGF0aC5hZGRDb250cm9sUG9pbnQobW91c2VQb3NpdGlvbik7XG4gICAgICAgIHRoaXMuX3JlZHJhd1BhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGNhbGxlZCB3aGVuIHRoZSB1c2VyIGxlYXZlcyB0aGUgY2FudmFzLlxuICAgICAqIFRoaXMgd2lsbCBhbHNvIHN0b3AgdGhlIHBhaW50aW5nIHBoYXNlXG4gICAgICogQHBhcmFtICB7W3R5cGVdfSBlIFtkZXNjcmlwdGlvbl1cbiAgICAgKiBAcmV0dXJuIHtbdHlwZV19ICAgW2Rlc2NyaXB0aW9uXVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX29uTW91c2VMZWF2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk1vdXNlTGVhdmUoZSkge1xuICAgICAgdGhpcy5faGlkZUN1cnNvcigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIG1vdXNlIHBvc2l0aW9uLCByZWxhdGl2ZSB0byB0aGUgdXBwZXItbGVmdCBjb3JuZXJcbiAgICAgKiBvZiB0aGUgY2FudmFzXG4gICAgICogQHBhcmFtICB7RXZlbnR9IGVcbiAgICAgKiBAcmV0dXJuIHtWZWN0b3IyfSBUaGUgTW91c2UgUG9zaXRpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19nZXRSZWxhdGl2ZU1vdXNlUG9zaXRpb25Gcm9tRXZlbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0UmVsYXRpdmVNb3VzZVBvc2l0aW9uRnJvbUV2ZW50KGUpIHtcbiAgICAgIHZhciBjbGllbnRSZWN0ID0gdGhpcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIG9mZnNldCA9IG5ldyBfbGliTWF0aFZlY3RvcjIyWydkZWZhdWx0J10oY2xpZW50UmVjdC5sZWZ0LCBjbGllbnRSZWN0LnRvcCk7XG4gICAgICB2YXIgYWJzb2x1dGVQb3NpdGlvbiA9IF9saWJVdGlsczJbJ2RlZmF1bHQnXS5nZXRFdmVudFBvc2l0aW9uKGUpLnN1YnRyYWN0KG9mZnNldCk7XG4gICAgICByZXR1cm4gYWJzb2x1dGVQb3NpdGlvbi5kaXZpZGUodGhpcy5fdWkuY2FudmFzLnNpemUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIHRoaWNrbmVzcyBoYXMgYmVlbiBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfb25UaGlja25lc3NVcGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25UaGlja25lc3NVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3NldEN1cnNvclNpemUodGhpcy5fY3VycmVudFRoaWNrbmVzcyAqIHRoaXMuX2dldExvbmdlclNpZGVTaXplKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgY2FsbGVkIHdoZW4gdGhlIGNvbG9yIGhhcyBiZWVuIGNoYW5nZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19vbkNvbG9yVXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uQ29sb3JVcGRhdGUodmFsdWUpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IHZhbHVlO1xuICAgICAgdGhpcy5fc2V0Q3Vyc29yQ29sb3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvbmdlciBzaXplIG9mIHRoZSB1aSBjYW52YXNcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6ICdfZ2V0TG9uZ2VyU2lkZVNpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TG9uZ2VyU2lkZVNpemUoKSB7XG4gICAgICB2YXIgc2l6ZSA9IHRoaXMuX3VpLmNhbnZhcy5zaXplO1xuXG4gICAgICByZXR1cm4gTWF0aC5tYXgoc2l6ZS54LCBzaXplLnkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIG91ciBjdXN0b20gY3Vyc29yIHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb25cbiAgICAgKiBAcGFyYW0gIHtWZWN0b3IyfSBwb3NpdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX21vdmVDdXJzb3JUbycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tb3ZlQ3Vyc29yVG8ocG9zaXRpb24pIHtcbiAgICAgIHZhciBoYWxmVGhpY2tuZXNzID0gdGhpcy5fY3VycmVudFRoaWNrbmVzcyAqIHRoaXMuX2dldExvbmdlclNpZGVTaXplKCkgLyAyLjA7XG4gICAgICB0aGlzLl9jdXJzb3Iuc3R5bGUubGVmdCA9IHBvc2l0aW9uLnggKiB0aGlzLl91aS5jYW52YXMuc2l6ZS54IC0gaGFsZlRoaWNrbmVzcyArICdweCc7XG4gICAgICB0aGlzLl9jdXJzb3Iuc3R5bGUudG9wID0gcG9zaXRpb24ueSAqIHRoaXMuX3VpLmNhbnZhcy5zaXplLnkgLSBoYWxmVGhpY2tuZXNzICsgJ3B4JztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJzZXIgc2l6ZVxuICAgICAqIEBwYXJhbSB7RmxvYXR9IHNpemVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zZXRDdXJzb3JTaXplJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEN1cnNvclNpemUoc2l6ZSkge1xuICAgICAgdGhpcy5fY3Vyc29yLnN0eWxlLndpZHRoID0gc2l6ZSArICdweCc7XG4gICAgICB0aGlzLl9jdXJzb3Iuc3R5bGUuaGVpZ2h0ID0gc2l6ZSArICdweCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3Vyc29yIGNvbG9yXG4gICAgICogQHBhcmFtIHtDb2xvcn0gY29sb3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zZXRDdXJzb3JDb2xvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRDdXJzb3JDb2xvcihjb2xvcikge1xuICAgICAgdGhpcy5fY3Vyc29yLnN0eWxlLmJhY2tncm91bmQgPSBjb2xvci50b0hleCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBjdXJzb3JcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogJ19zaG93Q3Vyc29yJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3dDdXJzb3IoKSB7XG4gICAgICB0aGlzLl9jdXJzb3Iuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGN1cnNvclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnX2hpZGVDdXJzb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZUN1cnNvcigpIHtcbiAgICAgIHRoaXMuX2N1cnNvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIHRoYXQgaXMgYXZhaWxhYmxlIHRvIHRoZSB0ZW1wbGF0ZVxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiAnY29udGV4dCcsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5VGhpY2tuZXNzOiB0aGlzLl9kaXNwbGF5VGhpY2tuZXNzXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcnVzaENvbnRyb2w7XG59KShfY29udHJvbDJbJ2RlZmF1bHQnXSk7XG5cbkJydXNoQ29udHJvbC5wcm90b3R5cGUuaWRlbnRpZmllciA9ICdicnVzaCc7XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IEJydXNoQ29udHJvbDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9jb250cm9scy9icnVzaC1jb250cm9sLmpzXG4gKiogbW9kdWxlIGlkID0gMTExXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJvcGVyYXRpb25zXCI6IHtcblx0XHRcImJyaWdodG5lc3NcIjogXCJCcmlnaHRuZXNzXCIsXG5cdFx0XCJjb250cmFzdFwiOiBcIkNvbnRyYXN0XCIsXG5cdFx0XCJmaWx0ZXJzXCI6IFwiRmlsdGVyc1wiLFxuXHRcdFwiZmxpcFwiOiBcIkZsaXBcIixcblx0XHRcImZyYW1lc1wiOiBcIkZyYW1lc1wiLFxuXHRcdFwicmFkaWFsLWJsdXJcIjogXCJSYWRpYWwgQmx1clwiLFxuXHRcdFwicm90YXRpb25cIjogXCJSb3RhdGlvblwiLFxuXHRcdFwic2F0dXJhdGlvblwiOiBcIlNhdHVyYXRpb25cIixcblx0XHRcInN0aWNrZXJzXCI6IFwiU3RpY2tlcnNcIixcblx0XHRcInRleHRcIjogXCJUZXh0XCIsXG5cdFx0XCJ0aWx0LXNoaWZ0XCI6IFwiVGlsdC1TaGlmdFwiLFxuXHRcdFwiY3JvcFwiOiBcIkNyb3BcIixcblx0XHRcImJydXNoXCI6IFwiQnJ1c2hcIlxuXHR9LFxuXHRcInRvcC1jb250cm9sc1wiOiB7XG5cdFx0XCJuZXdcIjogXCJOZXdcIixcblx0XHRcInVuZG9cIjogXCJVbmRvXCIsXG5cdFx0XCJleHBvcnRcIjogXCJFeHBvcnRcIixcblx0XHRcInpvb21cIjogXCJab29tXCJcblx0fSxcblx0XCJzcGxhc2hcIjoge1xuXHRcdFwidXBsb2FkXCI6IHtcblx0XHRcdFwiaGVhZGxpbmVcIjogXCJVcGxvYWQgYSBwaWN0dXJlXCIsXG5cdFx0XHRcImRlc2NyaXB0aW9uXCI6IFwiQ2xpY2sgaGVyZSB0byB1cGxvYWQgYSBwaWN0dXJlIGZyb20geW91ciBsaWJyYXJ5IG9yIGp1c3QgZHJhZyBhbmQgZHJvcFwiXG5cdFx0fSxcblx0XHRcIm9yXCI6IFwib3JcIixcblx0XHRcIndlYmNhbVwiOiB7XG5cdFx0XHRcImhlYWRsaW5lXCI6IFwiVGFrZSBhIHBpY3R1cmVcIixcblx0XHRcdFwiZGVzY3JpcHRpb25cIjogXCJDbGljayBoZXJlIHRvIHRha2UgYSBwaWN0dXJlIHdpdGggeW91ciB3ZWJjYW0gb3IgcGhvbmVcIlxuXHRcdH1cblx0fSxcblx0XCJnZW5lcmljXCI6IHtcblx0XHRcImxvYWRpbmdcIjogXCJMb2FkaW5nXCIsXG5cdFx0XCJleHBvcnRpbmdcIjogXCJFeHBvcnRpbmdcIixcblx0XHRcImltcG9ydGluZ1wiOiBcIkltcG9ydGluZ1wiLFxuXHRcdFwiY29sb3JcIjogXCJDb2xvclwiLFxuXHRcdFwiZXJyb3JfaGVhZGxpbmVcIjogXCJBbiBlcnJvciBoYXMgb2NjdXJyZWQuXCIsXG5cdFx0XCJ3YXJuaW5nX2hlYWRsaW5lXCI6IFwiV2FybmluZyFcIlxuXHR9LFxuXHRcImNvbnRyb2xzXCI6IHtcblx0XHRcImZyYW1lc1wiOiB7XG5cdFx0XHRcImNvbG9yXCI6IFwiQ29sb3JcIlxuXHRcdH0sXG5cdFx0XCJicnVzaFwiOiB7XG5cdFx0XHRcImNvbG9yXCI6IFwiQ29sb3JcIlxuXHRcdH0sXG5cdFx0XCJ0ZXh0XCI6IHtcblx0XHRcdFwiZm9yZWdyb3VuZFwiOiBcIkZvcmVncm91bmRcIixcblx0XHRcdFwiYmFja2dyb3VuZFwiOiBcIkJhY2tncm91bmRcIlxuXHRcdH1cblx0fSxcblx0XCJlcnJvcnNcIjoge1xuXHRcdFwiV0VCR0xfQ09OVEVYVF9MT1NUXCI6IFwiWW91ciBicm93c2VyIHRvb2sgdG9vIGxvbmcgdG8gcmVuZGVyIHRoZSBpbWFnZS4gUGxlYXNlIHRyeSBhcHBseWluZyBsZXNzIG9wZXJhdGlvbnMuXCIsXG5cdFx0XCJXRUJHTF9DT05URVhUX0xPU1RfTElNSVRcIjogXCJZb3VyIGJyb3dzZXIgZmFpbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIHJlbmRlcmluZyB0aGUgaW1hZ2UuXCJcblx0fSxcblx0XCJ3YXJuaW5nc1wiOiB7XG5cdFx0XCJpbWFnZV9yZXNpemVkXCI6IFwiWW91ciBpbWFnZSBleGNlZWRzIHRoZSBtYXhpbXVtIHNpemUgb2YgJDEgbWVnYXBpeGVscyBhbmQgaGFzIHRoZXJlZm9yZSBiZWVuIHJlc2l6ZWQgdG8gJDJ4JDMgcGl4ZWxzLlwiXG5cdH1cbn07XG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3VpL25pZ2h0L2xhbmcvZW4uanNvblxuICoqIG1vZHVsZSBpZCA9IDExMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwibW9kdWxlLmV4cG9ydHMgPSB7XG5cdFwib3BlcmF0aW9uc1wiOiB7XG5cdFx0XCJicmlnaHRuZXNzXCI6IFwiSGVsbGlna2VpdFwiLFxuXHRcdFwiY29udHJhc3RcIjogXCJLb250cmFzdFwiLFxuXHRcdFwiZmlsdGVyc1wiOiBcIkZpbHRlclwiLFxuXHRcdFwiZmxpcFwiOiBcIlNwaWVnZWxuXCIsXG5cdFx0XCJmcmFtZXNcIjogXCJSYWhtZW5cIixcblx0XHRcInJhZGlhbC1ibHVyXCI6IFwiUmFkaWFsIEJsdXJcIixcblx0XHRcInJvdGF0aW9uXCI6IFwiRHJlaHVuZ1wiLFxuXHRcdFwic2F0dXJhdGlvblwiOiBcIlPDpHR0aWd1bmdcIixcblx0XHRcInN0aWNrZXJzXCI6IFwiU3RpY2tlclwiLFxuXHRcdFwidGV4dFwiOiBcIlRleHRcIixcblx0XHRcInRpbHQtc2hpZnRcIjogXCJUaWx0LVNoaWZ0XCIsXG5cdFx0XCJjcm9wXCI6IFwiWnVzY2huZWlkZW5cIixcblx0XHRcImJydXNoXCI6IFwiTWFsZW5cIlxuXHR9LFxuXHRcInRvcC1jb250cm9sc1wiOiB7XG5cdFx0XCJuZXdcIjogXCJOZXVcIixcblx0XHRcInVuZG9cIjogXCJSw7xja2fDpG5naWdcIixcblx0XHRcImV4cG9ydFwiOiBcIkV4cG9ydGllcmVuXCIsXG5cdFx0XCJ6b29tXCI6IFwiWm9vbVwiXG5cdH0sXG5cdFwic3BsYXNoXCI6IHtcblx0XHRcInVwbG9hZFwiOiB7XG5cdFx0XHRcImhlYWRsaW5lXCI6IFwiQmlsZCBob2NobGFkZW5cIixcblx0XHRcdFwiZGVzY3JpcHRpb25cIjogXCJLbGlja2UgaGllciwgdW0gZWluIEJpbGQgaG9jaHp1bGFkZW4gb2RlciB6aWVoZSBlaW5lIEJpbGRkYXRlaSBoaWVyIGhlclwiXG5cdFx0fSxcblx0XHRcIm9yXCI6IFwib2RlclwiLFxuXHRcdFwid2ViY2FtXCI6IHtcblx0XHRcdFwiaGVhZGxpbmVcIjogXCJGb3RvIG1hY2hlblwiLFxuXHRcdFx0XCJkZXNjcmlwdGlvblwiOiBcIktsaWNrZSBoaWVyLCB1bSBlaW4gRm90byBtaXQgZGVpbmVyIFdlYmNhbSBvZGVyIGRlaW5lbSBTbWFydHBob25lIHp1IG1hY2hlblwiXG5cdFx0fVxuXHR9LFxuXHRcImdlbmVyaWNcIjoge1xuXHRcdFwibG9hZGluZ1wiOiBcIkxhZGVuXCIsXG5cdFx0XCJleHBvcnRpbmdcIjogXCJFeHBvcnRpZXJlXCIsXG5cdFx0XCJpbXBvcnRpbmdcIjogXCJJbXBvcnRpZXJlXCIsXG5cdFx0XCJlcnJvcl9oZWFkbGluZVwiOiBcIkVzIGlzdCBlaW4gRmVobGVyIGF1ZmdldHJldGVuLlwiLFxuXHRcdFwid2FybmluZ19oZWFkbGluZVwiOiBcIldhcm51bmchXCJcblx0fSxcblx0XCJjb250cm9sc1wiOiB7XG5cdFx0XCJmcmFtZXNcIjoge1xuXHRcdFx0XCJjb2xvclwiOiBcIkZhcmJlXCJcblx0XHR9LFxuXHRcdFwiYnJ1c2hcIjoge1xuXHRcdFx0XCJjb2xvclwiOiBcIkZhcmJlXCJcblx0XHR9LFxuXHRcdFwidGV4dFwiOiB7XG5cdFx0XHRcImZvcmVncm91bmRcIjogXCJUZXh0XCIsXG5cdFx0XHRcImJhY2tncm91bmRcIjogXCJIaW50ZXJncnVuZFwiXG5cdFx0fVxuXHR9LFxuXHRcImVycm9yc1wiOiB7XG5cdFx0XCJjb250ZXh0X2xvc3RcIjogXCJEZWluIEJyb3dzZXIgaGF0IHp1IGxhbmdlIGdlYnJhdWNodCwgdW0gZGFzIEJpbGQgenUgZ2VuZXJpZXJlbi4gQml0dGUgdmVyc3VjaGUgZXMgbm9jaCBlaW5tYWwuXCIsXG5cdFx0XCJjb250ZXh0X2xvc3RfbGltaXRcIjogXCJCaWxkLUdlbmVyaWVydW5nIGlzdCBtZWhybWFscyBmZWhsZ2VzY2hsYWdlbi5cIlxuXHR9LFxuXHRcIndhcm5pbmdzXCI6IHtcblx0XHRcImltYWdlX3Jlc2l6ZWRcIjogXCJEZWluIEJpbGQgw7xiZXJzY2hyZWl0ZXQgZGllIG1heGltYWxlIEdyw7bDn2Ugdm9uICQxIE1lZ2FwaXhlbG4gdW5kIHd1cmRlIGRhaGVyIGF1ZiAkMngkMyBQaXhlbCB2ZXJrbGVpbmVydC5cIlxuXHR9XG59O1xuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi91aS9uaWdodC9sYW5nL2RlLmpzb25cbiAqKiBtb2R1bGUgaWQgPSAxMTNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=